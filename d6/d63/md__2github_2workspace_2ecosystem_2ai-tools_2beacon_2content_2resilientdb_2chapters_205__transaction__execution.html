#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_transaction_execution</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d63/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_205__transaction__execution.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_transaction_execution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> layout: default title: 'Chapter 5: <a class="el" href="../../df/d28/classTransaction.html">Transaction</a> Execution' parent: 'ResilientDB' </p>
<h2><a class="anchor" id="autotoc_md123"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md124"></a>
Chapter 5: Transaction Execution</h1>
<p>In the previous chapter, <a class="el" href="../../d2/d6d/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_204__message__transaction__collection.html">Chapter 4: Message/Transaction Collection</a>, we saw how ResilientDB meticulously collects and organizes all the messages related to a specific transaction until consensus is reached and the transaction is declared <code>READY_EXECUTE</code>. It's like all the managers have finally approved an important company decision (like purchasing new equipment).</p>
<p>But approval is just one step! Someone actually needs to <em>act</em> on that decision â€“ place the order, update the inventory, and record the purchase in the company's books. Similarly, once ResilientDB replicas agree on a transaction (e.g., "Store the key 'UserScore' with the value '1000'"), something needs to actually <em>perform</em> that change in the database state.</p>
<p>Welcome to Chapter 5! We'll explore the <b><a class="el" href="../../df/d28/classTransaction.html">Transaction</a> Execution</b> layer. This is where the agreed-upon transactions meet the actual database, making the changes permanent.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
The Need for Execution: Making Changes Happen</h2>
<p>Imagine ResilientDB is a shared, super-secure accounting ledger run by a committee (the replicas).</p>
<ul>
<li>A user submits an invoice (a transaction request, see Chapter 1).</li>
<li>The committee discusses and votes until they agree the invoice is valid and in the correct order (consensus, Chapter 3).</li>
<li>The approved invoice is carefully filed and tracked (Chapter 4).</li>
</ul>
<p>Now what? The ledger hasn't actually been updated yet! We need an <b>accountant</b> to take the approved invoice and officially record the transaction in the ledger (the database state). This "accountant" role is played by the <a class="el" href="../../df/d28/classTransaction.html">Transaction</a> Execution layer.</p>
<p>This layer ensures that:</p>
<ol type="1">
<li>Transactions are executed in the exact order determined by consensus.</li>
<li>The correct logic is applied based on the <em>type</em> of transaction (e.g., updating a key-value store is different from transferring a digital token).</li>
<li>The database state accurately reflects the history of agreed-upon operations.</li>
</ol>
<h2><a class="anchor" id="autotoc_md126"></a>
Meet the Execution Team: <code>TransactionExecutor</code> and <code>TransactionManager</code></h2>
<p>Two key components work together to handle execution:</p>
<ol type="1">
<li><b><code>TransactionExecutor</code>:</b> The <b>Execution Coordinator</b>.<ul>
<li><b>Job:</b> Receives the finalized, ordered transactions from the consensus/collection layer (Chapter 4). It manages the flow, ensuring transactions are executed sequentially (or sometimes out-of-order if configured) and handles sending responses back.</li>
<li><b>Analogy:</b> Think of this as the <b>accounting department head</b>. They receive the approved invoices from management, ensure they are processed in the right order (by sequence number), and pass them to the right specialist accountant. They also coordinate sending confirmation receipts (responses) back.</li>
<li><b>Function:</b> Takes committed <code>Request</code> objects, puts them in an internal queue, orders them strictly by sequence number, and calls upon a <code>TransactionManager</code> to perform the actual work for each transaction. It also handles notifying other parts of the system about progress.</li>
</ul>
</li>
<li><b><code>TransactionManager</code>:</b> The <b>Execution Specialist</b>.<ul>
<li><b>Job:</b> Defines <em>how</em> to execute a specific <em>type</em> of transaction. ResilientDB supports different data models (Key-Value, UTXO, Smart Contracts), and each needs different execution logic. <code>TransactionManager</code> is an <em>abstract base class</em> (like a job description template), and specific implementations handle the details.</li>
<li><b>Analogy:</b> This is the <b>specialist accountant</b>. One accountant might handle Accounts Payable (like KV Set/Get), another handles Payroll (like UTXO transfers), and another handles complex project budgets (like Smart Contracts). Each knows the specific rules for their domain.</li>
<li><b>Function:</b> Provides the concrete <code>ExecuteBatch</code> or <code>ExecuteData</code> method that the <code>TransactionExecutor</code> calls. Implementations like <code>KVExecutor</code>, <code><a class="el" href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a></code>, and <code><a class="el" href="../../d8/d32/classContractTransactionManager.html">ContractTransactionManager</a></code> inherit from <code>TransactionManager</code> and contain the logic to interact with the underlying storage or state for their specific data type.</li>
</ul>
</li>
</ol>
<p>The <code>TransactionExecutor</code> coordinates <em>when</em> to execute, while the specific <code>TransactionManager</code> implementation decides <em>how</em> to execute.</p>
<h2><a class="anchor" id="autotoc_md127"></a>
How It Works: Executing a Key-Value Transaction</h2>
<p>Let's follow a simple <code>Set("myKey", "myValue")</code> transaction after it has been agreed upon by consensus (sequence number <code>N=101</code>) and marked <code>READY_EXECUTE</code> by the <code>TransactionCollector</code> from Chapter 4.</p>
<ol type="1">
<li><p class="startli"><b>Commit Trigger:</b> The <code>TransactionCollector</code> for sequence <code>101</code> calls <code>TransactionExecutor::Commit(request_101)</code>.</p>
<p class="startli"><code>cpp // Inside TransactionCollector::Commit() - simplified // (from <a class="el" href="../../d4/d5b/transaction__collector_8cpp.html">platform/consensus/ordering/pbft/transaction_collector.cpp</a>) if (executor_ &amp;&amp; main_request_) { // Pass the main request (containing the Set command) to the executor executor_-&gt;Commit(std::move(main_request_)); } </code></p>
<p class="startli">This hands off the approved transaction to the execution coordinator.</p>
</li>
<li><p class="startli"><b>Executor Enqueues:</b> <code>TransactionExecutor::Commit</code> receives <code>request_101</code> and pushes it onto an internal queue (<code>commit_queue_</code>) waiting to be ordered.</p>
<p class="startli"><code>cpp // Inside TransactionExecutor::Commit() - simplified // (from <a class="el" href="../../d7/d24/transaction__executor_8cpp.html">platform/consensus/execution/transaction_executor.cpp</a>) int TransactionExecutor::Commit(std::unique_ptr&lt;Request&gt; message) { global_stats_-&gt;IncPendingExecute(); // ... (potential handling for out-of-order execution) ... commit_queue_.Push(std::move(message)); // Add to the ordering queue return 0; } </code></p>
</li>
<li><p class="startli"><b>Ordering Thread:</b> A background thread (<code>ordering_thread_</code>) in <code>TransactionExecutor</code> monitors <code>commit_queue_</code>. It pulls <code>request_101</code>. It checks if <code>101</code> is the <em>next expected sequence number</em> (<code>next_execute_seq_</code>). If <code>next_execute_seq_</code> is indeed <code>101</code>, the thread moves <code>request_101</code> to another queue (<code>execute_queue_</code>) and increments <code>next_execute_seq_</code> to <code>102</code>. (If <code>101</code> arrived but <code>next_execute_seq_</code> was still <code>100</code>, it would wait.)</p>
<p class="startli"><code>cpp // Inside TransactionExecutor::OrderMessage() - simplified logic // (from <a class="el" href="../../d7/d24/transaction__executor_8cpp.html">platform/consensus/execution/transaction_executor.cpp</a>) while (!IsStop()) { auto message = commit_queue_.Pop(); // Get from commit queue if (message != nullptr) { if (next_execute_seq_ &gt; message-&gt;seq()) continue; // Already done AddNewData(std::move(message)); // Add to pending candidates map } // Check if the next expected message is in candidates std::unique_ptr&lt;Request&gt; next_message = GetNextData(); if (next_message != nullptr) { // Found the next one! execute_queue_.Push(std::move(next_message)); // Push to execute queue next_execute_seq_++; // Expect the following sequence number now // ... (notify others about sequence update) ... } // ... (loop/wait) ... } </code></p>
</li>
<li><b>Execution Thread:</b> Another background thread (<code>execute_thread_</code>) monitors <code>execute_queue_</code>. It pulls <code>request_101</code>.</li>
<li><p class="startli"><b>Executor Calls Manager:</b> The <code>execute_thread_</code> calls <code>TransactionExecutor::Execute(request_101)</code>. Inside <code>Execute</code>, it parses the raw data from the request into a <code>BatchUserRequest</code> (which might contain multiple client sub-requests). Crucially, it then calls the <code>ExecuteBatch</code> method of the configured <code>TransactionManager</code>.</p>
<p class="startli">```cpp // Inside TransactionExecutor::Execute() - simplified // (from <a class="el" href="../../d7/d24/transaction__executor_8cpp.html">platform/consensus/execution/transaction_executor.cpp</a>) void TransactionExecutor::Execute(std::unique_ptr&lt;Request&gt; request, bool need_execute /*= true*/) { BatchUserRequest batch_request; // Contains one or more client ops if (!batch_request.ParseFromString(request-&gt;data())) { /* error */ } // ... copy seq, hash etc. from request to batch_request ...</p>
<p class="startli">std::unique_ptr&lt;BatchUserResponse&gt; response; if (transaction_manager_ &amp;&amp; need_execute) { // *** Call the configured TransactionManager *** response = transaction_manager_-&gt;ExecuteBatch(batch_request); } // ... handle response, call post_exec_func_ ... global_stats_-&gt;IncExecuteDone(); } ```</p>
</li>
<li><p class="startli"><b>Manager Delegates (KVExecutor):</b> The <code>transaction_manager_</code> pointer in <code>TransactionExecutor</code> actually points to a specific implementation, like <code>KVExecutor</code>. The base <code>TransactionManager::ExecuteBatch</code> often just loops through sub-requests and calls <code>ExecuteData</code>. The <em>derived</em> class (<code>KVExecutor</code>) provides the real logic for <code>ExecuteData</code>.</p>
<p class="startli"><code>cpp // Base class default implementation // (from <a class="el" href="../../d1/d14/transaction__manager_8cpp.html">executor/common/transaction_manager.cpp</a>) std::unique_ptr&lt;BatchUserResponse&gt; TransactionManager::ExecuteBatch( const BatchUserRequest&amp; request) { auto batch_response = std::make_unique&lt;BatchUserResponse&gt;(); for (auto&amp; sub_request : request.user_requests()) { // Call the virtual ExecuteData method for each sub-request std::unique_ptr&lt;std::string&gt; response = ExecuteData(sub_request.request().data()); // ... add response to batch_response ... } return batch_response; } </code></p>
</li>
<li><p class="startli"><b>KVExecutor Executes:</b> <code>KVExecutor::ExecuteData</code> is called with the data for the <code>Set("myKey", "myValue")</code> operation. It parses this data into a <code>KVRequest</code>. It checks the command (<code>KVRequest::SET</code>) and calls its internal <code>Set</code> method.</p>
<p class="startli">```cpp // Inside KVExecutor::ExecuteData() - simplified // (from <a class="el" href="../../dd/d28/kv__executor_8cpp.html">executor/kv/kv_executor.cpp</a>) std::unique_ptr&lt;std::string&gt; KVExecutor::ExecuteData(
        const std::string&amp; request_data) { KVRequest kv_request; KVResponse kv_response; if (!kv_request.ParseFromString(request_data)) { /* error */ return nullptr; }</p>
<p class="startli">if (kv_request.cmd() == KVRequest::SET) { // Call the internal method to handle SET Set(kv_request.key(), kv_request.value()); } else if (kv_request.cmd() == KVRequest::GET) { // ... handle GET ... } // ... other commands ...</p>
<p class="startli">// ... package kv_response into string ... return resp_str; } ```</p>
</li>
<li><p class="startli"><b>KVExecutor Interacts with Storage:</b> The <code>KVExecutor::Set</code> method interacts with the underlying <code>Storage</code> layer (Chapter 6) to actually write the key-value pair.</p>
<p class="startli"><code>cpp // Inside KVExecutor::Set() - simplified // (from <a class="el" href="../../dd/d28/kv__executor_8cpp.html">executor/kv/kv_executor.cpp</a>) void KVExecutor::Set(const std::string&amp; key, const std::string&amp; value) { // Call the storage layer to perform the write storage_-&gt;SetValue(key, value); } </code></p>
</li>
<li><b>Response:</b> The result (success/failure, or data for a <code>GET</code>) bubbles back up. <code>TransactionExecutor</code> receives the <code>BatchUserResponse</code> and uses its <code>post_exec_func_</code> callback to potentially send a reply back to the original client proxy or perform other actions.</li>
</ol>
<h2><a class="anchor" id="autotoc_md128"></a>
Visualizing the Flow</h2>
<p>Here's a simplified sequence diagram showing the execution of sequence number <code>N</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant TC as TransactionCollector (Seq N)</div>
<div class="line">    participant TxExec as TransactionExecutor</div>
<div class="line">    participant OrderThr as OrderingThread (in TxExec)</div>
<div class="line">    participant ExecThr as ExecutionThread (in TxExec)</div>
<div class="line">    participant TxMgr as TransactionManager (e.g., KVExecutor)</div>
<div class="line">    participant Store as Storage Layer</div>
<div class="line"> </div>
<div class="line">    Note over TC: Consensus reached for Seq N</div>
<div class="line">    TC-&gt;&gt;+TxExec: Commit(Request N)</div>
<div class="line">    TxExec-&gt;&gt;OrderThr: Push Request N to commit_queue_</div>
<div class="line">    OrderThr-&gt;&gt;OrderThr: Check if N == next_execute_seq_</div>
<div class="line">    alt N is the next sequence number</div>
<div class="line">        OrderThr-&gt;&gt;ExecThr: Push Request N to execute_queue_</div>
<div class="line">        OrderThr-&gt;&gt;OrderThr: Increment next_execute_seq_</div>
<div class="line">    else N is not the next sequence number</div>
<div class="line">        OrderThr-&gt;&gt;OrderThr: Wait / Store in candidates_</div>
<div class="line">    end</div>
<div class="line">    ExecThr-&gt;&gt;ExecThr: Pop Request N from execute_queue_</div>
<div class="line">    ExecThr-&gt;&gt;+TxMgr: ExecuteBatch(Parsed Request N Data)</div>
<div class="line">    TxMgr-&gt;&gt;TxMgr: (Loop if Batch) Call ExecuteData(SubRequest)</div>
<div class="line">    TxMgr-&gt;&gt;+Store: SetValue(&quot;myKey&quot;, &quot;myValue&quot;) / Other Storage Op</div>
<div class="line">    Store--&gt;&gt;-TxMgr: Storage Op Result (Success/Fail/Data)</div>
<div class="line">    TxMgr--&gt;&gt;-ExecThr: Execution Result (Response Data)</div>
<div class="line">    Note over ExecThr: Handle response (call post_exec_func_)</div>
</div><!-- fragment --><p>This diagram shows the handoff from collection (<code>TC</code>) to the executor (<code>TxExec</code>), the internal ordering and execution threads, the call to the specific manager (<code>TxMgr</code>), and the final interaction with the <code>Storage</code> layer.</p>
<h2><a class="anchor" id="autotoc_md129"></a>
Different Specialists: <code>KVExecutor</code>, <code>UTXOExecutor</code>, <code>ContractExecutor</code></h2>
<p>ResilientDB uses the <code>TransactionManager</code> interface to support different application types. Each inherits from the base <code>TransactionManager</code> and provides its own <code>ExecuteData</code> or <code>ExecuteBatch</code> logic:</p>
<ul>
<li><p class="startli"><b><code>KVExecutor</code> (<code><a class="el" href="../../d1/d72/kv__executor_8h.html">executor/kv/kv_executor.h</a></code>, <code>.cpp</code>):</b></p><ul>
<li>Handles Key-Value operations (<code>SET</code>, <code>GET</code>, <code>GETRANGE</code>, etc.).</li>
<li>Parses <code>KVRequest</code>.</li>
<li>Interacts with <code>Storage</code> using methods like <code>SetValue</code>, <code>GetValue</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// From executor/kv/kv_executor.h</span></div>
<div class="line"><span class="keyword">class </span>KVExecutor : <span class="keyword">public</span> TransactionManager {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  KVExecutor(std::unique_ptr&lt;Storage&gt; storage);</div>
<div class="line">  std::unique_ptr&lt;std::string&gt; ExecuteData(<span class="keyword">const</span> std::string&amp; request) <span class="keyword">override</span>;</div>
<div class="line">  <span class="comment">// ... other methods ...</span></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::unique_ptr&lt;Storage&gt; storage_; <span class="comment">// Holds the storage implementation</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><p class="startli"><b><code><a class="el" href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a></code> (<code><a class="el" href="../../d9/dbb/utxo__executor_8h.html">executor/utxo/executor/utxo_executor.h</a></code>, <code>.cpp</code>):</b></p><ul>
<li>Handles transactions based on the Unspent <a class="el" href="../../df/d28/classTransaction.html">Transaction</a> Output model (like Bitcoin).</li>
<li>Parses <code>UTXORequest</code>.</li>
<li>Interacts with specialized UTXO managers (<code><a class="el" href="../../df/d28/classTransaction.html">Transaction</a></code>, <code><a class="el" href="../../de/d7d/classWallet.html">Wallet</a></code>) which likely use the <code>Storage</code> layer underneath.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// From executor/utxo/executor/utxo_executor.h</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a> : <span class="keyword">public</span> <a class="code hl_function" href="../../df/d01/classresdb_1_1TransactionManager.html#a2052d912a5ff5488106cf3af32ca66b6">TransactionManager</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="../../d2/d1d/classUTXOExecutor.html#ac88c78d485fb83492cc6d88c71fe18e6">UTXOExecutor</a>(<span class="keyword">const</span> Config&amp; <a class="code hl_namespace" href="../../d6/d7f/namespaceconfig.html">config</a>, <a class="code hl_class" href="../../df/d28/classTransaction.html">Transaction</a>* transaction, <a class="code hl_class" href="../../de/d7d/classWallet.html">Wallet</a>* wallet);</div>
<div class="line">  std::unique_ptr&lt;std::string&gt; <a class="code hl_function" href="../../d2/d1d/classUTXOExecutor.html#a2d44174ea25aec2f9da2ce6f6979123d">ExecuteData</a>(<span class="keyword">const</span> std::string&amp; request) <span class="keyword">override</span>;</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_class" href="../../df/d28/classTransaction.html">Transaction</a>* transaction_; <span class="comment">// Manages UTXO transaction logic</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassTransaction_html"><div class="ttname"><a href="../../df/d28/classTransaction.html">Transaction</a></div><div class="ttdef"><b>Definition</b> <a href="../../d0/db6/transaction_8h_source.html#l00031">transaction.h:31</a></div></div>
<div class="ttc" id="aclassUTXOExecutor_html"><div class="ttname"><a href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a></div><div class="ttdef"><b>Definition</b> <a href="../../d9/dbb/utxo__executor_8h_source.html#l00032">utxo_executor.h:32</a></div></div>
<div class="ttc" id="aclassUTXOExecutor_html_a2d44174ea25aec2f9da2ce6f6979123d"><div class="ttname"><a href="../../d2/d1d/classUTXOExecutor.html#a2d44174ea25aec2f9da2ce6f6979123d">UTXOExecutor::ExecuteData</a></div><div class="ttdeci">std::unique_ptr&lt; std::string &gt; ExecuteData(const std::string &amp;request) override</div><div class="ttdef"><b>Definition</b> <a href="../../d5/da3/utxo__executor_8cpp_source.html#l00035">utxo_executor.cpp:35</a></div></div>
<div class="ttc" id="aclassUTXOExecutor_html_ac88c78d485fb83492cc6d88c71fe18e6"><div class="ttname"><a href="../../d2/d1d/classUTXOExecutor.html#ac88c78d485fb83492cc6d88c71fe18e6">UTXOExecutor::UTXOExecutor</a></div><div class="ttdeci">UTXOExecutor(const Config &amp;config, Transaction *transaction, Wallet *wallet)</div><div class="ttdef"><b>Definition</b> <a href="../../d5/da3/utxo__executor_8cpp_source.html#l00029">utxo_executor.cpp:29</a></div></div>
<div class="ttc" id="aclassWallet_html"><div class="ttname"><a href="../../de/d7d/classWallet.html">Wallet</a></div><div class="ttdef"><b>Definition</b> <a href="../../d0/df4/wallet_8h_source.html#l00027">wallet.h:27</a></div></div>
<div class="ttc" id="aclassresdb_1_1TransactionManager_html_a2052d912a5ff5488106cf3af32ca66b6"><div class="ttname"><a href="../../df/d01/classresdb_1_1TransactionManager.html#a2052d912a5ff5488106cf3af32ca66b6">resdb::TransactionManager::TransactionManager</a></div><div class="ttdeci">TransactionManager(bool is_out_of_order=false, bool need_response=true)</div><div class="ttdef"><b>Definition</b> <a href="../../d1/d14/transaction__manager_8cpp_source.html#l00026">transaction_manager.cpp:26</a></div></div>
<div class="ttc" id="anamespaceconfig_html"><div class="ttname"><a href="../../d6/d7f/namespaceconfig.html">config</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/d0d/ai-tools_2mcp_2resilientdb-mcp_2config_8py_source.html#l00001">config.py:1</a></div></div>
</div><!-- fragment --></li>
<li><p class="startli"><b><code><a class="el" href="../../d8/d32/classContractTransactionManager.html">ContractTransactionManager</a></code> (<code><a class="el" href="../../d8/d98/contract__executor_8h.html">executor/contract/executor/contract_executor.h</a></code>, <code>.cpp</code>):</b></p><ul>
<li>Handles deploying and executing smart contracts.</li>
<li>Parses <code>contract::Request</code>.</li>
<li>Interacts with <code>ContractManager</code> and <code>AddressManager</code> to manage contract state and execution environments (like WASM).</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// From executor/contract/executor/contract_executor.h</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../d8/d32/classContractTransactionManager.html">ContractTransactionManager</a> : <span class="keyword">public</span> <a class="code hl_function" href="../../df/d01/classresdb_1_1TransactionManager.html#a2052d912a5ff5488106cf3af32ca66b6">TransactionManager</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="../../d8/d32/classContractTransactionManager.html#aae0e1f0ef954144b0f4d0baeb9a9f232">ContractTransactionManager</a>(<span class="keywordtype">void</span>);</div>
<div class="line">  std::unique_ptr&lt;std::string&gt; <a class="code hl_function" href="../../d8/d32/classContractTransactionManager.html#a346f7a17c8b79f6228ec23b0aa7066f3">ExecuteData</a>(<span class="keyword">const</span> std::string&amp; request) <span class="keyword">override</span>;</div>
<div class="line">  <span class="comment">// ... other methods ...</span></div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::unique_ptr&lt;ContractManager&gt; contract_manager_; <span class="comment">// Manages contract logic</span></div>
<div class="line">  std::unique_ptr&lt;AddressManager&gt; address_manager_; <span class="comment">// Manages addresses</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassContractTransactionManager_html"><div class="ttname"><a href="../../d8/d32/classContractTransactionManager.html">ContractTransactionManager</a></div><div class="ttdef"><b>Definition</b> <a href="../../d8/d98/contract__executor_8h_source.html#l00032">contract_executor.h:32</a></div></div>
<div class="ttc" id="aclassContractTransactionManager_html_a346f7a17c8b79f6228ec23b0aa7066f3"><div class="ttname"><a href="../../d8/d32/classContractTransactionManager.html#a346f7a17c8b79f6228ec23b0aa7066f3">ContractTransactionManager::ExecuteData</a></div><div class="ttdeci">std::unique_ptr&lt; std::string &gt; ExecuteData(const std::string &amp;request) override</div><div class="ttdef"><b>Definition</b> <a href="../../d4/dba/contract__executor_8cpp_source.html#l00031">contract_executor.cpp:31</a></div></div>
<div class="ttc" id="aclassContractTransactionManager_html_aae0e1f0ef954144b0f4d0baeb9a9f232"><div class="ttname"><a href="../../d8/d32/classContractTransactionManager.html#aae0e1f0ef954144b0f4d0baeb9a9f232">ContractTransactionManager::ContractTransactionManager</a></div><div class="ttdeci">ContractTransactionManager(Storage *storage)</div><div class="ttdef"><b>Definition</b> <a href="../../d4/dba/contract__executor_8cpp_source.html#l00027">contract_executor.cpp:27</a></div></div>
</div><!-- fragment --></li>
</ul>
<p>The beauty of this design is that the <code>TransactionExecutor</code> doesn't need to know the specifics of KV, UTXO, or Contracts. It just needs a <code>TransactionManager</code> object and calls its standard <code>ExecuteBatch</code> method. The specific implementation handles the rest. This is configured when ResilientDB starts, based on the desired mode of operation (see Chapter 8: ResilientDB Configuration (ResDBConfig)).</p>
<h2><a class="anchor" id="autotoc_md130"></a>
Conclusion</h2>
<p>You've now seen how ResilientDB takes transactions that have been agreed upon and actually applies their changes to the database state!</p>
<ul>
<li>We learned that the <b><code>TransactionExecutor</code></b> acts as the <b>coordinator</b>, receiving committed transactions, ensuring they execute in the correct order (using sequence numbers), and managing the overall execution flow.</li>
<li>We met the <b><code>TransactionManager</code></b> interface and its specific implementations (<code>KVExecutor</code>, <code><a class="el" href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a></code>, <code><a class="el" href="../../d8/d32/classContractTransactionManager.html">ContractTransactionManager</a></code>) which act as <b>specialists</b>, knowing <em>how</em> to execute different types of transactions (Key-Value, UTXO, Smart Contract).</li>
<li>We traced the journey of a transaction from the <code>Commit</code> call in <code>TransactionCollector</code> through the internal queues and threads of <code>TransactionExecutor</code>, finally reaching the specific <code>TransactionManager</code> logic that updates the state.</li>
</ul>
<p>The <code>TransactionManager</code> implementations like <code>KVExecutor</code> rely heavily on an underlying mechanism to actually store and retrieve the data persistently. How does ResilientDB handle saving data to disk or memory reliably? That's the topic of our next chapter, where we'll explore the Storage Layer!</p>
<p><b>Next:</b> <a class="el" href="../../d4/db2/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_206__storage__layer.html">Chapter 6: Storage Layer</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
