#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: Section 6 &ndash; Execution</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/de0/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-spec_2Section_016_01--_01Execution.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Section 6 &ndash; Execution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1180"></a>
Execution</h1>
<p>A GraphQL service generates a response from a request via execution.</p>
<p>:: A <em>request</em> for execution consists of a few pieces of information:</p>
<ul>
<li>{schema}: The schema to use, typically solely provided by the GraphQL service.</li>
<li>{document}: A {Document} which must contain GraphQL {OperationDefinition} and may contain {FragmentDefinition}.</li>
<li>{operationName} (optional): The name of the Operation in the Document to execute.</li>
<li>{variableValues} (optional): Values for any Variables defined by the Operation.</li>
<li>{initialValue} (optional): An initial value corresponding to the root type being executed. Conceptually, an initial value represents the "universe" of data available via a GraphQL Service. It is common for a GraphQL Service to always use the same initial value for every request.</li>
<li>{extensions} (optional): A map reserved for implementation-specific additional information.</li>
</ul>
<p>Given this information, the result of {ExecuteRequest(schema, document,
operationName, variableValues, initialValue)} produces the response, to be formatted according to the Response section below.</p>
<p>Implementations should not add additional properties to a <em>request</em>, which may conflict with future editions of the GraphQL specification. Instead, {extensions} provides a reserved location for implementation-specific additional information. If present, {extensions} must be a map, but there are no additional restrictions on its contents. To avoid conflicts, keys should use unique prefixes.</p>
<p>Note: GraphQL requests do not require any specific serialization format or transport mechanism. Message serialization and transport mechanisms should be chosen by the implementing service.</p>
<p>Note: Descriptions and comments in executable documents (operation definitions, fragment definitions, and variable definitions) MUST be ignored during execution and have no effect on the observable execution, validation, or response of a GraphQL document. Descriptions and comments on executable documents MAY be used for non-observable purposes, such as logging and other developer tools.</p>
<h2><a class="anchor" id="autotoc_md1181"></a>
Executing Requests</h2>
<p>To execute a request, the executor must have a parsed {Document} and a selected operation name to run if the document defines multiple operations, otherwise the document is expected to only contain a single operation. The result of the request is determined by the result of executing this operation according to the "Executing Operations” section below.

ExecuteRequest(schema, document, operationName, variableValues, initialValue):

- Let {operation} be the result of {GetOperation(document, operationName)}.
- Let {coercedVariableValues} be the result of {CoerceVariableValues(schema,
  operation, variableValues)}.
- If {operation} is a query operation:
  - Return {ExecuteQuery(operation, schema, coercedVariableValues,
    initialValue)}.
- Otherwise if {operation} is a mutation operation:
  - Return {ExecuteMutation(operation, schema, coercedVariableValues,
    initialValue)}.
- Otherwise if {operation} is a subscription operation:
  - Return {Subscribe(operation, schema, coercedVariableValues, initialValue)}.

GetOperation(document, operationName):

- If {operationName} is {null}:
  - If {document} contains exactly one operation.
    - Return the Operation contained in the {document}.
  - Otherwise raise a &lt;em&gt;request error&lt;/em&gt; requiring {operationName}.
- Otherwise:
  - Let {operation} be the Operation named {operationName} in {document}.
  - If {operation} was not found, raise a &lt;em&gt;request error&lt;/em&gt;.
  - Return {operation}.

@subsubsection autotoc_md1182 Validating Requests

As explained in the Validation section, only requests which pass all validation
rules should be executed. If validation errors are known, they should be
reported in the list of "errors" in the response and the request must fail
without execution.

Typically validation is performed in the context of a request immediately before
execution, however a GraphQL service may execute a request without immediately
validating it if that exact same request is known to have been validated before.
A GraphQL service should only execute requests which &lt;em&gt;at some point&lt;/em&gt; were known
to be free of any validation errors, and have since not changed.

For example: the request may be validated during development, provided it does
not later change, or a service may validate a request once and memoize the
result to avoid validating the same request again in the future.

@subsubsection autotoc_md1183 Coercing Variable Values

If the operation has defined any variables, then the values for those variables
need to be coerced using the input coercion rules of the variable's declared
type. If a &lt;em&gt;request error&lt;/em&gt; is encountered during input coercion of variable
values, then the operation fails without execution.

CoerceVariableValues(schema, operation, variableValues):

- Let {coercedValues} be an empty unordered Map.
- Let {variablesDefinition} be the variables defined by {operation}.
- For each {variableDefinition} in {variablesDefinition}:
  - Let {variableName} be the name of {variableDefinition}.
  - Let {variableType} be the expected type of {variableDefinition}.
  - Assert: {IsInputType(variableType)} must be {true}.
  - Let {defaultValue} be the default value for {variableDefinition}.
  - Let {hasValue} be {true} if {variableValues} provides a value for the name
    {variableName}.
  - Let {value} be the value provided in {variableValues} for the name
    {variableName}.
  - If {hasValue} is not {true} and {defaultValue} exists (including {null}):
    - Let {coercedDefaultValue} be the result of coercing {defaultValue}
      according to the input coercion rules of {variableType}.
    - Add an entry to {coercedValues} named {variableName} with the value
      {coercedDefaultValue}.
  - Otherwise if {variableType} is a Non-Nullable type, and either {hasValue} is
    not {true} or {value} is {null}, raise a &lt;em&gt;request error&lt;/em&gt;.
  - Otherwise if {hasValue} is {true}:
    - If {value} is {null}:
      - Add an entry to {coercedValues} named {variableName} with the value
        {null}.
    - Otherwise:
      - If {value} cannot be coerced according to the input coercion rules of
        {variableType}, raise a &lt;em&gt;request error&lt;/em&gt;.
      - Let {coercedValue} be the result of coercing {value} according to the
        input coercion rules of {variableType}.
      - Add an entry to {coercedValues} named {variableName} with the value
        {coercedValue}.
- Return {coercedValues}.

Note: This algorithm is very similar to {CoerceArgumentValues()}.

@subsection autotoc_md1184 Executing Operations

The type system, as described in the "Type System" section of the spec, must
provide a query root operation type. If mutations or subscriptions are
supported, it must also provide a mutation or subscription root operation type,
respectively.

@subsubsection autotoc_md1185 Query

If the operation is a query, the result of the operation is the result of
executing the operation’s &lt;em&gt;root selection set&lt;/em&gt; with the query root operation
type.

An initial value may be provided when executing a query operation.

ExecuteQuery(query, schema, variableValues, initialValue):

- Let {queryType} be the root Query type in {schema}.
- Assert: {queryType} is an Object type.
- Let {rootSelectionSet} be the &lt;em&gt;root selection set&lt;/em&gt; in {query}.
- Return {ExecuteRootSelectionSet(variableValues, initialValue, queryType,
  rootSelectionSet, "normal")}.

@subsubsection autotoc_md1186 Mutation

If the operation is a mutation, the result of the operation is the result of
executing the operation’s &lt;em&gt;root selection set&lt;/em&gt; on the mutation root object type.
This selection set should be executed serially.

It is expected that the top level fields in a mutation operation perform
side-effects on the underlying data system. Serial execution of the provided
mutations ensures against race conditions during these side-effects.

ExecuteMutation(mutation, schema, variableValues, initialValue):

- Let {mutationType} be the root Mutation type in {schema}.
- Assert: {mutationType} is an Object type.
- Let {rootSelectionSet} be the &lt;em&gt;root selection set&lt;/em&gt; in {mutation}.
- Return {ExecuteRootSelectionSet(variableValues, initialValue, mutationType,
  rootSelectionSet, "serial")}.

@subsubsection autotoc_md1187 Subscription

If the operation is a subscription, the result is an &lt;em&gt;event stream&lt;/em&gt; called the
&lt;em&gt;response stream&lt;/em&gt; where each event in the event stream is the result of
executing the operation for each new event on an underlying &lt;em&gt;source stream&lt;/em&gt;.

Executing a subscription operation creates a persistent function on the service
that maps an underlying &lt;em&gt;source stream&lt;/em&gt; to a returned &lt;em&gt;response stream&lt;/em&gt;.

Subscribe(subscription, schema, variableValues, initialValue):

- Let {sourceStream} be the result of running
  {CreateSourceEventStream(subscription, schema, variableValues, initialValue)}.
- Let {responseStream} be the result of running
  {MapSourceToResponseEvent(sourceStream, subscription, schema,
  variableValues)}.
- Return {responseStream}.

Note: In a large-scale subscription system, the {Subscribe()} and
{ExecuteSubscriptionEvent()} algorithms may be run on separate services to
maintain predictable scaling properties. See the section below on Supporting
Subscriptions at Scale.

As an example, consider a chat application. To subscribe to new messages posted
to the chat room, the client sends a request like so:

@icode{graphql} example
subscription NewMessages {
  newMessage(roomId: 123) {
    sender
    text
  }
}
@endicode 

While the client is subscribed, whenever new messages are posted to chat room
with ID "123", the selection for "sender" and "text" will be evaluated and
published to the client, for example:

@icode{json} example
{
  "data": {
    "newMessage": {
      "sender": "Hagrid",
      "text": "You're a wizard!"
    }
  }
}
@endicode 

The "new message posted to chat room" could use a "Pub-Sub" system where the
chat room ID is the "topic" and each "publish" contains the sender and text.

&lt;strong&gt;Event Streams&lt;/strong&gt;

:: An &lt;em&gt;event stream&lt;/em&gt; represents a sequence of events: discrete emitted values
over time which can be observed. As an example, a "Pub-Sub" system may produce
an &lt;em&gt;event stream&lt;/em&gt; when "subscribing to a topic", with an value emitted for each
"publish" to that topic.

An &lt;em&gt;event stream&lt;/em&gt; may complete at any point, often because no further events
will occur. An &lt;em&gt;event stream&lt;/em&gt; may emit an infinite sequence of values, in which
it may never complete. If an &lt;em&gt;event stream&lt;/em&gt; encounters an error, it must
complete with that error.

An observer may at any point decide to stop observing an &lt;em&gt;event stream&lt;/em&gt; by
cancelling it. When an &lt;em&gt;event stream&lt;/em&gt; is cancelled, it must complete.

Internal user code also may cancel an &lt;em&gt;event stream&lt;/em&gt; for any reason, which would
be observed as that &lt;em&gt;event stream&lt;/em&gt; completing.

&lt;strong&gt;Supporting Subscriptions at Scale&lt;/strong&gt;

Query and mutation operations are stateless, allowing scaling via cloning of
GraphQL service instances. Subscriptions, by contrast, are stateful and require
maintaining the GraphQL document, variables, and other context over the lifetime
of the subscription.

Consider the behavior of your system when state is lost due to the failure of a
single machine in a service. Durability and availability may be improved by
having separate dedicated services for managing subscription state and client
connectivity.

&lt;strong&gt;Delivery Agnostic&lt;/strong&gt;

GraphQL subscriptions do not require any specific serialization format or
transport mechanism. GraphQL specifies algorithms for the creation of the
response stream, the content of each payload on that stream, and the closing of
that stream. There are intentionally no specifications for message
acknowledgement, buffering, resend requests, or any other quality of service
(QoS) details. Message serialization, transport mechanisms, and quality of
service details should be chosen by the implementing service.

@paragraph autotoc_md1188 Source Stream

:: A &lt;em&gt;source stream&lt;/em&gt; is an &lt;em&gt;event stream&lt;/em&gt; representing a sequence of root
values, each of which will trigger a GraphQL execution. Like field value
resolution, the logic to create a &lt;em&gt;source stream&lt;/em&gt; is application-specific.

CreateSourceEventStream(subscription, schema, variableValues, initialValue):

- Let {subscriptionType} be the root Subscription type in {schema}.
- Assert: {subscriptionType} is an Object type.
- Let {selectionSet} be the top level selection set in {subscription}.
- Let {collectedFieldsMap} be the result of {CollectFields(subscriptionType,
  selectionSet, variableValues)}.
- If {collectedFieldsMap} does not have exactly one entry, raise a &lt;em&gt;request
  error&lt;/em&gt;.
- Let {fields} be the value of the first entry in {collectedFieldsMap}.
- Let {fieldName} be the name of the first entry in {fields}. Note: This value
  is unaffected if an alias is used.
- Let {field} be the first entry in {fields}.
- Let {argumentValues} be the result of {CoerceArgumentValues(subscriptionType,
  field, variableValues)}.
- Let {sourceStream} be the result of running
  {ResolveFieldEventStream(subscriptionType, initialValue, fieldName,
  argumentValues)}.
- Return {sourceStream}.

ResolveFieldEventStream(subscriptionType, rootValue, fieldName, argumentValues):

- Let {resolver} be the internal function provided by {subscriptionType} for
  determining the resolved &lt;em&gt;event stream&lt;/em&gt; of a subscription field named
  {fieldName}.
- Return the result of calling {resolver}, providing {rootValue} and
  {argumentValues}.

Note: This {ResolveFieldEventStream()} algorithm is intentionally similar to
{ResolveFieldValue()} to enable consistency when defining resolvers on any
operation type.

@paragraph autotoc_md1189 Response Stream

Each event from the underlying &lt;em&gt;source stream&lt;/em&gt; triggers execution of the
subscription &lt;em&gt;selection set&lt;/em&gt; using that event's value as the {initialValue}.

MapSourceToResponseEvent(sourceStream, subscription, schema, variableValues):

- Let {responseStream} be a new &lt;em&gt;event stream&lt;/em&gt;.
- When {sourceStream} emits {sourceValue}:
  - Let {executionResult} be the result of running
    {ExecuteSubscriptionEvent(subscription, schema, variableValues,
    sourceValue)}.
  - If internal {error} was raised:
    - Cancel {sourceStream}.
    - Complete {responseStream} with {error}.
  - Otherwise emit {executionResult} on {responseStream}.
- When {sourceStream} completes normally:
  - Complete {responseStream} normally.
- When {sourceStream} completes with {error}:
  - Complete {responseStream} with {error}.
- When {responseStream} is cancelled:
  - Cancel {sourceStream}.
  - Complete {responseStream} normally.
- Return {responseStream}.

Note: Since {ExecuteSubscriptionEvent()} handles all &lt;em&gt;execution error&lt;/em&gt;, and
&lt;em&gt;request error&lt;/em&gt; only occur during {CreateSourceEventStream()}, the only
remaining error condition handled from {ExecuteSubscriptionEvent()} are internal
exceptional errors not described by this specification.

ExecuteSubscriptionEvent(subscription, schema, variableValues, initialValue):

- Let {subscriptionType} be the root Subscription type in {schema}.
- Assert: {subscriptionType} is an Object type.
- Let {rootSelectionSet} be the &lt;em&gt;root selection set&lt;/em&gt; in {subscription}.
- Return {ExecuteRootSelectionSet(variableValues, initialValue,
  subscriptionType, rootSelectionSet, "normal")}.

Note: The {ExecuteSubscriptionEvent()} algorithm is intentionally similar to
{ExecuteQuery()} since this is how each event result is produced.

@paragraph autotoc_md1190 Unsubscribe

Unsubscribe cancels the &lt;em&gt;response stream&lt;/em&gt; when a client no longer wishes to
receive payloads for a subscription. This in turn also cancels the Source
Stream, which is a good opportunity to clean up any other resources used by the
subscription.

Unsubscribe(responseStream):

- Cancel {responseStream}.

@subsection autotoc_md1191 Executing Selection Sets

Executing a GraphQL operation recursively collects and executes every selected
field in the operation. First all initially selected fields from the operation's
top most &lt;em&gt;root selection set&lt;/em&gt; are collected, then each executed. As each field
completes, all its subfields are collected, then each executed. This process
continues until there are no more subfields to collect and execute.

@subsubsection autotoc_md1192 Executing the Root Selection Set

:: A &lt;em&gt;root selection set&lt;/em&gt; is the top level &lt;em&gt;selection set&lt;/em&gt; provided by a GraphQL
operation. A root selection set always selects from a &lt;em&gt;root operation type&lt;/em&gt;.

To execute the root selection set, the initial value being evaluated and the
root type must be known, as well as whether the fields must be executed in a
series, or normally by executing all fields in parallel (see
@ref "sec-Normal-and-Serial-Execution" "Normal and Serial Execution").

Executing the root selection set works similarly for queries (parallel),
mutations (serial), and subscriptions (where it is executed for each event in
the underlying Source Stream).

First, the &lt;em&gt;selection set&lt;/em&gt; is collected into a &lt;em&gt;collected fields map&lt;/em&gt; which is
then executed, returning the resulting {data} and {errors}.

ExecuteRootSelectionSet(variableValues, initialValue, objectType, selectionSet,
executionMode):

- Let {collectedFieldsMap} be the result of {CollectFields(objectType,
  selectionSet, variableValues)}.
- Let {data} be the result of running
  {ExecuteCollectedFields(collectedFieldsMap, objectType, initialValue,
  variableValues)} &lt;em&gt;serially&lt;/em&gt; if {executionMode} is {"serial"}, otherwise
  &lt;em&gt;normally&lt;/em&gt; (allowing parallelization)).
- Let {errors} be the list of all &lt;em&gt;execution error&lt;/em&gt; raised while executing the
  selection set.
- Return an unordered map containing {data} and {errors}.

@subsubsection autotoc_md1193 Field Collection

Before execution, each &lt;em&gt;selection set&lt;/em&gt; is converted to a &lt;em&gt;collected fields map&lt;/em&gt;
by collecting all fields with the same response name, including those in
referenced fragments, into an individual &lt;em&gt;field set&lt;/em&gt;. This ensures that multiple
references to fields with the same response name will only be executed once.

:: A &lt;em&gt;collected fields map&lt;/em&gt; is an ordered map where each entry is a &lt;em&gt;response
name&lt;/em&gt; and its associated &lt;em&gt;field set&lt;/em&gt;. A &lt;em&gt;collected fields map&lt;/em&gt; may be produced
from a selection set via {CollectFields()} or from the selection sets of all
entries of a &lt;em&gt;field set&lt;/em&gt; via {CollectSubfields()}.

:: A &lt;em&gt;field set&lt;/em&gt; is an ordered set of selected fields that share the same
&lt;em&gt;response name&lt;/em&gt; (the field alias if defined, otherwise the field's name).
Validation ensures each field in the set has the same name and arguments,
however each may have different subfields (see:
@ref "sec-Field-Selection-Merging" "Field Selection Merging").

Note: The order of field selections in both a &lt;em&gt;collected fields map&lt;/em&gt; and a
&lt;em&gt;field set&lt;/em&gt; are significant, hence the algorithms in this specification model
them as an ordered map and ordered set.

As an example, collecting the fields of this query's selection set would result
in a collected fields map with two entries, &lt;tt&gt;"a"&lt;/tt&gt; and &lt;tt&gt;"b"&lt;/tt&gt;, with two instances
of the field &lt;tt&gt;a&lt;/tt&gt; and one of field &lt;tt&gt;b&lt;/tt&gt;:

@icode{graphql} example
{
  a {
    subfield1
  }
  ...ExampleFragment
}

fragment ExampleFragment on Query {
  a {
    subfield2
  }
  b
}
@endicode 

The depth-first-search order of each &lt;em&gt;field set&lt;/em&gt; produced by {CollectFields()}
is maintained through execution, ensuring that fields appear in the executed
response in a stable and predictable order.

CollectFields(objectType, selectionSet, variableValues, visitedFragments):

- If {visitedFragments} is not provided, initialize it to the empty set.
- Initialize {collectedFieldsMap} to an empty ordered map of ordered sets.
- For each {selection} in {selectionSet}:
  - If {selection} provides the directive &lt;tt&gt;\@skip&lt;/tt&gt;, let {skipDirective} be that
    directive.
    - If {skipDirective}'s {if} argument is {true} or is a variable in
      {variableValues} with the value {true}, continue with the next {selection}
      in {selectionSet}.
  - If {selection} provides the directive &lt;tt&gt;\@include&lt;/tt&gt;, let {includeDirective} be
    that directive.
    - If {includeDirective}'s {if} argument is not {true} and is not a variable
      in {variableValues} with the value {true}, continue with the next
      {selection} in {selectionSet}.
  - If {selection} is a {Field}:
    - Let {responseName} be the &lt;em&gt;response name&lt;/em&gt; of {selection} (the alias if
      defined, otherwise the field name).
    - Let {fieldsForResponseName} be the &lt;em&gt;field set&lt;/em&gt; value in
      {collectedFieldsMap} for the key {responseName}; otherwise create the
      entry with an empty ordered set.
    - Add {selection} to the {fieldsForResponseName}.
  - If {selection} is a {FragmentSpread}:
    - Let {fragmentSpreadName} be the name of {selection}.
    - If {fragmentSpreadName} is in {visitedFragments}, continue with the next
      {selection} in {selectionSet}.
    - Add {fragmentSpreadName} to {visitedFragments}.
    - Let {fragment} be the Fragment in the current Document whose name is
      {fragmentSpreadName}.
    - If no such {fragment} exists, continue with the next {selection} in
      {selectionSet}.
    - Let {fragmentType} be the type condition on {fragment}.
    - If {DoesFragmentTypeApply(objectType, fragmentType)} is {false}, continue
      with the next {selection} in {selectionSet}.
    - Let {fragmentSelectionSet} be the top-level selection set of {fragment}.
    - Let {fragmentCollectedFieldsMap} be the result of calling
      {CollectFields(objectType, fragmentSelectionSet, variableValues,
      visitedFragments)}.
    - For each {responseName} and {fragmentFields} in
      {fragmentCollectedFieldsMap}:
      - Let {fieldsForResponseName} be the &lt;em&gt;field set&lt;/em&gt; value in
        {collectedFieldsMap} for the key {responseName}; otherwise create the
        entry with an empty ordered set.
      - Add each item from {fragmentFields} to {fieldsForResponseName}.
  - If {selection} is an {InlineFragment}:
    - Let {fragmentType} be the type condition on {selection}.
    - If {fragmentType} is not {null} and {DoesFragmentTypeApply(objectType,
      fragmentType)} is {false}, continue with the next {selection} in
      {selectionSet}.
    - Let {fragmentSelectionSet} be the top-level selection set of {selection}.
    - Let {fragmentCollectedFieldsMap} be the result of calling
      {CollectFields(objectType, fragmentSelectionSet, variableValues,
      visitedFragments)}.
    - For each {responseName} and {fragmentFields} in
      {fragmentCollectedFieldsMap}:
      - Let {fieldsForResponseName} be the &lt;em&gt;field set&lt;/em&gt; value in
        {collectedFieldsMap} for the key {responseName}; otherwise create the
        entry with an empty ordered set.
      - Append each item from {fragmentFields} to {fieldsForResponseName}.
- Return {collectedFieldsMap}.

DoesFragmentTypeApply(objectType, fragmentType):

- If {fragmentType} is an Object Type:
  - If {objectType} and {fragmentType} are the same type, return {true},
    otherwise return {false}.
- If {fragmentType} is an Interface Type:
  - If {objectType} is an implementation of {fragmentType}, return {true},
    otherwise return {false}.
- If {fragmentType} is a Union:
  - If {objectType} is a possible type of {fragmentType}, return {true},
    otherwise return {false}.

Note: The steps in {CollectFields()} evaluating the &lt;tt&gt;\@skip&lt;/tt&gt; and &lt;tt&gt;\@include&lt;/tt&gt;
directives may be applied in either order since they apply commutatively.

&lt;strong&gt;Merging Selection Sets&lt;/strong&gt;

In order to execute the sub-selections of an object typed field, all &lt;em&gt;selection
sets&lt;/em&gt; of each field with the same response name in the parent &lt;em&gt;field set&lt;/em&gt; are
merged together into a single &lt;em&gt;collected fields map&lt;/em&gt; representing the subfields
to be executed next.

An example operation illustrating parallel fields with the same name with
sub-selections.

Continuing the example above,

@icode{graphql} example
{
  a {
    subfield1
  }
  ...ExampleFragment
}

fragment ExampleFragment on Query {
  a {
    subfield2
  }
  b
}
@endicode 

After resolving the value for field &lt;tt&gt;"a"&lt;/tt&gt;, the following multiple selection sets
are collected and merged together so &lt;tt&gt;"subfield1"&lt;/tt&gt; and &lt;tt&gt;"subfield2"&lt;/tt&gt; are
resolved in the same phase with the same value.

CollectSubfields(objectType, fields, variableValues):

- Let {collectedFieldsMap} be an empty ordered map of ordered sets.
- For each {field} in {fields}:
  - Let {fieldSelectionSet} be the selection set of {field}.
  - If {fieldSelectionSet} is null or empty, continue to the next field.
  - Let {fieldCollectedFieldsMap} be the result of {CollectFields(objectType,
    fieldSelectionSet, variableValues)}.
  - For each {responseName} and {subfields} in {fieldCollectedFieldsMap}:
    - Let {fieldsForResponseName} be the &lt;em&gt;field set&lt;/em&gt; value in
      {collectedFieldsMap} for the key {responseName}; otherwise create the
      entry with an empty ordered set.
    - Add each fields from {subfields} to {fieldsForResponseName}.
- Return {collectedFieldsMap}.

Note: All the {fields} passed to {CollectSubfields()} share the same &lt;em&gt;response
name&lt;/em&gt;.

@subsubsection autotoc_md1194 Executing Collected Fields

To execute a &lt;em&gt;collected fields map&lt;/em&gt;, the object type being evaluated and the
runtime value need to be known, as well as the runtime values for any variables.

Execution will recursively resolve and complete the value of every entry in the
collected fields map, producing an entry in the result map with the same
&lt;em&gt;response name&lt;/em&gt; key.

ExecuteCollectedFields(collectedFieldsMap, objectType, objectValue,
variableValues):

- Initialize {resultMap} to an empty ordered map.
- For each {responseName} and {fields} in {collectedFieldsMap}:
  - Let {fieldName} be the name of the first entry in {fields}. Note: This value
    is unaffected if an alias is used.
  - Let {fieldType} be the return type defined for the field {fieldName} of
    {objectType}.
  - If {fieldType} is defined:
    - Let {responseValue} be {ExecuteField(objectType, objectValue, fieldType,
      fields, variableValues)}.
    - Set {responseValue} as the value for {responseName} in {resultMap}.
- Return {resultMap}.

Note: {resultMap} is ordered by which fields appear first in the operation. This
is explained in greater detail in the @ref "sec-Field-Collection" "Field Collection"
section.

&lt;strong&gt;Errors and Non-Null Types&lt;/strong&gt;

&lt;a name="sec-Executing-Selection-Sets.Errors-and-Non-Null-Fields"&gt;
  
&lt;/a&gt;

If during {ExecuteCollectedFields()} a &lt;em&gt;response position&lt;/em&gt; with a non-null type
raises an &lt;em&gt;execution error&lt;/em&gt; then that error must propagate to the parent
response position (the entire selection set in the case of a field, or the
entire list in the case of a list position), either resolving to {null} if
allowed or being further propagated to a parent response position.

If this occurs, any sibling response positions which have not yet executed or
have not yet yielded a value may be cancelled to avoid unnecessary work.

Note: See @ref "sec-Handling-Execution-Errors" "Handling Execution Errors" for more
about this behavior.

@subsubsection autotoc_md1195 Normal and Serial Execution

Normally the executor can execute the entries in a &lt;em&gt;collected fields map&lt;/em&gt; in
whatever order it chooses (normally in parallel). Because the resolution of
fields other than top-level mutation fields must always be side effect-free and
idempotent, the execution order must not affect the result, and hence the
service has the freedom to execute the field entries in whatever order it deems
optimal.

For example, given the following collected fields map to be executed normally:

@icode{graphql} example
{
  birthday {
    month
  }
  address {
    street
  }
}
@endicode 

A valid GraphQL executor can resolve the four fields in whatever order it chose
(however of course &lt;tt&gt;birthday&lt;/tt&gt; must be resolved before &lt;tt&gt;month&lt;/tt&gt;, and &lt;tt&gt;address&lt;/tt&gt;
before &lt;tt&gt;street&lt;/tt&gt;).

When executing a mutation, the selections in the top most selection set will be
executed in serial order, starting with the first appearing field textually.

When executing a collected fields map serially, the executor must consider each
entry from the collected fields map in the order provided in the collected
fields map. It must determine the corresponding entry in the result map for each
item to completion before it continues on to the next entry in the collected
fields map:

For example, given the following mutation operation, the root &lt;em&gt;selection set&lt;/em&gt;
must be executed serially:

@icode{graphql} example
mutation ChangeBirthdayAndAddress($newBirthday: String!, $newAddress: String!) {
  changeBirthday(birthday: $newBirthday) {
    month
  }
  changeAddress(address: $newAddress) {
    street
  }
}
@endicode 

Therefore the executor must, in serial:

- Run {ExecuteField()} for &lt;tt&gt;changeBirthday&lt;/tt&gt;, which during {CompleteValue()} will
  execute the &lt;tt&gt;{ month }&lt;/tt&gt; sub-selection set normally.
- Run {ExecuteField()} for &lt;tt&gt;changeAddress&lt;/tt&gt;, which during {CompleteValue()} will
  execute the &lt;tt&gt;{ street }&lt;/tt&gt; sub-selection set normally.

As an illustrative example, let's assume we have a mutation field
&lt;tt&gt;changeTheNumber&lt;/tt&gt; that returns an object containing one field, &lt;tt&gt;theNumber&lt;/tt&gt;. If
we execute the following &lt;em&gt;selection set&lt;/em&gt; serially:

@icode{graphql} example
# Note: This is a selection set, not a full document using the query shorthand.
{
  first: changeTheNumber(newNumber: 1) {
    theNumber
  }
  second: changeTheNumber(newNumber: 3) {
    theNumber
  }
  third: changeTheNumber(newNumber: 2) {
    theNumber
  }
}
@endicode 

The executor will execute the following serially:

- Resolve the &lt;tt&gt;changeTheNumber(newNumber: 1)&lt;/tt&gt; field
- Execute the &lt;tt&gt;{ theNumber }&lt;/tt&gt; sub-selection set of &lt;tt&gt;first&lt;/tt&gt; normally
- Resolve the &lt;tt&gt;changeTheNumber(newNumber: 3)&lt;/tt&gt; field
- Execute the &lt;tt&gt;{ theNumber }&lt;/tt&gt; sub-selection set of &lt;tt&gt;second&lt;/tt&gt; normally
- Resolve the &lt;tt&gt;changeTheNumber(newNumber: 2)&lt;/tt&gt; field
- Execute the &lt;tt&gt;{ theNumber }&lt;/tt&gt; sub-selection set of &lt;tt&gt;third&lt;/tt&gt; normally

A correct executor must generate the following result for that &lt;em&gt;selection set&lt;/em&gt;:

@icode{json} example
{
  "first": {
    "theNumber": 1
  },
  "second": {
    "theNumber": 3
  },
  "third": {
    "theNumber": 2
  }
}
@endicode 

@subsection autotoc_md1196 Executing Fields

Each entry in a result map is the result of executing a field on an object type
selected by the name of that field in a &lt;em&gt;collected fields map&lt;/em&gt;. Field execution
first coerces any provided argument values, then resolves a value for the field,
and finally completes that value either by recursively executing another
selection set or coercing a scalar value.

ExecuteField(objectType, objectValue, fieldType, fields, variableValues):

- Let {field} be the first entry in {fields}.
- Let {fieldName} be the field name of {field}.
- Let {argumentValues} be the result of {CoerceArgumentValues(objectType, field,
  variableValues)}.
- Let {resolvedValue} be {ResolveFieldValue(objectType, objectValue, fieldName,
  argumentValues)}.
- Return the result of {CompleteValue(fieldType, fields, resolvedValue,
  variableValues)}.

@subsubsection autotoc_md1197 Coercing Field Arguments

Fields may include arguments which are provided to the underlying runtime in
order to correctly produce a value. These arguments are defined by the field in
the type system to have a specific input type.

At each argument position in an operation may be a literal {Value}, or a
{Variable} to be provided at runtime.

CoerceArgumentValues(objectType, field, variableValues):

- Let {coercedValues} be an empty unordered Map.
- Let {argumentValues} be the argument values provided in {field}.
- Let {fieldName} be the name of {field}.
- Let {argumentDefinitions} be the arguments defined by {objectType} for the
  field named {fieldName}.
- For each {argumentDefinition} in {argumentDefinitions}:
  - Let {argumentName} be the name of {argumentDefinition}.
  - Let {argumentType} be the expected type of {argumentDefinition}.
  - Let {defaultValue} be the default value for {argumentDefinition}.
  - Let {argumentValue} be the value provided in {argumentValues} for the name
    {argumentName}.
  - If {argumentValue} is a {Variable}:
    - Let {variableName} be the name of {argumentValue}.
    - If {variableValues} provides a value for the name {variableName}:
      - Let {hasValue} be {true}.
      - Let {value} be the value provided in {variableValues} for the name
        {variableName}.
  - Otherwise if {argumentValues} provides a value for the name {argumentName}.
    - Let {hasValue} be {true}.
    - Let {value} be {argumentValue}.
  - If {hasValue} is not {true} and {defaultValue} exists (including {null}):
    - Let {coercedDefaultValue} be the result of coercing {defaultValue}
      according to the input coercion rules of {argumentType}.
    - Add an entry to {coercedValues} named {argumentName} with the value
      {coercedDefaultValue}.
  - Otherwise if {argumentType} is a Non-Nullable type, and either {hasValue} is
    not {true} or {value} is {null}, raise an &lt;em&gt;execution error&lt;/em&gt;.
  - Otherwise if {hasValue} is {true}:
    - If {value} is {null}:
      - Add an entry to {coercedValues} named {argumentName} with the value
        {null}.
    - Otherwise, if {argumentValue} is a {Variable}:
      - Add an entry to {coercedValues} named {argumentName} with the value
        {value}.
    - Otherwise:
      - If {value} cannot be coerced according to the input coercion rules of
        {argumentType}, raise an &lt;em&gt;execution error&lt;/em&gt;.
      - Let {coercedValue} be the result of coercing {value} according to the
        input coercion rules of {argumentType}.
      - Add an entry to {coercedValues} named {argumentName} with the value
        {coercedValue}.
- Return {coercedValues}.

Any &lt;em&gt;request error&lt;/em&gt; raised as a result of input coercion during
{CoerceArgumentValues()} should be treated instead as an &lt;em&gt;execution error&lt;/em&gt;.

Note: Variable values are not coerced because they are expected to be coerced
before executing the operation in {CoerceVariableValues()}, and valid operations
must only allow usage of variables of appropriate types.

Note: Implementations are encouraged to optimize the coercion of an argument's
default value by doing so only once and caching the resulting coerced value.

@subsubsection autotoc_md1198 Value Resolution

While nearly all of GraphQL execution can be described generically, ultimately
the internal system exposing the GraphQL interface must provide values. This is
exposed via {ResolveFieldValue}, which produces a value for a given field on a
type for a real value.

As an example, this might accept the {objectType} &lt;tt&gt;Person&lt;/tt&gt;, the {field}
{"soulMate"}, and the {objectValue} representing John Lennon. It would be
expected to yield the value representing Yoko Ono.

ResolveFieldValue(objectType, objectValue, fieldName, argumentValues):

- Let {resolver} be the internal function provided by {objectType} for
  determining the resolved value of a field named {fieldName}.
- Return the result of calling {resolver}, providing {objectValue} and
  {argumentValues}.

Note: It is common for {resolver} to be asynchronous due to relying on reading
an underlying database or networked service to produce a value. This
necessitates the rest of a GraphQL executor to handle an asynchronous execution
flow. If the field is of a list type, each value in the collection of values
returned by {resolver} may itself be retrieved asynchronously.

@subsubsection autotoc_md1199 Value Completion

After resolving the value for a field, it is completed by ensuring it adheres to
the expected return type. If the return type is another Object type, then the
field execution process continues recursively by collecting and executing
subfields.

CompleteValue(fieldType, fields, result, variableValues):

- If the {fieldType} is a Non-Null type:
  - Let {innerType} be the inner type of {fieldType}.
  - Let {completedResult} be the result of calling {CompleteValue(innerType,
    fields, result, variableValues)}.
  - If {completedResult} is {null}, raise an &lt;em&gt;execution error&lt;/em&gt;.
  - Return {completedResult}.
- If {result} is {null} (or another internal value similar to {null} such as
  {undefined}), return {null}.
- If {fieldType} is a List type:
  - If {result} is not a collection of values, raise an &lt;em&gt;execution error&lt;/em&gt;.
  - Let {innerType} be the inner type of {fieldType}.
  - Return a list where each list item is the result of calling
    {CompleteValue(innerType, fields, resultItem, variableValues)}, where
    {resultItem} is each item in {result}.
- If {fieldType} is a Scalar or Enum type:
  - Return the result of {CoerceResult(fieldType, result)}.
- If {fieldType} is an Object, Interface, or Union type:
  - If {fieldType} is an Object type.
    - Let {objectType} be {fieldType}.
  - Otherwise if {fieldType} is an Interface or Union type.
    - Let {objectType} be {ResolveAbstractType(fieldType, result)}.
  - Let {collectedFieldsMap} be the result of calling
    {CollectSubfields(objectType, fields, variableValues)}.
  - Return the result of evaluating {ExecuteCollectedFields(collectedFieldsMap,
    objectType, result, variableValues)} &lt;em&gt;normally&lt;/em&gt; (allowing for
    parallelization).

&lt;strong&gt;Coercing Results&lt;/strong&gt;

The primary purpose of value completion is to ensure that the values returned by
field resolvers are valid according to the GraphQL type system and a service's
schema. This "dynamic type checking" allows GraphQL to provide consistent
guarantees about returned types atop any service's internal runtime.

See the Scalars
@ref "sec-Scalars.Result-Coercion-and-Serialization" "Result Coercion and Serialization"
sub-section for more detailed information about how GraphQL's built-in scalars
coerce result values.

CoerceResult(leafType, value):

- Assert: {value} is not {null}.
- Return the result of calling the internal method provided by the type system
  for determining the "result coercion" of {leafType} given the value {value}.
  This internal method must return a valid value for the type and not {null}.
  Otherwise raise an &lt;em&gt;execution error&lt;/em&gt;.

Note: If a field resolver returns {null} then it is handled within
{CompleteValue()} before {CoerceResult()} is called. Therefore both the input
and output of {CoerceResult()} must not be {null}.

&lt;strong&gt;Resolving Abstract Types&lt;/strong&gt;

When completing a field with an abstract return type, that is an Interface or
Union return type, first the abstract type must be resolved to a relevant Object
type. This determination is made by the internal system using whatever means
appropriate.

Note: A common method of determining the Object type for an {objectValue} in
object-oriented environments, such as Java or C#, is to use the class name of
the {objectValue}.

ResolveAbstractType(abstractType, objectValue):

- Return the result of calling the internal method provided by the type system
  for determining the Object type of {abstractType} given the value
  {objectValue}.

@subsubsection autotoc_md1200 Handling Execution Errors

@anchor sec-Handling-Field-Errors &lt;a&gt;
  
&lt;/a&gt;

An &lt;em&gt;execution error&lt;/em&gt; is an error raised during field execution, value resolution
or coercion, at a specific &lt;em&gt;response position&lt;/em&gt;. While these errors must be
reported in the response, they are "handled" by producing partial {"data"} in
the &lt;em&gt;response&lt;/em&gt;.

Note: This is distinct from a &lt;em&gt;request error&lt;/em&gt; which results in a &lt;em&gt;request error
result&lt;/em&gt; with no data.

If an execution error is raised while resolving a field (either directly or
nested inside any lists), it is handled as though the &lt;em&gt;response position&lt;/em&gt; at
which the error occurred resolved to {null}, and the error must be added to the
{"errors"} list in the &lt;em&gt;execution result&lt;/em&gt;.

If the result of resolving a &lt;em&gt;response position&lt;/em&gt; is {null} (either due to the
result of {ResolveFieldValue()} or because an execution error was raised), and
that position is of a &lt;tt&gt;Non-Null&lt;/tt&gt; type, then an execution error is raised at that
position. The error must be added to the {"errors"} list in the &lt;em&gt;execution
result&lt;/em&gt;.

If a &lt;em&gt;response position&lt;/em&gt; resolves to {null} because of an execution error which
has already been added to the {"errors"} list in the &lt;em&gt;execution result&lt;/em&gt;, the
{"errors"} list must not be further affected. That is, only one error should be
added to the errors list per &lt;em&gt;response position&lt;/em&gt;.

Since &lt;tt&gt;Non-Null&lt;/tt&gt; response positions cannot be {null}, execution errors are
propagated to be handled by the parent &lt;em&gt;response position&lt;/em&gt;. If the parent
response position may be {null} then it resolves to {null}, otherwise if it is a
&lt;tt&gt;Non-Null&lt;/tt&gt; type, the execution error is further propagated to its parent
&lt;em&gt;response position&lt;/em&gt;.

If a &lt;tt&gt;List&lt;/tt&gt; type wraps a &lt;tt&gt;Non-Null&lt;/tt&gt; type, and one of the &lt;em&gt;response position&lt;/em&gt;
elements of that list resolves to {null}, then the entire list &lt;em&gt;response
position&lt;/em&gt; must resolve to {null}. If the &lt;tt&gt;List&lt;/tt&gt; type is also wrapped in a
&lt;tt&gt;Non-Null&lt;/tt&gt;, the execution error continues to propagate upwards.

If every &lt;em&gt;response position&lt;/em&gt; from the root of the request to the source of the
execution error has a &lt;tt&gt;Non-Null&lt;/tt&gt; type, then the {"data"} entry in the <em>execution result</em> should be {null}. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
