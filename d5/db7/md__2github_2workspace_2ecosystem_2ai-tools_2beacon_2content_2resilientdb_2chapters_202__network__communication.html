#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_network_communication</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/db7/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_202__network__communication.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_network_communication</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> layout: default title: 'Chapter 2: Network Communication' parent: 'ResilientDB' </p>
<h2><a class="anchor" id="autotoc_md94"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md95"></a>
Chapter 2: Network Communication</h1>
<p>In <a class="el" href="../../d1/d5a/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_201__client__interaction.html">Chapter 1: Client Interaction</a>, we learned how you, as a user or application, can talk to ResilientDB using special "Client" tools. You package your request (like storing data) and send it off using something like <code><a class="el" href="../../d6/da5/classKVClient.html">KVClient</a></code>.</p>
<p>But where does that request <em>go</em>? And how do the different computers (replicas) that make up the ResilientDB network talk to <em>each other</em> to process your request and agree on the result?</p>
<p>Welcome to Chapter 2! Here, we'll explore the <b>Network Communication</b> layer. This is the backbone that allows all the different parts of ResilientDB to connect and exchange messages.</p>
<p>Think of it like the <b>postal service and telephone network</b> combined for ResilientDB:</p>
<ul>
<li><b>Postal Service:</b> It needs to reliably send letters (messages like transaction proposals or votes) to the correct addresses (other replicas).</li>
<li><b>Telephone Network:</b> It needs a way to receive incoming calls (client requests or messages from other replicas) so the system can answer them.</li>
</ul>
<p>This chapter focuses on two key components:</p>
<ol type="1">
<li><code>ReplicaCommunicator</code>: Handles sending messages <em>between</em> the ResilientDB replicas. (The Postal Service)</li>
<li><code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code>: Handles listening for and receiving <em>incoming</em> messages, both from clients and other replicas. (The Telephone Network Operator)</li>
</ol>
<h2><a class="anchor" id="autotoc_md96"></a>
Why is Network Communication Important?</h2>
<p>ResilientDB is a <em>distributed</em> system. This means it doesn't run on just one computer. Instead, a team of computers (replicas) work together. To work together, they <em>must</em> communicate constantly over the network.</p>
<p>Imagine you and your friends are trying to decide on a movie to watch tonight.</p>
<ul>
<li>You send a message proposing "Let's watch SciFi Movie X!" (like a client sending a transaction).</li>
<li>Your friends need to receive this message.</li>
<li>They discuss amongst themselves, sending messages back and forth like "I vote yes for SciFi Movie X!" or "How about Comedy Movie Y?" (like replicas exchanging votes for consensus).</li>
<li>Eventually, enough friends agree, and someone sends a final message: "Okay, SciFi Movie X it is!" (like a replica sending a response back to the client).</li>
</ul>
<p>Without a reliable way to send and receive these messages, the group could never agree! ResilientDB needs its own robust communication system for the replicas to coordinate.</p>
<h2><a class="anchor" id="autotoc_md97"></a>
Sending Messages Between Replicas: <code>ReplicaCommunicator</code></h2>
<p>The <code>ReplicaCommunicator</code> is responsible for sending messages <em>from</em> one replica <em>to</em> other replicas in the network. It's like the postal service handling outgoing mail.</p>
<p><b>Key Jobs:</b></p>
<ol type="1">
<li><b>Knowing Addresses:</b> It knows the network addresses (IP and port) of all the other replicas it needs to talk to, based on the system configuration (ResilientDB Configuration (ResDBConfig)).</li>
<li><b>Sending Methods:</b> It provides ways to send messages:<ul>
<li><b>Broadcast:</b> Send the same message to <em>all</em> other replicas (like sending a party invitation to everyone).</li>
<li><b>Targeted Send:</b> Send a message to one <em>specific</em> replica (like sending a private note).</li>
</ul>
</li>
<li><b>Reliability (Under the Hood):</b> It often uses lower-level tools (like <code>NetChannel</code> or <code>AsyncReplicaClient</code>) to handle the actual network sending, potentially retrying if a message fails to send initially.</li>
<li><b>Batching (Optional):</b> For efficiency, it might collect several small messages going to the same destination and send them together in one larger "package" (<code>BatchQueue</code>).</li>
</ol>
<p><b>Analogy:</b> <code>ReplicaCommunicator</code> is the mailroom clerk. You give the clerk a letter (message) and tell them who it's for (one replica or everyone). The clerk figures out the addresses and makes sure the letters get sent out.</p>
<p><b>Simplified Usage Example (Conceptual):</b></p>
<p>Imagine Replica A needs to tell all other replicas about a new transaction proposal.</p>
<div class="fragment"><div class="line"><span class="comment">// Inside Replica A&#39;s code (conceptual)</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/dd9/replica__communicator_8h.html">platform/networkstrate/replica_communicator.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;platform/proto/resdb.pb.h&quot;</span> <span class="comment">// Contains message definitions like &#39;Request&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume &#39;replica_communicator&#39; is already set up with network info</span></div>
<div class="line"><span class="comment">// Assume &#39;my_transaction_proposal&#39; is a &#39;Request&#39; message object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Broadcast the proposal to all other replicas</span></div>
<div class="line">replica_communicator-&gt;BroadCast(my_transaction_proposal);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or, send a specific message just to Replica B (identified by node_id 2)</span></div>
<div class="line"><span class="comment">// Assume &#39;private_message&#39; is another &#39;Request&#39; object</span></div>
<div class="line">replica_communicator-&gt;SendMessage(private_message, <span class="comment">/* node_id = */</span> 2);</div>
<div class="ttc" id="areplica__communicator_8h_html"><div class="ttname"><a href="../../d0/dd9/replica__communicator_8h.html">replica_communicator.h</a></div></div>
</div><!-- fragment --><p>This code shows how simple it is <em>to use</em> the <code>ReplicaCommunicator</code>. You create your message (<code>my_transaction_proposal</code> or <code>private_message</code>) and call either <code>BroadCast</code> or <code>SendMessage</code>. The communicator handles the rest!</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Listening for Incoming Messages: <code>ServiceNetwork</code></h2>
<p>While <code>ReplicaCommunicator</code> handles <em>sending</em> messages, <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> handles <em>receiving</em> them. Each replica runs a <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> instance that acts like its ear to the world (or network, in this case!).</p>
<p><b>Key Jobs:</b></p>
<ol type="1">
<li><b>Listening:</b> It opens a network "port" (like a specific phone number) and listens for incoming network connections.</li>
<li><b>Accepting Connections:</b> When a client or another replica tries to connect and send a message, <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> accepts the connection.</li>
<li><b>Receiving Data:</b> It reads the incoming message data from the network connection.</li>
<li><b>Passing the Message:</b> Once a complete message is received, it doesn't process the message itself. Instead, it passes the message off to the appropriate internal component (represented by <code>ServiceInterface</code>) for actual processing. This processing might involve adding the transaction to a queue (Message/Transaction Collection (TransactionCollector / MessageManager)) or handling a consensus vote (Consensus Management (ConsensusManager)).</li>
</ol>
<p><b>Analogy:</b> <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> is like the central telephone operator for a company (a ResilientDB replica).</p>
<ul>
<li>It listens for the phone ringing (incoming network connections).</li>
<li>It answers the call (accepts the connection).</li>
<li>It takes the message ("Please connect me to Sales," or the actual transaction data).</li>
<li>It transfers the call or message to the correct department (<code>ServiceInterface</code>).</li>
</ul>
<p><b>Simplified Setup Example:</b></p>
<p>Setting up the <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> usually happens when a ResilientDB replica starts.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from platform/networkstrate/service_network.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d22/service__network_8h.html">platform/networkstrate/service_network.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/d9a/resdb__config_8h.html">platform/config/resdb_config.h</a>&quot;</span> <span class="comment">// For configuration</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/dca/service__interface_8h.html">platform/networkstrate/service_interface.h</a>&quot;</span> <span class="comment">// Interface for processing</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Assume &#39;config&#39; holds this replica&#39;s network info (IP, port)</span></div>
<div class="line"><span class="comment">// Assume &#39;my_service_handler&#39; is an object implementing ServiceInterface</span></div>
<div class="line"><span class="comment">// (This object knows what to *do* with received messages)</span></div>
<div class="line">std::unique_ptr&lt;resdb::ServiceInterface&gt; my_service_handler = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the ServiceNetwork</span></div>
<div class="line"><a class="code hl_class" href="../../d4/d2d/classresdb_1_1ServiceNetwork.html">resdb::ServiceNetwork</a> service_network(<a class="code hl_namespace" href="../../d6/d7f/namespaceconfig.html">config</a>, std::move(my_service_handler));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start listening in the background</span></div>
<div class="line">service_network.Run(); <span class="comment">// This starts the listening process</span></div>
<div class="ttc" id="aclassresdb_1_1ServiceNetwork_html"><div class="ttname"><a href="../../d4/d2d/classresdb_1_1ServiceNetwork.html">resdb::ServiceNetwork</a></div><div class="ttdef"><b>Definition</b> <a href="../../d2/d22/service__network_8h_source.html#l00038">service_network.h:38</a></div></div>
<div class="ttc" id="anamespaceconfig_html"><div class="ttname"><a href="../../d6/d7f/namespaceconfig.html">config</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/d0d/ai-tools_2mcp_2resilientdb-mcp_2config_8py_source.html#l00001">config.py:1</a></div></div>
<div class="ttc" id="aresdb__config_8h_html"><div class="ttname"><a href="../../d4/d9a/resdb__config_8h.html">resdb_config.h</a></div></div>
<div class="ttc" id="aservice__interface_8h_html"><div class="ttname"><a href="../../db/dca/service__interface_8h.html">service_interface.h</a></div></div>
<div class="ttc" id="aservice__network_8h_html"><div class="ttname"><a href="../../d2/d22/service__network_8h.html">service_network.h</a></div></div>
</div><!-- fragment --><p>This code creates the <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code>, telling it <em>where</em> to listen (<code>config</code>) and <em>who</em> to pass messages to (<code>my_service_handler</code>). Calling <code>Run()</code> starts the listening loop.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
How They Work Together: A Simple Flow</h2>
<p>Let's trace a <em>very</em> simplified path of a client request:</p>
<ol type="1">
<li><b>Client Sends:</b> You use <code><a class="el" href="../../d6/da5/classKVClient.html">KVClient</a></code> (from Chapter 1) to send a <code>Set("mykey", "myvalue")</code> request. The client library sends this message over the network to one of the ResilientDB replicas (let's say Replica A).</li>
<li><b>Replica A Receives:</b> Replica A's <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> is listening. It receives the incoming connection and the <code>Set</code> request message.</li>
<li><b>Replica A Passes Message:</b> <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> passes the <code>Set</code> request to its internal <code>ServiceInterface</code>. This might trigger the consensus process.</li>
<li><b>Replica A Broadcasts:</b> To get agreement, Replica A's consensus logic uses <code>ReplicaCommunicator</code> to <em>broadcast</em> the <code>Set</code> request (or a proposal based on it) to Replica B and Replica C.</li>
<li><b>Replicas B &amp; C Receive:</b> The <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> on Replica B and Replica C receive the broadcasted message from Replica A.</li>
<li><b>Replicas B &amp; C Process:</b> They pass the message to their own <code>ServiceInterface</code> handlers to process (e.g., validate the request, prepare to vote).</li>
<li><b>Replicas B &amp; C Send Votes:</b> Replicas B and C use their <code>ReplicaCommunicator</code> to send "vote" messages back to Replica A (and possibly others).</li>
<li><b>Replica A Receives Votes:</b> Replica A's <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> receives the incoming vote messages.</li>
<li><b>Replica A Finalizes:</b> The votes are passed internally. Once enough votes arrive, Replica A knows the request is agreed upon. It might then execute the command (Transaction Execution (TransactionManager / TransactionExecutor)) and store the data (Storage Layer (Storage / LevelDB / MemoryDB)).</li>
<li><b>Replica A Responds to Client:</b> Finally, Replica A might use its network connection (managed potentially via <code>NetChannel</code> originating from the initial <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> interaction) to send a "Success" response back to the original client.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant RepA_SN as Replica A (ServiceNetwork)</div>
<div class="line">    participant RepA_RC as Replica A (ReplicaCommunicator)</div>
<div class="line">    participant RepB_SN as Replica B (ServiceNetwork)</div>
<div class="line">    participant RepB_RC as Replica B (ReplicaCommunicator)</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+RepA_SN: Send Request (e.g., Set(&quot;key&quot;, &quot;value&quot;))</div>
<div class="line">    Note over RepA_SN: Receives &amp; passes to internal logic</div>
<div class="line">    RepA_SN--&gt;&gt;RepA_RC: Initiate broadcast (consensus)</div>
<div class="line">    RepA_RC-&gt;&gt;+RepB_SN: Broadcast Request</div>
<div class="line">    Note over RepB_SN: Receives &amp; passes to internal logic</div>
<div class="line">    RepB_SN--&gt;&gt;RepB_RC: Send Vote back to A</div>
<div class="line">    RepB_RC-&gt;&gt;+RepA_SN: Send Vote Message</div>
<div class="line">    Note over RepA_SN: Receives Vote &amp; processes consensus</div>
<div class="line">    RepA_SN--&gt;&gt;-Client: Send Response (Success)</div>
</div><!-- fragment --><p>This diagram simplifies heavily, but it shows the interplay: <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> receives, <code>ReplicaCommunicator</code> sends between replicas.</p>
<h2><a class="anchor" id="autotoc_md100"></a>
Under the Hood: Code Glimpses</h2>
<p>Let's peek at some simplified code structures.</p>
<p><b>1. <code>ReplicaCommunicator</code> Sending a Message:</b></p>
<p>The <code>ReplicaCommunicator</code> might use a helper class like <code>NetChannel</code> (which we saw briefly in Chapter 1) or a dedicated <code>AsyncReplicaClient</code> to talk to a specific replica.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from platform/networkstrate/replica_communicator.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method to send a message to a list of specific replicas</span></div>
<div class="line"><span class="keywordtype">int</span> ReplicaCommunicator::SendMessageInternal(</div>
<div class="line">    <span class="keyword">const</span> google::protobuf::Message&amp; message,</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;ReplicaInfo&gt;&amp; replicas) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> success_count = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; replica : replicas) {</div>
<div class="line">    <span class="comment">// Get a network channel/client for the target replica&#39;s IP and port</span></div>
<div class="line">    <span class="comment">// This might create a temporary connection or use a persistent one.</span></div>
<div class="line">    std::unique_ptr&lt;NetChannel&gt; client = GetClient(replica.ip(), replica.port());</div>
<div class="line">    <span class="keywordflow">if</span> (client == <span class="keyword">nullptr</span>) {</div>
<div class="line">      LOG(WARNING) &lt;&lt; <span class="stringliteral">&quot;Could not create client for &quot;</span> &lt;&lt; replica.ip();</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Optionally add a digital signature if configured</span></div>
<div class="line">    <span class="keywordflow">if</span> (verifier_ != <span class="keyword">nullptr</span>) {</div>
<div class="line">      client-&gt;SetSignatureVerifier(verifier_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use the client/channel to send the message (already formatted)</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_variable" href="../../d6/d79/namespaceresdb__sdk.html#afb4c2d86b40343edd170f68581e12ee3">client</a>-&gt;SendRawMessage(message) == 0) { <span class="comment">// 0 means success</span></div>
<div class="line">      success_count++;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      LOG(ERROR) &lt;&lt; <span class="stringliteral">&quot;Failed to send message to &quot;</span> &lt;&lt; replica.ip();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// The client/channel might be closed here if not using long connections</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> success_count;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceresdb__sdk_html_afb4c2d86b40343edd170f68581e12ee3"><div class="ttname"><a href="../../d6/d79/namespaceresdb__sdk.html#afb4c2d86b40343edd170f68581e12ee3">resdb_sdk.client</a></div><div class="ttdeci">client</div><div class="ttdef"><b>Definition</b> <a href="../../d7/dfe/resdb__sdk_8py_source.html#l00167">resdb_sdk.py:167</a></div></div>
</div><!-- fragment --><p>This shows <code>ReplicaCommunicator</code> iterating through target replicas, getting a communication channel (<code>NetChannel</code>) for each, and using that channel's <code>SendRawMessage</code> method.</p>
<p><b>2. <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> Receiving a Message:</b></p>
<p><code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> often uses an underlying "Acceptor" component (<code>Acceptor</code> or <code>AsyncAcceptor</code>) to handle the low-level network listening and connection acceptance.</p>
<ul>
<li><b><code>Acceptor</code> (Simpler, Blocking Style):</b> Listens for a connection, accepts it, reads one message, and puts the message (and the connection socket if a reply is needed) onto a queue (<code>input_queue_</code>).</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Simplified concept from platform/rdbc/acceptor.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Acceptor::Run() {</div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Acceptor starting...&quot;</span>;</div>
<div class="line">  <span class="keywordflow">while</span> (IsRunning()) {</div>
<div class="line">    <span class="comment">// 1. Wait for and accept a new incoming connection</span></div>
<div class="line">    <span class="comment">// &#39;socket_&#39; is the main listening socket</span></div>
<div class="line">    <span class="keyword">auto</span> client_socket = socket_-&gt;Accept();</div>
<div class="line">    <span class="keywordflow">if</span> (client_socket == <span class="keyword">nullptr</span>) {</div>
<div class="line">      <span class="keywordflow">continue</span>; <span class="comment">// No connection yet, or error</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Read the data (message) from the connected client</span></div>
<div class="line">    std::unique_ptr&lt;DataInfo&gt; request_info = std::make_unique&lt;DataInfo&gt;();</div>
<div class="line">    <span class="keywordtype">int</span> ret = client_socket-&gt;Recv(&amp;request_info-&gt;buff, &amp;request_info-&gt;data_len);</div>
<div class="line">    <span class="keywordflow">if</span> (ret &lt;= 0) {</div>
<div class="line">       <span class="comment">// Error reading or client disconnected</span></div>
<div class="line">       client_socket-&gt;Close();</div>
<div class="line">       <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Package the client socket and the received data</span></div>
<div class="line">    std::unique_ptr&lt;QueueItem&gt; item = std::make_unique&lt;QueueItem&gt;();</div>
<div class="line">    item-&gt;socket = std::move(client_socket); <span class="comment">// Keep socket for potential reply</span></div>
<div class="line">    item-&gt;data = std::move(request_info);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Push the item onto the input queue for ServiceNetwork&#39;s workers</span></div>
<div class="line">    input_queue_-&gt;Push(std::move(item));</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b><code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> Processing from Queue:</b> Worker threads in <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> then pick items from this queue.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Simplified concept from platform/networkstrate/service_network.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ServiceNetwork::InputProcess() {</div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;ServiceNetwork worker starting...&quot;</span>;</div>
<div class="line">  <span class="keywordflow">while</span> (IsRunning()) {</div>
<div class="line">    <span class="comment">// 1. Wait for and pop an item from the input queue</span></div>
<div class="line">    <span class="comment">// (This item was put there by the Acceptor)</span></div>
<div class="line">    std::unique_ptr&lt;QueueItem&gt; item = input_queue_-&gt;Pop(1000); <span class="comment">// Wait up to 1s</span></div>
<div class="line">    <span class="keywordflow">if</span> (item == <span class="keyword">nullptr</span>) {</div>
<div class="line">      <span class="keywordflow">continue</span>; <span class="comment">// No message received in the timeout period</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2. Extract the socket and data</span></div>
<div class="line">    <span class="keyword">auto</span> client_socket = (item-&gt;socket == <span class="keyword">nullptr</span>) ? <span class="keyword">nullptr</span> : std::move(item-&gt;socket);</div>
<div class="line">    <span class="keyword">auto</span> request_data = std::move(item-&gt;data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 3. Create a context (includes the client connection info)</span></div>
<div class="line">    std::unique_ptr&lt;Context&gt; context = std::make_unique&lt;Context&gt;();</div>
<div class="line">    <span class="keywordflow">if</span>(client_socket != <span class="keyword">nullptr</span>) {</div>
<div class="line">       <span class="comment">// Wrap the socket in a NetChannel for potential replies</span></div>
<div class="line">       context-&gt;client = std::make_unique&lt;NetChannel&gt;(std::move(client_socket), <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 4. Pass the context and the received data to the actual service logic</span></div>
<div class="line">    <span class="keywordflow">if</span> (request_data) {</div>
<div class="line">       <span class="comment">// &#39;service_&#39; is the ServiceInterface implementation provided during setup</span></div>
<div class="line">       service_-&gt;Process(std::move(context), std::move(request_data));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This shows the hand-off: <code>Acceptor</code> receives raw data and puts it on a queue. <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code>'s worker threads take items from the queue and pass them to the <code>service_</code> object (which implements <code>ServiceInterface</code>) for actual application-level processing.</p>
<ul>
<li><b><code>AsyncAcceptor</code> (More Complex, Non-Blocking):</b> Uses asynchronous I/O (like Boost.Asio) to handle many connections concurrently without blocking threads per connection. When data arrives, it calls a callback function (<code>AcceptorHandler</code> in <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code>) which then usually puts the data onto the <code>input_queue_</code>. The end result for <code>InputProcess</code> is similar.</li>
</ul>
<h2><a class="anchor" id="autotoc_md101"></a>
Conclusion</h2>
<p>You've now seen the vital communication layer of ResilientDB!</p>
<ul>
<li>We learned that <code>ReplicaCommunicator</code> acts like the <b>postal service</b>, responsible for <em>sending</em> messages (like proposals and votes) between the different replica computers. It knows the addresses and can broadcast or send targeted messages.</li>
<li>We saw that <code><a class="el" href="../../d7/d96/classServiceNetwork.html">ServiceNetwork</a></code> acts like the <b>telephone network operator</b>, responsible for <em>listening</em> for and <em>receiving</em> incoming messages, whether from clients or other replicas. It passes these messages on for processing.</li>
<li>These two components work together, using lower-level network tools, to allow the distributed replicas of ResilientDB to coordinate effectively.</li>
</ul>
<p>So, the replicas can now send and receive messages reliably. But what exactly are they saying to each other? How do they use these messages to <em>agree</em> on the order of transactions and the state of the database? That's the magic of <b>consensus</b>, and it's the topic of our next chapter!</p>
<p><b>Next:</b> [Chapter 3: Consensus Management](03_consensus_management)</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
