#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: Section 3 &ndash; Type System</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d8b/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-spec_2Section_013_01--_01Type_01System.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Section 3 &ndash; Type System</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1092"></a>
Type System</h1>
<p>The GraphQL Type system describes the capabilities of a GraphQL service and is used to determine if a requested operation is valid, to guarantee the type of response results, and describes the input types of variables to determine if values provided at request time are valid.</p>
<p>TypeSystemDocument : TypeSystemDefinition+</p>
<p>TypeSystemDefinition :</p>
<ul>
<li>SchemaDefinition</li>
<li>TypeDefinition</li>
<li>DirectiveDefinition</li>
</ul>
<p>The GraphQL language includes an <a href="https://en.wikipedia.org/wiki/Interface_description_language">IDL</a> used to describe a GraphQL service's type system. Tools may use this definition language to provide utilities such as client code generation or service bootstrapping.</p>
<p>GraphQL tools or services which only seek to execute GraphQL requests and not construct a new GraphQL schema may choose not to allow {TypeSystemDefinition}. Tools which only seek to produce schema and not execute requests may choose to only allow {TypeSystemDocument} and not allow {ExecutableDefinition} or {TypeSystemExtension} but should provide a descriptive error if present.</p>
<p>Note: The type system definition language is used throughout the remainder of this specification document when illustrating example type systems.</p>
<h2><a class="anchor" id="autotoc_md1093"></a>
Type System Extensions</h2>
<p>TypeSystemExtensionDocument : TypeSystemDefinitionOrExtension+</p>
<p>TypeSystemDefinitionOrExtension :</p>
<ul>
<li>TypeSystemDefinition</li>
<li>TypeSystemExtension</li>
</ul>
<p>TypeSystemExtension :</p>
<ul>
<li>SchemaExtension</li>
<li>TypeExtension</li>
</ul>
<p>Type system extensions are used to represent a GraphQL type system which has been extended from some previous type system. For example, this might be used by a local service to represent data a GraphQL client only accesses locally, or by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p>Tools which only seek to produce and extend schema and not execute requests may choose to only allow {TypeSystemExtensionDocument} and not allow {ExecutableDefinition} but should provide a descriptive error if present.</p>
<h2><a class="anchor" id="autotoc_md1094"></a>
Type System Descriptions</h2>
<p>Documentation is a first-class feature of GraphQL type systems, written immediately alongside definitions in a {TypeSystemDocument} and made available via introspection.</p>
<p>Descriptions allow GraphQL service designers to easily provide documentation which remains consistent with the capabilities of a GraphQL service. Descriptions should be provided as Markdown (as specified by <a href="https://commonmark.org/">CommonMark</a>) for every definition in a type system.</p>
<p>GraphQL schema and all other definitions (e.g. types, fields, arguments, etc.) which can be described should provide a {Description} unless they are considered self descriptive.</p>
<p>As an example, this simple GraphQL schema is well described:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">A simple GraphQL schema which is well described.</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">schema {</div>
<div class="line">  query: Query</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">Root type for all your query operations</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">type Query {</div>
<div class="line">  &quot;&quot;&quot;</div>
<div class="line">  Translates a string from a given language into a different language.</div>
<div class="line">  &quot;&quot;&quot;</div>
<div class="line">  translate(</div>
<div class="line">    &quot;The original language that `text` is provided in.&quot;</div>
<div class="line">    fromLanguage: Language</div>
<div class="line"> </div>
<div class="line">    &quot;The translated language to be returned.&quot;</div>
<div class="line">    toLanguage: Language</div>
<div class="line"> </div>
<div class="line">    &quot;The text to be translated.&quot;</div>
<div class="line">    text: String</div>
<div class="line">  ): String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">The set of languages supported by `translate`.</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">enum Language {</div>
<div class="line">  &quot;English&quot;</div>
<div class="line">  EN</div>
<div class="line"> </div>
<div class="line">  &quot;French&quot;</div>
<div class="line">  FR</div>
<div class="line"> </div>
<div class="line">  &quot;Chinese&quot;</div>
<div class="line">  CH</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1095"></a>
Schema</h2>
<p>SchemaDefinition : Description? schema Directives[Const]? { RootOperationTypeDefinition+ }</p>
<p>RootOperationTypeDefinition : OperationType : NamedType</p>
<p>A GraphQL service's collective type system capabilities are referred to as that service's "schema". A schema is defined in terms of the types and directives it supports as well as the <em>root operation type</em> for each kind of operation: query, mutation, and subscription; this determines the place in the type system where those operations begin.</p>
<p>A GraphQL schema must itself be internally valid. This section describes the rules for this validation process where relevant.</p>
<p>All types within a GraphQL schema must have unique names. No two provided types may have the same name. No provided type may have a name which conflicts with any built in types (including Scalar and Introspection types).</p>
<p>All directives within a GraphQL schema must have unique names.</p>
<p>All types and directives defined within a schema must not have a name which begins with {"\_\_"} (two underscores), as this is used exclusively by GraphQL's introspection system.</p>
<h3><a class="anchor" id="autotoc_md1096"></a>
Root Operation Types</h3>
<p>:: A schema defines the initial <em>root operation type</em> for each kind of operation it supports: query, mutation, and subscription; this determines the place in the type system where those operations begin.</p>
<p>The {<code>query</code>} <em>root operation type</em> must be provided and must be an Object type.</p>
<p>The {<code>mutation</code>} <em>root operation type</em> is optional; if it is not provided, the service does not support mutations. If it is provided, it must be an Object type.</p>
<p>Similarly, the {<code>subscription</code>} <em>root operation type</em> is also optional; if it is not provided, the service does not support subscriptions. If it is provided, it must be an Object type.</p>
<p>The {<code>query</code>}, {<code>mutation</code>}, and {<code>subscription</code>} root types must all be different types if provided.</p>
<p>The fields on the {<code>query</code>} <em>root operation type</em> indicate what fields are available at the top level of a GraphQL query operation.</p>
<p>For example, this example operation:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query {</div>
<div class="line">  myName</div>
<div class="line">}</div>
</div><!-- fragment --><p>is only valid when the {<code>query</code>} <em>root operation type</em> has a field named "myName":</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Query {</div>
<div class="line">  myName: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>Similarly, the following mutation is only valid if the {<code>mutation</code>} <em>root operation type</em> has a field named "setName".</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">mutation {</div>
<div class="line">  setName(name: &quot;Zuck&quot;) {</div>
<div class="line">    newName</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using the type system definition language, a document must include at most one {<code>schema</code>} definition.</p>
<p>In this example, a GraphQL schema is defined with both a query and mutation <em>root operation type</em>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">schema {</div>
<div class="line">  query: MyQueryRootType</div>
<div class="line">  mutation: MyMutationRootType</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type MyQueryRootType {</div>
<div class="line">  someField: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type MyMutationRootType {</div>
<div class="line">  setSomeField(to: String): String</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Default Root Operation Type Names</b></p>
<p>:: The <em>default root type name</em> for each {<code>query</code>}, {<code>mutation</code>}, and {<code>subscription</code>} <em>root operation type</em> are {"Query"}, {"Mutation"}, and {"Subscription"} respectively.</p>
<p>The type system definition language can omit the schema definition when each <em>root operation type</em> uses its respective <em>default root type name</em>, no other type uses any <em>default root type name</em>, and the schema does not have a description.</p>
<p>Likewise, when representing a GraphQL schema using the type system definition language, a schema definition should be omitted if each <em>root operation type</em> uses its respective <em>default root type name</em>, no other type uses any <em>default root type name</em>, and the schema does not have a description.</p>
<p>This example describes a valid complete GraphQL schema, despite not explicitly including a {<code>schema</code>} definition. The {"Query"} type is presumed to be the {<code>query</code>} <em>root operation type</em> of the schema.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Query {</div>
<div class="line">  someField: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example describes a valid GraphQL schema without a {<code>mutation</code>} <em>root operation type</em>, even though it contains a type named {"Mutation"}. The schema definition must be included, otherwise the {"Mutation"} type would be incorrectly presumed to be the {<code>mutation</code>} <em>root operation type</em> of the schema.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">schema {</div>
<div class="line">  query: Query</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Query {</div>
<div class="line">  latestVirus: Virus</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Virus {</div>
<div class="line">  name: String</div>
<div class="line">  mutations: [Mutation]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Mutation {</div>
<div class="line">  name: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example describes a valid GraphQL schema with a description and both a {<code>query</code>} and {<code>mutation</code>} operation type:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">Example schema</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">schema {</div>
<div class="line">  query: Query</div>
<div class="line">  mutation: Mutation</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Query {</div>
<div class="line">  someField: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Mutation {</div>
<div class="line">  someMutation: String</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1097"></a>
Schema Extension</h3>
<p>SchemaExtension :</p>
<ul>
<li>extend schema Directives[Const]? { RootOperationTypeDefinition+ }</li>
<li>extend schema Directives[Const] [lookahead != <code>{</code>]</li>
</ul>
<p>Schema extensions are used to represent a schema which has been extended from a previous schema. For example, this might be used by a GraphQL service which adds additional operation types, or additional directives to an existing schema.</p>
<p>Note: Schema extensions without additional operation type definitions must not be followed by a {<code>{</code>} (such as a query shorthand) to avoid parsing ambiguity. The same limitation applies to the type definitions and extensions below.</p>
<p><b>Schema Validation</b></p>
<p>Schema extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The Schema must already be defined.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Schema.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1098"></a>
Types</h2>
<p>TypeDefinition :</p>
<ul>
<li>ScalarTypeDefinition</li>
<li>ObjectTypeDefinition</li>
<li>InterfaceTypeDefinition</li>
<li>UnionTypeDefinition</li>
<li>EnumTypeDefinition</li>
<li>InputObjectTypeDefinition</li>
</ul>
<p>The fundamental unit of any GraphQL Schema is the type. There are six kinds of named type definitions in GraphQL, and two wrapping types.</p>
<p>The most basic type is a <code>Scalar</code>. A scalar represents a primitive value, like a string or an integer. Oftentimes, the possible responses for a scalar field are enumerable. GraphQL offers an <code>Enum</code> type in those cases, where the type specifies the space of valid responses.</p>
<p>Scalars and Enums form the leaves in response trees; the intermediate levels are <code>Object</code> types, which define a set of fields, where each field is another type in the system, allowing the definition of arbitrary type hierarchies.</p>
<p>GraphQL supports two abstract types: interfaces and unions.</p>
<p>An <code>Interface</code> defines a list of fields; <code>Object</code> types and other Interface types which implement this Interface are guaranteed to implement those fields. Whenever a field claims it will return an Interface type, it will return a valid implementing Object type during execution.</p>
<p>A <code>Union</code> defines a list of possible types; similar to interfaces, whenever the type system claims a union will be returned, one of the possible types will be returned.</p>
<p>Finally, oftentimes it is useful to provide complex structs as inputs to GraphQL field arguments or variables; the <code>Input Object</code> type allows the schema to define exactly what data is expected.</p>
<h3><a class="anchor" id="autotoc_md1099"></a>
Wrapping Types</h3>
<p>All of the types so far are assumed to be both nullable and singular: e.g. a scalar string returns either null or a singular string.</p>
<p>A GraphQL schema may describe that a field represents a list of another type; the <code>List</code> type is provided for this reason, and wraps another type.</p>
<p>Similarly, the <code>Non-Null</code> type wraps another type, and denotes that the resulting value will never be {null} (and that an <em>execution error</em> cannot result in a {null} value).</p>
<p>These two types are referred to as "wrapping types"; non-wrapping types are referred to as "named types". A wrapping type has an underlying named type, found by continually unwrapping the type until a named type is found.</p>
<h3><a class="anchor" id="autotoc_md1100"></a>
Input and Output Types</h3>
<p>Types are used throughout GraphQL to describe both the values accepted as input to arguments and variables as well as the values output by fields. These two uses categorize types as <em>input types</em> and <em>output types</em>. Some kinds of types, like Scalar and Enum types, can be used as both input types and output types; other kinds of types can only be used in one or the other. Input Object types can only be used as input types. Object, Interface, and Union types can only be used as output types. Lists and Non-Null types may be used as input types or output types depending on how the wrapped type may be used.</p>
<p>IsInputType(type):</p>
<ul>
<li>If {type} is a List type or Non-Null type:<ul>
<li>Let {unwrappedType} be the unwrapped type of {type}.</li>
<li>Return {IsInputType(unwrappedType)}.</li>
</ul>
</li>
<li>If {type} is a Scalar, Enum, or Input Object type:<ul>
<li>Return {true}.</li>
</ul>
</li>
<li>Return {false}.</li>
</ul>
<p>IsOutputType(type):</p>
<ul>
<li>If {type} is a List type or Non-Null type:<ul>
<li>Let {unwrappedType} be the unwrapped type of {type}.</li>
<li>Return {IsOutputType(unwrappedType)}.</li>
</ul>
</li>
<li>If {type} is a Scalar, Object, Interface, Union, or Enum type:<ul>
<li>Return {true}.</li>
</ul>
</li>
<li>Return {false}.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1101"></a>
Type Extensions</h3>
<p>TypeExtension :</p>
<ul>
<li>ScalarTypeExtension</li>
<li>ObjectTypeExtension</li>
<li>InterfaceTypeExtension</li>
<li>UnionTypeExtension</li>
<li>EnumTypeExtension</li>
<li>InputObjectTypeExtension</li>
</ul>
<p>Type extensions are used to represent a GraphQL type which has been extended from some previous type. For example, this might be used by a local service to represent additional fields a GraphQL client only accesses locally.</p>
<h2><a class="anchor" id="autotoc_md1102"></a>
Scalars</h2>
<p>ScalarTypeDefinition : Description? scalar Name Directives[Const]?</p>
<p>Scalar types represent primitive leaf values in a GraphQL type system. GraphQL responses take the form of a hierarchical tree; the leaves of this tree are typically GraphQL Scalar types (but may also be Enum types or {null} values).</p>
<p>GraphQL provides a number of built-in scalars which are fully defined in the sections below, however type systems may also add additional custom scalars to introduce additional semantic meaning.</p>
<p><b>Built-in Scalars</b></p>
<p>GraphQL specifies a basic set of well-defined Scalar types: {Int}, {Float}, {String}, {Boolean}, and {ID}. A GraphQL framework should support all of these types, and a GraphQL service which provides a type by these names must adhere to the behavior described for them in this document. As an example, a service must not include a type called {Int} and use it to represent 64-bit numbers, internationalization information, or anything other than what is defined in this document.</p>
<p>When returning the set of types from the <code>__Schema</code> introspection type, all referenced built-in scalars must be included. If a built-in scalar type is not referenced anywhere in a schema (there is no field, argument, or input field of that type) then it must not be included.</p>
<p>When representing a GraphQL schema using the type system definition language, all built-in scalars must be omitted for brevity.</p>
<p><b>Custom Scalars</b></p>
<p>GraphQL services may use custom scalar types in addition to the built-in scalars. For example, a GraphQL service could define a scalar called <code>UUID</code> which, while serialized as a string, conforms to <a href="https://tools.ietf.org/html/rfc4122">RFC 4122</a>. When querying a field of type <code>UUID</code>, you can then rely on the ability to parse the result with an RFC 4122 compliant parser. Another example of a potentially useful custom scalar is <code>URL</code>, which serializes as a string, but is guaranteed by the service to be a valid URL.</p>
<p>:: When defining a custom scalar, GraphQL services should provide a <em>scalar specification URL</em> via the <code>@specifiedBy</code> directive or the <code>specifiedByURL</code> introspection field. This URL must link to a human-readable specification of the data format, serialization, and coercion rules for the scalar.</p>
<p>For example, a GraphQL service providing a <code>UUID</code> scalar may link to RFC 4122, or some custom document defining a reasonable subset of that RFC. If a <em>scalar specification URL</em> is present, systems and tools that are aware of it should conform to its described rules.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">scalar UUID @specifiedBy(url: &quot;https://tools.ietf.org/html/rfc4122&quot;)</div>
<div class="line">scalar URL @specifiedBy(url: &quot;https://tools.ietf.org/html/rfc3986&quot;)</div>
<div class="line">scalar DateTime</div>
<div class="line">  @specifiedBy(url: &quot;https://scalars.graphql.org/andimarek/date-time&quot;)</div>
</div><!-- fragment --><p>Custom *scalar specification URL*s should provide a single, stable format to avoid ambiguity. If the linked specification is in flux, the service should link to a fixed version rather than to a resource which might change.</p>
<p>Note: Some community-maintained custom scalar specifications are hosted at <a href="https://scalars.graphql.org/">scalars.graphql.org</a>.</p>
<p>Custom *scalar specification URL*s should not be changed once defined. Doing so would likely disrupt tooling or could introduce breaking changes within the linked specification's contents.</p>
<p>Built-in scalar types must not provide a <em>scalar specification URL</em> as they are specified by this document.</p>
<p>Note: Custom scalars should also summarize the specified format and provide examples in their description; see the GraphQL scalars <a href="https://scalars.graphql.org/implementation-guide">implementation guide</a> for more guidance.</p>
<p><b>Result Coercion and Serialization</b></p>
<p>A GraphQL service, when preparing a field of a given scalar type, must uphold the contract the scalar type describes, either by coercing the value or producing an <em>execution error</em> if a value cannot be coerced or if coercion may result in data loss.</p>
<p>A GraphQL service may decide to allow coercing different internal types to the expected return type. For example when coercing a field of type {Int} a boolean {true} value may produce {1} or a string value {"123"} may be parsed as base-10 {123}. However if internal type coercion cannot be reasonably performed without losing information, then it must raise an <em>execution error</em>.</p>
<p>Since this coercion behavior is not observable to clients of the GraphQL service, the precise rules of coercion are left to the implementation. The only requirement is that the service must yield values which adhere to the expected Scalar type.</p>
<p>GraphQL scalars are serialized according to the serialization format being used. There may be a most appropriate serialized primitive for each given scalar type, and the service should produce each primitive where appropriate.</p>
<p>See Serialization Format for more detailed information on the serialization of scalars in common JSON and other formats.</p>
<p><b>Input Coercion</b></p>
<p>If a GraphQL service expects a scalar type as input to an argument, coercion is observable and the rules must be well defined. If an input value does not match a coercion rule, a <em>request error</em> must be raised (input values are validated before execution begins).</p>
<p>GraphQL has different constant literals to represent integer and floating-point input values, and coercion rules may apply differently depending on which type of input value is encountered. GraphQL may be parameterized by variables, the values of which are often serialized when sent over a transport like HTTP. Since some common serializations (e.g. JSON) do not discriminate between integer and floating-point values, they are interpreted as an integer input value if they have an empty fractional part (e.g. <code>1.0</code>) and otherwise as floating-point input value.</p>
<p>For all types below, with the exception of Non-Null, if the explicit value {null} is provided, then the result of input coercion is {null}.</p>
<h3><a class="anchor" id="autotoc_md1103"></a>
Int</h3>
<p>The Int scalar type represents a signed 32-bit numeric non-fractional value. Response formats that support a 32-bit integer or a number type should use that type to represent this scalar.</p>
<p><b>Result Coercion</b></p>
<p>Fields returning the type {Int} expect to encounter 32-bit integer internal values.</p>
<p>GraphQL services may coerce non-integer internal values to integers when reasonable without losing information, otherwise they must raise an <em>execution error</em>. Examples of this may include returning <code>1</code> for the floating-point number <code>1.0</code>, or returning <code>123</code> for the string <code>"123"</code>. In scenarios where coercion may lose data, raising an execution error is more appropriate. For example, a floating-point number <code>1.2</code> should raise an execution error instead of being truncated to <code>1</code>.</p>
<p>If the integer internal value represents a value less than -2<sup>31</sup> or greater than or equal to 2<sup>31</sup>, an <em>execution error</em> should be raised.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input type, only integer input values are accepted. All other input values, including strings with numeric content, must raise a request error indicating an incorrect type. If the integer input value represents a value less than -2<sup>31</sup> or greater than or equal to 2<sup>31</sup>, a <em>request error</em> should be raised.</p>
<p>Note: Numeric integer values larger than 32-bit should either use String or a custom-defined Scalar type, as not all platforms and transports support encoding integer numbers larger than 32-bit.</p>
<h3><a class="anchor" id="autotoc_md1104"></a>
Float</h3>
<p>The Float scalar type represents signed double-precision finite values as specified by <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>. Response formats that support an appropriate double-precision number type should use that type to represent this scalar.</p>
<p><b>Result Coercion</b></p>
<p>Fields returning the type {Float} expect to encounter double-precision floating-point internal values.</p>
<p>GraphQL services may coerce non-floating-point internal values to {Float} when reasonable without losing information, otherwise they must raise an <em>execution error</em>. Examples of this may include returning <code>1.0</code> for the integer number <code>1</code>, or <code>123.0</code> for the string <code>"123"</code>.</p>
<p>Non-finite floating-point internal values ({NaN} and {Infinity}) cannot be coerced to {Float} and must raise an <em>execution error</em>.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input type, both integer and float input values are accepted. Integer input values are coerced to Float by adding an empty fractional part, for example <code>1.0</code> for the integer input value <code>1</code>. All other input values, including strings with numeric content, must raise a <em>request error</em> indicating an incorrect type. If the input value otherwise represents a value not representable by finite IEEE 754 (e.g. {NaN}, {Infinity}, or a value outside the available precision), a <em>request error</em> must be raised.</p>
<h3><a class="anchor" id="autotoc_md1105"></a>
String</h3>
<p>The String scalar type represents textual data, represented as a sequence of Unicode code points. The String type is most often used by GraphQL to represent free-form human-readable text. How the String is encoded internally (for example UTF-8) is left to the service implementation. All response serialization formats must support a string representation (for example, JSON Unicode strings), and that representation must be used to serialize this type.</p>
<p><b>Result Coercion</b></p>
<p>Fields returning the type {String} expect to encounter Unicode string values.</p>
<p>GraphQL services may coerce non-string raw values to {String} when reasonable without losing information, otherwise they must raise an <em>execution error</em>. Examples of this may include returning the string <code>"true"</code> for a boolean true value, or the string <code>"1"</code> for the integer <code>1</code>.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input type, only valid Unicode string input values are accepted. All other input values must raise a <em>request error</em> indicating an incorrect type.</p>
<h3><a class="anchor" id="autotoc_md1106"></a>
Boolean</h3>
<p>The Boolean scalar type represents <code>true</code> or <code>false</code>. Response formats should use a built-in boolean type if supported; otherwise, they should use their representation of the integers <code>1</code> and <code>0</code>.</p>
<p><b>Result Coercion</b></p>
<p>Fields returning the type {Boolean} expect to encounter boolean internal values.</p>
<p>GraphQL services may coerce non-boolean raw values to {Boolean} when reasonable without losing information, otherwise they must raise an <em>execution error</em>. Examples of this may include returning <code>true</code> for non-zero numbers.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input type, only boolean input values are accepted. All other input values must raise a <em>request error</em> indicating an incorrect type.</p>
<h3><a class="anchor" id="autotoc_md1107"></a>
ID</h3>
<p>The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a {String}; however, it is not intended to be human-readable. While it is often numeric, it must always serialize as a {String}.</p>
<p><b>Result Coercion</b></p>
<p>GraphQL is agnostic to ID format, and serializes to string to ensure consistency across many formats ID could represent, from small auto-increment numbers, to large 128-bit random numbers, to base64 encoded values, or string values of a format like <a href="https://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a>.</p>
<p>GraphQL services should coerce as appropriate given the ID formats they expect. When coercion is not possible they must raise an <em>execution error</em>.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input type, any string (such as <code>"4"</code>) or integer (such as <code>4</code> or <code>-4</code>) input value should be coerced to ID as appropriate for the ID formats a given GraphQL service expects. Any other input value, including float input values (such as <code>4.0</code>), must raise a <em>request error</em> indicating an incorrect type.</p>
<h3><a class="anchor" id="autotoc_md1108"></a>
Scalar Extensions</h3>
<p>ScalarTypeExtension :</p>
<ul>
<li>extend scalar Name Directives[Const]</li>
</ul>
<p>Scalar type extensions are used to represent a scalar type which has been extended from some previous scalar type. For example, this might be used by a GraphQL tool or service which adds directives to an existing scalar.</p>
<p><b>Type Validation</b></p>
<p>Scalar type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be a Scalar type.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Scalar type.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1109"></a>
Objects</h2>
<p>ObjectTypeDefinition :</p>
<ul>
<li>Description? type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition</li>
<li>Description? type Name ImplementsInterfaces? Directives[Const]? [lookahead != <code>{</code>]</li>
</ul>
<p>ImplementsInterfaces :</p>
<ul>
<li>ImplementsInterfaces &amp; NamedType</li>
<li>implements <code>&amp;</code>? NamedType</li>
</ul>
<p>FieldsDefinition : { FieldDefinition+ }</p>
<p>FieldDefinition : Description? Name ArgumentsDefinition? : Type Directives[Const]?</p>
<p>GraphQL operations are hierarchical and composed, describing a tree of information. While Scalar types describe the leaf values of these hierarchical operations, Objects describe the intermediate levels.</p>
<p>GraphQL Objects represent a list of named fields, each of which yields a value of a specific type. Object values should be serialized as ordered maps, where the selected field names (or aliases) are the keys and the result of evaluating the field is the value, ordered by the order in which they appear in the <em>selection set</em>.</p>
<p>All fields defined within an Object type must not have a name which begins with {"\_\_"} (two underscores), as this is used exclusively by GraphQL's introspection system.</p>
<p>For example, a type <code>Person</code> could be described as:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Person {</div>
<div class="line">  name: String</div>
<div class="line">  age: Int</div>
<div class="line">  picture: Url</div>
<div class="line">}</div>
</div><!-- fragment --><p>Where <code>name</code> is a field that will yield a {String} value, and <code>age</code> is a field that will yield an {Int} value, and <code>picture</code> is a field that will yield a <code>Url</code> value.</p>
<p>A query of an object value must select at least one field. This selection of fields will yield an ordered map containing exactly the subset of the object queried, which should be represented in the order in which they were queried. Only fields that are declared on the object type may validly be queried on that object.</p>
<p>For example, selecting all the fields of <code>Person</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  name</div>
<div class="line">  age</div>
<div class="line">  picture</div>
<div class="line">}</div>
</div><!-- fragment --><p>Would yield the object:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,</div>
<div class="line">  &quot;age&quot;: 30,</div>
<div class="line">  &quot;picture&quot;: &quot;http://some.cdn/picture.jpg&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>While selecting a subset of fields:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  age</div>
<div class="line">  name</div>
<div class="line">}</div>
</div><!-- fragment --><p>Must only yield exactly that subset:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;age&quot;: 30,</div>
<div class="line">  &quot;name&quot;: &quot;Mark Zuckerberg&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A field of an Object type may be a Scalar, Enum, another Object type, an Interface, or a Union. Additionally, it may be any wrapping type whose underlying base type is one of those five.</p>
<p>For example, the <code>Person</code> type might include a <code>relationship</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Person {</div>
<div class="line">  name: String</div>
<div class="line">  age: Int</div>
<div class="line">  picture: Url</div>
<div class="line">  relationship: Person</div>
<div class="line">}</div>
</div><!-- fragment --><p>Valid operations must supply a <em>selection set</em> for every field whose return type is an object type, so this operation is not valid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  name</div>
<div class="line">  relationship</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, this example is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  name</div>
<div class="line">  relationship {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And will yield the subset of each object type queried:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,</div>
<div class="line">  &quot;relationship&quot;: {</div>
<div class="line">    &quot;name&quot;: &quot;Priscilla Chan&quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Field Ordering</b></p>
<p>When querying an Object, the resulting mapping of fields are conceptually ordered in the same order in which they were encountered during execution, excluding fragments for which the type does not apply and fields or fragments that are skipped via <code>@skip</code> or <code>@include</code> directives. This ordering is correctly produced when using the {CollectFields()} algorithm.</p>
<p>Response serialization formats capable of representing ordered maps should maintain this ordering. Serialization formats which can only represent unordered maps (such as JSON) should retain this order textually. That is, if two fields <code>{foo, bar}</code> were queried in that order, the resulting JSON serialization should contain <code>{"foo": "...", "bar": "..."}</code> in the same order.</p>
<p>Producing a response where fields are represented in the same order in which they appear in the request improves human readability during debugging and enables more efficient parsing of responses if the order of properties can be anticipated.</p>
<p>If a fragment is spread before other fields, the fields that fragment specifies occur in the response before the following fields.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  foo</div>
<div class="line">  ...Frag</div>
<div class="line">  qux</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment Frag on Query {</div>
<div class="line">  bar</div>
<div class="line">  baz</div>
<div class="line">}</div>
</div><!-- fragment --><p>Produces the ordered result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;foo&quot;: 1,</div>
<div class="line">  &quot;bar&quot;: 2,</div>
<div class="line">  &quot;baz&quot;: 3,</div>
<div class="line">  &quot;qux&quot;: 4</div>
<div class="line">}</div>
</div><!-- fragment --><p>If a field is queried multiple times in a selection, it is ordered by the first time it is encountered. However fragments for which the type does not apply do not affect ordering.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  foo</div>
<div class="line">  ...Ignored</div>
<div class="line">  ...Matching</div>
<div class="line">  bar</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment Ignored on UnknownType {</div>
<div class="line">  qux</div>
<div class="line">  baz</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment Matching on Query {</div>
<div class="line">  bar</div>
<div class="line">  qux</div>
<div class="line">  foo</div>
<div class="line">}</div>
</div><!-- fragment --><p>Produces the ordered result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;foo&quot;: 1,</div>
<div class="line">  &quot;bar&quot;: 2,</div>
<div class="line">  &quot;qux&quot;: 3</div>
<div class="line">}</div>
</div><!-- fragment --><p>Also, if directives result in fields being excluded, they are not considered in the ordering of fields.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  foo @skip(if: true)</div>
<div class="line">  bar</div>
<div class="line">  foo</div>
<div class="line">}</div>
</div><!-- fragment --><p>Produces the ordered result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;bar&quot;: 1,</div>
<div class="line">  &quot;foo&quot;: 2</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Result Coercion</b></p>
<p>Determining the result of coercing an object is the heart of the GraphQL executor, see Value Completion.</p>
<p><b>Input Coercion</b></p>
<p>Objects are never valid inputs.</p>
<p><b>Type Validation</b></p>
<p>Object types have the potential to be invalid if incorrectly defined. This set of rules must be adhered to by every Object type in a GraphQL schema.</p>
<ol type="1">
<li>An Object type must define one or more fields.</li>
<li>For each field of an Object type:<ol type="a">
<li>The field must have a unique name within that Object type; no two fields may share the same name.</li>
<li>The field must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The field must return a type where {IsOutputType(fieldType)} returns {true}.</li>
<li>For each argument of the field:<ol type="i">
<li>The argument must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The argument must have a unique name within that field; no two arguments may share the same name.</li>
<li>The argument must accept a type where {IsInputType(argumentType)} returns {true}.</li>
<li>If argument type is Non-Null and a default value is not defined:<ol type="A">
<li>The <code>@deprecated</code> directive must not be applied to this argument.</li>
</ol>
</li>
<li>If the argument has a default value it must be compatible with {argumentType} as per the coercion rules for that type.</li>
</ol>
</li>
</ol>
</li>
<li>An object type may declare that it implements one or more unique interfaces.</li>
<li>An object type must be a super-set of all interfaces it implements:<ol type="a">
<li>Let this object type be {objectType}.</li>
<li>For each interface declared implemented as {interfaceType}, {IsValidImplementation(objectType, interfaceType)} must be {true}.</li>
</ol>
</li>
</ol>
<p>IsValidImplementation(type, implementedType):</p>
<ol type="1">
<li>If {implementedType} declares it implements any interfaces, {type} must also declare it implements those interfaces.</li>
<li>{type} must include a field of the same name for every field defined in {implementedType}.<ol type="a">
<li>Let {field} be that named field on {type}.</li>
<li>Let {implementedField} be that named field on {implementedType}.</li>
<li>{field} must include an argument of the same name for every argument defined in {implementedField}.<ol type="i">
<li>That named argument on {field} must accept the same type (invariant) as that named argument on {implementedField}.</li>
</ol>
</li>
<li>{field} may include additional arguments not defined in {implementedField}, but any additional argument must not be required, e.g. must not be of a non-nullable type.</li>
<li>{field} must return a type which is equal to or a sub-type of (covariant) the return type of {implementedField} field's return type:<ol type="i">
<li>Let {fieldType} be the return type of {field}.</li>
<li>Let {implementedFieldType} be the return type of {implementedField}.</li>
<li>{IsValidImplementationFieldType(fieldType, implementedFieldType)} must be {true}.</li>
</ol>
</li>
<li>If {field} is deprecated then {implementedField} must also be deprecated.</li>
</ol>
</li>
</ol>
<p>IsValidImplementationFieldType(fieldType, implementedFieldType):</p>
<ol type="1">
<li>If {fieldType} is a Non-Null type:<ol type="a">
<li>Let {nullableType} be the unwrapped nullable type of {fieldType}.</li>
<li>Let {implementedNullableType} be the unwrapped nullable type of {implementedFieldType} if it is a Non-Null type, otherwise let it be {implementedFieldType} directly.</li>
<li>Return {IsValidImplementationFieldType(nullableType,
      implementedNullableType)}.</li>
</ol>
</li>
<li>If {fieldType} is a List type and {implementedFieldType} is also a List type:<ol type="a">
<li>Let {itemType} be the unwrapped item type of {fieldType}.</li>
<li>Let {implementedItemType} be the unwrapped item type of {implementedFieldType}.</li>
<li>Return {IsValidImplementationFieldType(itemType, implementedItemType)}.</li>
</ol>
</li>
<li>Return {IsSubType(fieldType, implementedFieldType)}.</li>
</ol>
<p>IsSubType(possibleSubType, superType):</p>
<ol type="1">
<li>If {possibleSubType} is the same type as {superType} then return {true}.</li>
<li>If {possibleSubType} is an Object type and {superType} is a Union type and {possibleSubType} is a possible type of {superType} then return {true}.</li>
<li>If {possibleSubType} is an Object or Interface type and {superType} is an Interface type and {possibleSubType} declares it implements {superType} then return {true}.</li>
<li>Otherwise return {false}.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1110"></a>
Field Arguments</h3>
<p>ArgumentsDefinition : ( InputValueDefinition+ )</p>
<p>InputValueDefinition : Description? Name : Type DefaultValue? Directives[Const]?</p>
<p>Object fields are conceptually functions which yield values. Occasionally object fields can accept arguments to further specify the return value. Object field arguments are defined as a list of all possible argument names and their expected input types.</p>
<p>All arguments defined within a field must not have a name which begins with {"\_\_"} (two underscores), as this is used exclusively by GraphQL's introspection system.</p>
<p>For example, a <code>Person</code> type with a <code>picture</code> field could accept an argument to determine what size of an image to return.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Person {</div>
<div class="line">  name: String</div>
<div class="line">  picture(size: Int): Url</div>
<div class="line">}</div>
</div><!-- fragment --><p>Operations can optionally specify arguments to their fields to provide these arguments.</p>
<p>This example operation:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  name</div>
<div class="line">  picture(size: 600)</div>
<div class="line">}</div>
</div><!-- fragment --><p>May return the result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;name&quot;: &quot;Mark Zuckerberg&quot;,</div>
<div class="line">  &quot;picture&quot;: &quot;http://some.cdn/picture_600.jpg&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The type of an object field argument must be an input type (any type except an Object, Interface, or Union type).</p>
<h3><a class="anchor" id="autotoc_md1111"></a>
Field Deprecation</h3>
<p>Fields in an object may be marked as deprecated as deemed necessary by the application. It is still legal to include these fields in a <em>selection set</em> (to ensure existing clients are not broken by the change), but the fields should be appropriately treated in documentation and tooling.</p>
<p>When using the type system definition language, <code>@deprecated</code> directives are used to indicate that a field is deprecated:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type ExampleType {</div>
<div class="line">  oldField: String @deprecated</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1112"></a>
Object Extensions</h3>
<p>ObjectTypeExtension :</p>
<ul>
<li>extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition</li>
<li>extend type Name ImplementsInterfaces? Directives[Const] [lookahead != <code>{</code>]</li>
<li>extend type Name ImplementsInterfaces [lookahead != <code>{</code>]</li>
</ul>
<p>Object type extensions are used to represent a type which has been extended from some previous type. For example, this might be used to represent local data, or by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p>In this example, a local data field is added to a <code>Story</code> type:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend type Story {</div>
<div class="line">  isHiddenLocally: Boolean</div>
<div class="line">}</div>
</div><!-- fragment --><p>Object type extensions may choose not to add additional fields, instead only adding interfaces or directives.</p>
<p>In this example, a directive is added to a <code>User</code> type without adding fields:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend type User @addedDirective</div>
</div><!-- fragment --><p><b>Type Validation</b></p>
<p>Object type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be an Object type.</li>
<li>The fields of an Object type extension must have unique names; no two fields may share the same name.</li>
<li>Any fields of an Object type extension must not be already defined on the previous Object type.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Object type.</li>
<li>Any interfaces provided must not be already implemented by the previous Object type.</li>
<li>The resulting extended object type must be a super-set of all interfaces it implements.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1113"></a>
Interfaces</h2>
<p>InterfaceTypeDefinition :</p>
<ul>
<li>Description? interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition</li>
<li>Description? interface Name ImplementsInterfaces? Directives[Const]? [lookahead != <code>{</code>]</li>
</ul>
<p>GraphQL interfaces represent a list of named fields and their arguments. GraphQL objects and interfaces can then implement these interfaces which requires the implementing type to define all fields defined by those interfaces.</p>
<p>Fields on a GraphQL interface have the same rules as fields on a GraphQL object; their type can be Scalar, Object, Enum, Interface, or Union, or any wrapping type whose base type is one of those five.</p>
<p>For example, an interface <code>NamedEntity</code> may describe a required field and types such as <code>Person</code> or <code>Business</code> may then implement this interface to guarantee this field will always exist.</p>
<p>Types may also implement multiple interfaces. For example, <code>Business</code> implements both the <code>NamedEntity</code> and <code>ValuedEntity</code> interfaces in the example below.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">interface NamedEntity {</div>
<div class="line">  name: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface ValuedEntity {</div>
<div class="line">  value: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Person implements NamedEntity {</div>
<div class="line">  name: String</div>
<div class="line">  age: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Business implements NamedEntity &amp; ValuedEntity {</div>
<div class="line">  name: String</div>
<div class="line">  value: Int</div>
<div class="line">  employeeCount: Int</div>
<div class="line">}</div>
</div><!-- fragment --><p>Fields which yield an interface are useful when one of many Object types are expected, but some fields should be guaranteed.</p>
<p>To continue the example, a <code>Contact</code> might refer to <code>NamedEntity</code>.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Contact {</div>
<div class="line">  entity: NamedEntity</div>
<div class="line">  phoneNumber: String</div>
<div class="line">  address: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>This allows us to write a <em>selection set</em> for a <code>Contact</code> that can select the common fields.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  entity {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">  phoneNumber</div>
<div class="line">}</div>
</div><!-- fragment --><p>When selecting fields on an interface type, only those fields declared on the interface may be queried. In the above example, <code>entity</code> returns a <code>NamedEntity</code>, and <code>name</code> is defined on <code>NamedEntity</code>, so it is valid. However, the following would not be a valid selection set against <code>Contact</code>:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  entity {</div>
<div class="line">    name</div>
<div class="line">    age</div>
<div class="line">  }</div>
<div class="line">  phoneNumber</div>
<div class="line">}</div>
</div><!-- fragment --><p>because <code>entity</code> refers to a <code>NamedEntity</code>, and <code>age</code> is not defined on that interface. Querying for <code>age</code> is only valid when the result of <code>entity</code> is a <code>Person</code>; this can be expressed using a fragment or an inline fragment:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  entity {</div>
<div class="line">    name</div>
<div class="line">    ... on Person {</div>
<div class="line">      age</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  phoneNumber</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Interfaces Implementing Interfaces</b></p>
<p>When defining an interface that implements another interface, the implementing interface must define each field that is specified by the implemented interface. For example, the interface Resource must define the field id to implement the Node interface:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">interface Node {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Resource implements Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  url: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>Transitively implemented interfaces (interfaces implemented by the interface that is being implemented) must also be defined on an implementing type or interface. For example, <code>Image</code> cannot implement <code>Resource</code> without also implementing <code>Node</code>:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">interface Node {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Resource implements Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  url: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Image implements Resource &amp; Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  url: String</div>
<div class="line">  thumbnail: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>Interface definitions must not contain cyclic references nor implement themselves. This example is invalid because <code>Node</code> and <code>Named</code> implement themselves and each other:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">interface Node implements Named &amp; Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Named implements Node &amp; Named {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Result Coercion</b></p>
<p>The interface type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the interface is the same as the result coercion of the object.</p>
<p><b>Input Coercion</b></p>
<p>Interfaces are never valid inputs.</p>
<p><b>Type Validation</b></p>
<p>Interface types have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>An Interface type must define one or more fields.</li>
<li>For each field of an Interface type:<ol type="a">
<li>The field must have a unique name within that Interface type; no two fields may share the same name.</li>
<li>The field must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The field must return a type where {IsOutputType(fieldType)} returns {true}.</li>
<li>For each argument of the field:<ol type="i">
<li>The argument must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The argument must have a unique name within that field; no two arguments may share the same name.</li>
<li>The argument must accept a type where {IsInputType(argumentType)} returns {true}.</li>
</ol>
</li>
</ol>
</li>
<li>An interface type may declare that it implements one or more unique interfaces, but may not implement itself.</li>
<li>An interface type must be a super-set of all interfaces it implements:<ol type="a">
<li>Let this interface type be {implementingType}.</li>
<li>For each interface declared implemented as {implementedType}, {IsValidImplementation(implementingType, implementedType)} must be {true}.</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md1114"></a>
Interface Extensions</h3>
<p>InterfaceTypeExtension :</p>
<ul>
<li>extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition</li>
<li>extend interface Name ImplementsInterfaces? Directives[Const] [lookahead != <code>{</code>]</li>
<li>extend interface Name ImplementsInterfaces [lookahead != <code>{</code>]</li>
</ul>
<p>Interface type extensions are used to represent an interface which has been extended from some previous interface. For example, this might be used to represent common local data on many types, or by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p>In this example, an extended data field is added to a <code>NamedEntity</code> type along with the types which implement it:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend interface NamedEntity {</div>
<div class="line">  nickname: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extend type Person {</div>
<div class="line">  nickname: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extend type Business {</div>
<div class="line">  nickname: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>Interface type extensions may choose not to add additional fields, instead only adding directives.</p>
<p>In this example, a directive is added to a <code>NamedEntity</code> type without adding fields:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend interface NamedEntity @addedDirective</div>
</div><!-- fragment --><p><b>Type Validation</b></p>
<p>Interface type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be an Interface type.</li>
<li>The fields of an Interface type extension must have unique names; no two fields may share the same name.</li>
<li>Any fields of an Interface type extension must not be already defined on the previous Interface type.</li>
<li>Any Object or Interface type which implemented the previous Interface type must also be a super-set of the fields of the Interface type extension (which may be due to Object type extension).</li>
<li>Any non-repeatable directives provided must not already apply to the previous Interface type.</li>
<li>The resulting extended Interface type must be a super-set of all Interfaces it implements.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1115"></a>
Unions</h2>
<p>UnionTypeDefinition : Description? union Name Directives[Const]? UnionMemberTypes?</p>
<p>UnionMemberTypes :</p>
<ul>
<li>UnionMemberTypes | NamedType</li>
<li>= <code>|</code>? NamedType</li>
</ul>
<p>GraphQL Unions represent an object that could be one of a list of GraphQL Object types, but provides for no guaranteed fields between those types. They also differ from interfaces in that Object types declare what interfaces they implement, but are not aware of what unions contain them.</p>
<p>With interfaces and objects, only those fields defined on the type can be queried directly; to query other fields on an interface, typed fragments must be used. This is the same as for unions, but unions do not define any fields, so <b>no</b> fields may be queried on this type without the use of type refining fragments or inline fragments (with the exception of the meta-field {__typename}).</p>
<p>For example, we might define the following types:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">union SearchResult = Photo | Person</div>
<div class="line"> </div>
<div class="line">type Person {</div>
<div class="line">  name: String</div>
<div class="line">  age: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Photo {</div>
<div class="line">  height: Int</div>
<div class="line">  width: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type SearchQuery {</div>
<div class="line">  firstSearchResult: SearchResult</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this example, a query operation wants the name if the result was a Person, and the height if it was a photo. However because a union itself defines no fields, this could be ambiguous and is invalid.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  firstSearchResult {</div>
<div class="line">    name</div>
<div class="line">    height</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>A valid operation includes typed fragments (in this example, inline fragments):</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  firstSearchResult {</div>
<div class="line">    ... on Person {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">    ... on Photo {</div>
<div class="line">      height</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Union members may be defined with an optional leading <code>|</code> character to aid formatting when representing a longer list of possible types:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">union SearchResult =</div>
<div class="line">  | Photo</div>
<div class="line">  | Person</div>
</div><!-- fragment --><p><b>Result Coercion</b></p>
<p>The union type should have some way of determining which object a given result corresponds to. Once it has done so, the result coercion of the union is the same as the result coercion of the object.</p>
<p><b>Input Coercion</b></p>
<p>Unions are never valid inputs.</p>
<p><b>Type Validation</b></p>
<p>Union types have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>A Union type must include one or more unique member types.</li>
<li>The member types of a Union type must all be Object base types; Scalar, Interface and Union types must not be member types of a Union. Similarly, wrapping types must not be member types of a Union.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1116"></a>
Union Extensions</h3>
<p>UnionTypeExtension :</p>
<ul>
<li>extend union Name Directives[Const]? UnionMemberTypes</li>
<li>extend union Name Directives[Const]</li>
</ul>
<p>Union type extensions are used to represent a union type which has been extended from some previous union type. For example, this might be used to represent additional local data, or by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p><b>Type Validation</b></p>
<p>Union type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be a Union type.</li>
<li>The member types of a Union type extension must all be Object base types; Scalar, Interface and Union types must not be member types of a Union. Similarly, wrapping types must not be member types of a Union.</li>
<li>All member types of a Union type extension must be unique.</li>
<li>All member types of a Union type extension must not already be a member of the previous Union type.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Union type.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1117"></a>
Enums</h2>
<p>EnumTypeDefinition :</p>
<ul>
<li>Description? enum Name Directives[Const]? EnumValuesDefinition</li>
<li>Description? enum Name Directives[Const]? [lookahead != <code>{</code>]</li>
</ul>
<p>EnumValuesDefinition : { EnumValueDefinition+ }</p>
<p>EnumValueDefinition : Description? EnumValue Directives[Const]?</p>
<p>GraphQL Enum types, like Scalar types, also represent leaf values in a GraphQL type system. However Enum types describe the set of possible values.</p>
<p>Enums are not references for a numeric value, but are unique values in their own right. They may serialize as a string: the name of the represented value.</p>
<p>In this example, an Enum type called <code>Direction</code> is defined:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">enum Direction {</div>
<div class="line">  NORTH</div>
<div class="line">  EAST</div>
<div class="line">  SOUTH</div>
<div class="line">  WEST</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Result Coercion</b></p>
<p>GraphQL services must return one of the defined set of possible values. If a reasonable coercion is not possible they must raise an <em>execution error</em>.</p>
<p><b>Input Coercion</b></p>
<p>GraphQL has a constant literal to represent enum input values. GraphQL string literals must not be accepted as an enum input and instead raise a request error.</p>
<p>Variable transport serializations which have a different representation for non-string symbolic values (for example, <a href="https://github.com/edn-format/edn">EDN</a>) should only allow such values as enum input values. Otherwise, for most transport serializations that do not, strings may be interpreted as the enum input value with the same name.</p>
<p><b>Type Validation</b></p>
<p>Enum types have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>An Enum type must define one or more unique enum values.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1118"></a>
Enum Extensions</h3>
<p>EnumTypeExtension :</p>
<ul>
<li>extend enum Name Directives[Const]? EnumValuesDefinition</li>
<li>extend enum Name Directives[Const] [lookahead != <code>{</code>]</li>
</ul>
<p>Enum type extensions are used to represent an enum type which has been extended from some previous enum type. For example, this might be used to represent additional local data, or by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p><b>Type Validation</b></p>
<p>Enum type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be an Enum type.</li>
<li>All values of an Enum type extension must be unique.</li>
<li>All values of an Enum type extension must not already be a value of the previous Enum.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Enum type.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1119"></a>
Input Objects</h2>
<p>InputObjectTypeDefinition :</p>
<ul>
<li>Description? input Name Directives[Const]? InputFieldsDefinition</li>
<li>Description? input Name Directives[Const]? [lookahead != <code>{</code>]</li>
</ul>
<p>InputFieldsDefinition : { InputValueDefinition+ }</p>
<p>Fields may accept arguments to configure their behavior. These inputs are often scalars or enums, but they sometimes need to represent more complex values.</p>
<p>:: A GraphQL <em>Input Object</em> defines a set of input fields; the input fields are scalars, enums, other input objects, or any wrapping type whose underlying base type is one of those three. This allows arguments to accept arbitrarily complex structs.</p>
<p>In this example, an Input Object called <code>Point2D</code> describes <code>x</code> and <code>y</code> inputs:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input Point2D {</div>
<div class="line">  x: Float</div>
<div class="line">  y: Float</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: The GraphQL Object type ({ObjectTypeDefinition}) defined above is inappropriate for re-use here, because Object types can contain fields that define arguments or contain references to interfaces and unions, neither of which is appropriate for use as an input argument. For this reason, input objects have a separate type in the system.</p>
<p><b>Circular References</b></p>
<p>Input Objects are allowed to reference other Input Objects as field types. A circular reference occurs when an Input Object references itself either directly or through referenced Input Objects.</p>
<p>Circular references are generally allowed, however they may not be defined as an unbroken chain of Non-Null singular fields. Such Input Objects are invalid because there is no way to provide a legal value for them.</p>
<p>This example of a circularly-referenced input type is valid as the field <code>self</code> may be omitted or the value {null}.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input Example {</div>
<div class="line">  self: Example</div>
<div class="line">  value: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example is also valid as the field <code>self</code> may be an empty List.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input Example {</div>
<div class="line">  self: [Example!]!</div>
<div class="line">  value: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example of a circularly-referenced input type is invalid as the field <code>self</code> cannot be provided a finite value.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">input Example {</div>
<div class="line">  value: String</div>
<div class="line">  self: Example!</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example is also invalid, as there is a non-null singular circular reference via the <code>First.second</code> and <code>Second.first</code> fields.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">input First {</div>
<div class="line">  second: Second!</div>
<div class="line">  value: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input Second {</div>
<div class="line">  first: First!</div>
<div class="line">  value: String</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Result Coercion</b></p>
<p>An input object is never a valid result. Input Object types cannot be the return type of an Object or Interface field.</p>
<p><b>Input Coercion</b></p>
<p>The value for an input object should be an input object literal or an unordered map supplied by a variable, otherwise a <em>request error</em> must be raised. In either case, the input object literal or unordered map must not contain any entries with names not defined by a field of this input object type, otherwise a request error must be raised.</p>
<p>The result of coercion is an unordered map with an entry for each field both defined by the input object type and for which a value exists. The resulting map is constructed with the following rules:</p>
<ul>
<li>If no value is provided for a defined input object field and that field definition provides a default value, the result of coercing the default value according to the coercion rules of the input field type should be used. If no default value is provided and the input object field's type is non-null, an error should be raised. Otherwise, if the field is not required, then no entry is added to the coerced unordered map.</li>
<li>If the value {null} was provided for an input object field, and the field's type is not a non-null type, an entry in the coerced unordered map is given the value {null}. In other words, there is a semantic difference between the explicitly provided value {null} versus having not provided a value.</li>
<li>If a literal value is provided for an input object field, an entry in the coerced unordered map is given the result of coercing that value according to the input coercion rules for the type of that field.</li>
<li>If a variable is provided for an input object field, the runtime value of that variable must be used. If the runtime value is {null} and the field type is non-null, an <em>execution error</em> must be raised. If no runtime value is provided, the variable definition's default value should be used. If the variable definition does not provide a default value, the input object field definition's default value should be used.</li>
</ul>
<p>Following are examples of input coercion for an input object type with a <code>String</code> field <code>a</code> and a required (non-null) <code>Int!</code> field <code>b</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input ExampleInputObject {</div>
<div class="line">  a: String</div>
<div class="line">  b: Int!</div>
<div class="line">}</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Literal Value   </th><th class="markdownTableHeadNone">Variables   </th><th class="markdownTableHeadNone">Coerced Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ a: "abc", b: 123 }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: null, b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ a: null, b: 123 }</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ b: 123 }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: $var, b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{ var: null }</code>   </td><td class="markdownTableBodyNone"><code>{ a: null, b: 123 }</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: $var, b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ b: 123 }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ b: $var }</code>   </td><td class="markdownTableBodyNone"><code>{ var: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{ b: 123 }</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: { b: 123 } }</code>   </td><td class="markdownTableBodyNone"><code>{ b: 123 }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>"abc123"</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Incorrect value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: "abc123" }</code>   </td><td class="markdownTableBodyNone">Error: Incorrect value    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: "123" }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Incorrect value for field {b}    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: "abc" }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Missing required field {b}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ b: $var }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Missing required field {b}.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: { a: "abc" } }</code>   </td><td class="markdownTableBodyNone">Error: Missing required field {b}    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: null }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: {b} must be non-null.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ b: $var }</code>   </td><td class="markdownTableBodyNone"><code>{ var: null }</code>   </td><td class="markdownTableBodyNone">Error: {b} must be non-null.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ b: 123, c: "xyz" }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Unexpected field {c}   </td></tr>
</table>
<p><b>Type Validation</b></p>
<ol type="1">
<li>An Input Object type must define one or more input fields.</li>
<li>For each input field of an Input Object type:<ol type="a">
<li>The input field must have a unique name within that Input Object type; no two input fields may share the same name.</li>
<li>The input field must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The input field must accept a type where {IsInputType(inputFieldType)} returns {true}.</li>
<li>If input field type is Non-Null and a default value is not defined:<ol type="i">
<li>The <code>@deprecated</code> directive must not be applied to this input field.</li>
</ol>
</li>
<li>If the Input Object is a <em>OneOf Input Object</em> then:<ol type="i">
<li>The type of the input field must be nullable.</li>
<li>The input field must not have a default value.</li>
</ol>
</li>
</ol>
</li>
<li>If an Input Object references itself either directly or through referenced Input Objects, at least one of the fields in the chain of references must be either a nullable or a List type.</li>
<li>{InputObjectDefaultValueHasCycle(inputObject)} must be {false}.</li>
</ol>
<p>InputObjectDefaultValueHasCycle(inputObject, defaultValue, visitedFields):</p>
<ul>
<li>If {defaultValue} is not provided, initialize it to an empty unordered map.</li>
<li>If {visitedFields} is not provided, initialize it to the empty set.</li>
<li>If {defaultValue} is a list:<ul>
<li>For each {itemValue} in {defaultValue}:<ul>
<li>If {InputObjectDefaultValueHasCycle(inputObject, itemValue,
      visitedFields)}, return {true}.</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise, if {defaultValue} is an unordered map:<ul>
<li>For each field {field} in {inputObject}:<ul>
<li>If {InputFieldDefaultValueHasCycle(field, defaultValue, visitedFields)}, return {true}.</li>
</ul>
</li>
</ul>
</li>
<li>Return {false}.</li>
</ul>
<p>InputFieldDefaultValueHasCycle(field, defaultValue, visitedFields):</p>
<ul>
<li>Assert: {defaultValue} is an unordered map.</li>
<li>Let {fieldType} be the type of {field}.</li>
<li>Let {namedFieldType} be the underlying named type of {fieldType}.</li>
<li>If {namedFieldType} is not an input object type:<ul>
<li>Return {false}.</li>
</ul>
</li>
<li>Let {fieldName} be the name of {field}.</li>
<li>Let {fieldDefaultValue} be the value for {fieldName} in {defaultValue}.</li>
<li>If {fieldDefaultValue} exists:<ul>
<li>Return {InputObjectDefaultValueHasCycle(namedFieldType, fieldDefaultValue,
    visitedFields)}.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Let {fieldDefaultValue} be the default value of {field}.</li>
<li>If {fieldDefaultValue} does not exist:<ul>
<li>Return {false}.</li>
</ul>
</li>
<li>If {field} is within {visitedFields}:<ul>
<li>Return {true}.</li>
</ul>
</li>
<li>Let {nextVisitedFields} be a new set containing {field} and everything from {visitedFields}.</li>
<li>Return {InputObjectDefaultValueHasCycle(namedFieldType, fieldDefaultValue,
    nextVisitedFields)}.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md1120"></a>
OneOf Input Objects</h3>
<p>:: A <em>OneOf Input Object</em> is a special variant of <em>Input Object</em> where exactly one field must be set and non-null, all others being omitted. This is useful for representing situations where an input may be one of many different options.</p>
<p>When using the type system definition language, the `@oneOf` directive is used to indicate that an Input Object is a OneOf Input Object (and thus requires exactly one of its fields be provided):</p>
<div class="fragment"><div class="line">input UserUniqueCondition @oneOf {</div>
<div class="line">  id: ID</div>
<div class="line">  username: String</div>
<div class="line">  organizationAndEmail: OrganizationAndEmailInput</div>
<div class="line">}</div>
</div><!-- fragment --><p>In schema introspection, the <code>__Type.isOneOf</code> field will return {true} for OneOf Input Objects, and {false} for all other Input Objects.</p>
<p><b>Input Coercion</b></p>
<p>The value of a OneOf Input Object, as a variant of Input Object, must also be an input object literal or an unordered map supplied by a variable, otherwise a <em>request error</em> must be raised.</p>
<ul>
<li>Prior to construction of the coerced map via the input coercion rules of an <em>Input Object</em>: the value to be coerced must contain exactly one entry and that entry must not be {null} or the {null} literal, otherwise a <em>request error</em> must be raised.</li>
<li>All <em>Input Object</em> input coercion rules must also apply to a <em>OneOf Input Object</em>.</li>
<li>The resulting coerced map must contain exactly one entry and the value for that entry must not be {null}, otherwise an <em>execution error</em> must be raised.</li>
</ul>
<p>Following are additional examples of input coercion for a OneOf Input Object type with a <code>String</code> member field <code>a</code> and an <code>Int</code> member field <code>b</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input ExampleOneOfInputObject @oneOf {</div>
<div class="line">  a: String</div>
<div class="line">  b: Int</div>
<div class="line">}</div>
</div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Literal Value   </th><th class="markdownTableHeadNone">Variables   </th><th class="markdownTableHeadNone">Coerced Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: "abc" }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ a: "abc" }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{ b: 123 }</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: { a: "abc" } }</code>   </td><td class="markdownTableBodyNone"><code>{ a: "abc" }</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: null }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Value for member field {a} must be non-null    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: { a: null } }</code>   </td><td class="markdownTableBodyNone">Error: Value for member field {a} must be non-null    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: $a }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Value for member field {a} must be specified    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: 123 }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: 456, b: "xyz" }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: { a: "abc", b: 123 } }</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: null }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{ a: "abc", b: $b }</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>{ a: $a, b: $b }</code>   </td><td class="markdownTableBodyNone"><code>{ a: "abc" }</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone"><code>{}</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>$var</code>   </td><td class="markdownTableBodyNone"><code>{ var: {} }</code>   </td><td class="markdownTableBodyNone">Error: Exactly one key must be specified   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md1121"></a>
Input Object Extensions</h3>
<p>InputObjectTypeExtension :</p>
<ul>
<li>extend input Name Directives[Const]? InputFieldsDefinition</li>
<li>extend input Name Directives[Const] [lookahead != <code>{</code>]</li>
</ul>
<p>Input object type extensions are used to represent an input object type which has been extended from some previous input object type. For example, this might be used by a GraphQL service which is itself an extension of another GraphQL service.</p>
<p><b>Type Validation</b></p>
<p>Input object type extensions have the potential to be invalid if incorrectly defined.</p>
<ol type="1">
<li>The named type must already be defined and must be a Input Object type.</li>
<li>All fields of an Input Object type extension must have unique names.</li>
<li>All fields of an Input Object type extension must not already be a field of the previous Input Object.</li>
<li>Any non-repeatable directives provided must not already apply to the previous Input Object type.</li>
<li>The <code>@oneOf</code> directive must not be provided by an Input Object type extension.</li>
<li>If the original Input Object is a <em>OneOf Input Object</em> then:<ol type="a">
<li>All fields of the Input Object type extension must be nullable.</li>
<li>All fields of the Input Object type extension must not have default values.</li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1122"></a>
List</h2>
<p>A GraphQL list is a special collection type which declares the type of each item in the List (referred to as the <em>item type</em> of the list). List values are serialized as ordered lists, where each item in the list is serialized as per the item type.</p>
<p>To denote that a field uses a List type the item type is wrapped in square brackets like this: <code>pets: [Pet]</code>. Nesting lists is allowed: <code>matrix: [[Int]]</code>.</p>
<p><b>Result Coercion</b></p>
<p>GraphQL services must return an ordered list as the result of a list type. Each item in the list must be the result of a result coercion of the item type. If a reasonable coercion is not possible it must raise an <em>execution error</em>. In particular, if a non-list is returned, the coercion should fail, as this indicates a mismatch in expectations between the type system and the implementation.</p>
<p>If a list's item type is nullable, then errors occurring during preparation or coercion of an individual item in the list must result in the value {null} at that position in the list along with an <em>execution error</em> added to the response. If a list's item type is non-null, an execution error occurring at an individual item in the list must result in an execution error for the entire list.</p>
<p>Note: See Handling Execution Errors for more about this behavior.</p>
<p><b>Input Coercion</b></p>
<p>When expected as an input, list values are accepted only when each item in the list can be accepted by the list's item type.</p>
<p>If the value passed as an input to a list type is <em>not</em> a list and not the {null} value, then the result of input coercion is a list of size one, where the single item value is the result of input coercion for the list's item type on the provided value (note this may apply recursively for nested lists).</p>
<p>This allows inputs which accept one or many arguments (sometimes referred to as "var args") to declare their input type as a list while for the common case of a single value, a client can just pass that value directly rather than constructing the list.</p>
<p>Following are examples of input coercion with various list types and values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expected Type   </th><th class="markdownTableHeadNone">Provided Value   </th><th class="markdownTableHeadNone">Coerced Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>[1, "b", true]</code>   </td><td class="markdownTableBodyNone">Error: Incorrect item value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>1</code>   </td><td class="markdownTableBodyNone"><code>[1]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone"><code>null</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>[[1], [2, 3]]</code>   </td><td class="markdownTableBodyNone"><code>[[1], [2, 3]]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[[1], [2], [3]]</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>[1, null, 3]</code>   </td><td class="markdownTableBodyNone"><code>[[1], null, [3]]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>[[1], ["b"]]</code>   </td><td class="markdownTableBodyNone">Error: Incorrect item value    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>1</code>   </td><td class="markdownTableBodyNone"><code>[[1]]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[[Int]]</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1123"></a>
Non-Null</h2>
<p>By default, all types in GraphQL are nullable; the {null} value is a valid response for all of the above types. To declare a type that disallows null, the GraphQL Non-Null type can be used. This type wraps an underlying type, and this type acts identically to that wrapped type, with the exception that {null} is not a valid response for the wrapping type. A trailing exclamation mark is used to denote a field that uses a Non-Null type like this: <code>name: String!</code>.</p>
<p><b>Nullable vs. Optional</b></p>
<p>Fields are <em>always</em> optional within the context of a <em>selection set</em>, a field may be omitted and the selection set is still valid (so long as the selection set does not become empty). However fields that return Non-Null types will never return the value {null} if queried.</p>
<p>Inputs (such as field arguments), are always optional by default. However a non-null input type is required. In addition to not accepting the value {null}, it also does not accept omission. For the sake of simplicity nullable types are always optional and non-null types are always required.</p>
<p><b>Result Coercion</b></p>
<p>In all of the above result coercions, {null} was considered a valid value. To coerce the result of a Non-Null type, the coercion of the wrapped type should be performed. If that result was not {null}, then the result of coercing the Non-Null type is that result. If that result was {null}, then an <em>execution error</em> must be raised.</p>
<p>Note: When an <em>execution error</em> is raised on a non-null <em>response position</em>, the error propagates to the parent <em>response position</em>. For more information on this process, see Errors and Non-Null Types within the Execution section.</p>
<p><b>Input Coercion</b></p>
<p>If an argument or input-object field of a Non-Null type is not provided, is provided with the literal value {null}, or is provided with a variable that was either not provided a value at runtime, or was provided the value {null}, then a <em>request error</em> must be raised.</p>
<p>If the value provided to the Non-Null type is provided with a literal value other than {null}, or a Non-Null variable value, it is coerced using the input coercion for the wrapped type.</p>
<p>A non-null argument cannot be omitted:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  fieldWithNonNullArg</div>
<div class="line">}</div>
</div><!-- fragment --><p>The value {null} cannot be provided to a non-null argument:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  fieldWithNonNullArg(nonNullArg: null)</div>
<div class="line">}</div>
</div><!-- fragment --><p>A variable of a nullable type cannot be provided to a non-null argument:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query withNullableVariable($var: String) {</div>
<div class="line">  fieldWithNonNullArg(nonNullArg: $var)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: The Validation section defines providing a nullable variable type to a non-null input type as invalid.</p>
<p><b>Type Validation</b></p>
<ol type="1">
<li>A Non-Null type must not wrap another Non-Null type.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1124"></a>
Combining List and Non-Null</h3>
<p>The List and Non-Null wrapping types can compose, representing more complex types. The rules for result coercion and input coercion of Lists and Non-Null types apply in a recursive fashion.</p>
<p>For example if the inner item type of a List is Non-Null (e.g. <code>[T!]</code>), then that List may not contain any {null} items. However if the inner type of a Non-Null is a List (e.g. <code>[T]!</code>), then {null} is not accepted however an empty list is accepted.</p>
<p>Following are examples of result coercion with various types and values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expected Type   </th><th class="markdownTableHeadNone">Internal Value   </th><th class="markdownTableHeadNone">Coerced Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone"><code>null</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, Error]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code> (With logged error)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]!</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone">Error: Value cannot be null    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, Error]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code> (With logged error)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int!]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int!]</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone"><code>null</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int!]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>   </td><td class="markdownTableBodyNone"><code>null</code> (With logged coercion error)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int!]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, Error]</code>   </td><td class="markdownTableBodyNone"><code>null</code> (With logged error)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int!]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, 3]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int!]!</code>   </td><td class="markdownTableBodyNone"><code>null</code>   </td><td class="markdownTableBodyNone">Error: Value cannot be null    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>[Int!]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, null]</code>   </td><td class="markdownTableBodyNone">Error: Item cannot be null    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[Int!]!</code>   </td><td class="markdownTableBodyNone"><code>[1, 2, Error]</code>   </td><td class="markdownTableBodyNone">Error: Error occurred in item   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1125"></a>
Directives</h2>
<p>DirectiveDefinition : Description? directive @ Name ArgumentsDefinition? <code>repeatable</code>? on DirectiveLocations</p>
<p>DirectiveLocations :</p>
<ul>
<li>DirectiveLocations | DirectiveLocation</li>
<li><code>|</code>? DirectiveLocation</li>
</ul>
<p>DirectiveLocation :</p>
<ul>
<li>ExecutableDirectiveLocation</li>
<li>TypeSystemDirectiveLocation</li>
</ul>
<p>ExecutableDirectiveLocation : one of</p>
<ul>
<li><code>QUERY</code></li>
<li><code>MUTATION</code></li>
<li><code>SUBSCRIPTION</code></li>
<li><code>FIELD</code></li>
<li><code>FRAGMENT_DEFINITION</code></li>
<li><code>FRAGMENT_SPREAD</code></li>
<li><code>INLINE_FRAGMENT</code></li>
<li><code>VARIABLE_DEFINITION</code></li>
</ul>
<p>TypeSystemDirectiveLocation : one of</p>
<ul>
<li><code>SCHEMA</code></li>
<li><code>SCALAR</code></li>
<li><code>OBJECT</code></li>
<li><code>FIELD_DEFINITION</code></li>
<li><code>ARGUMENT_DEFINITION</code></li>
<li><code>INTERFACE</code></li>
<li><code>UNION</code></li>
<li><code>ENUM</code></li>
<li><code>ENUM_VALUE</code></li>
<li><code>INPUT_OBJECT</code></li>
<li><code>INPUT_FIELD_DEFINITION</code></li>
</ul>
<p>A GraphQL schema describes directives which are used to annotate various parts of a GraphQL document as an indicator that they should be evaluated differently by a validator, executor, or client tool such as a code generator.</p>
<p><b>Built-in Directives</b></p>
<p>:: A <em>built-in directive</em> is any directive defined within this specification.</p>
<p>GraphQL implementations should provide the <code>@skip</code> and <code>@include</code> directives.</p>
<p>GraphQL implementations that support the type system definition language must provide the <code>@deprecated</code> directive if representing deprecated portions of the schema.</p>
<p>GraphQL implementations that support the type system definition language should provide the <code>@specifiedBy</code> directive if representing custom scalar definitions.</p>
<p>GraphQL implementations that support the type system definition language should provide the <code>@oneOf</code> directive if representing OneOf Input Objects.</p>
<p>When representing a GraphQL schema using the type system definition language any <em>built-in directive</em> may be omitted for brevity.</p>
<p>When introspecting a GraphQL service all provided directives, including any <em>built-in directive</em>, must be included in the set of returned directives.</p>
<p><b>Custom Directives</b></p>
<p>:: GraphQL services and client tooling may provide any additional <em>custom directive</em> beyond those defined in this document. Directives are the preferred way to extend GraphQL with custom or experimental behavior.</p>
<p>Note: When defining a <em>custom directive</em>, it is recommended to prefix the directive's name to make its scope of usage clear and to prevent a collision with <em>built-in directive</em> which may be specified by future versions of this document (which will not include <code>_</code> in their name). For example, a <em>custom directive</em> used by Facebook's GraphQL service should be named <code>@fb_auth</code> instead of <code>@auth</code>. This is especially recommended for proposed additions to this specification which can change during the <a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md">RFC process</a>. For example a work in progress version of <code>@live</code> should be named <code>@rfc_live</code>.</p>
<p>Directives must only be used in the locations they are declared to belong in. In this example, a directive is defined which can be used to annotate a field:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">directive @example on FIELD</div>
<div class="line"> </div>
<div class="line">fragment SomeFragment on SomeType {</div>
<div class="line">  field @example</div>
<div class="line">}</div>
</div><!-- fragment --><p>Directive locations may be defined with an optional leading <code>|</code> character to aid formatting when representing a longer list of possible locations:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">directive @example on</div>
<div class="line">  | FIELD</div>
<div class="line">  | FRAGMENT_SPREAD</div>
<div class="line">  | INLINE_FRAGMENT</div>
</div><!-- fragment --><p>Directives can also be used to annotate the type system definition language as well, which can be a useful tool for supplying additional metadata in order to generate GraphQL execution services, produce client generated runtime code, or many other useful extensions of the GraphQL semantics.</p>
<p>In this example, the directive <code>@example</code> annotates field and argument definitions:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">directive @example on FIELD_DEFINITION | ARGUMENT_DEFINITION</div>
<div class="line"> </div>
<div class="line">type SomeType {</div>
<div class="line">  field(arg: Int @example): String @example</div>
<div class="line">}</div>
</div><!-- fragment --><p>A directive may be defined as repeatable by including the "repeatable" keyword. Repeatable directives are often useful when the same directive should be used with different arguments at a single location, especially in cases where additional information needs to be provided to a type or schema extension via a directive:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">directive @delegateField(name: String!) repeatable on OBJECT | INTERFACE</div>
<div class="line"> </div>
<div class="line">type Book @delegateField(name: &quot;pageCount&quot;) @delegateField(name: &quot;author&quot;) {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extend type Book @delegateField(name: &quot;index&quot;)</div>
</div><!-- fragment --><p>While defining a directive, it must not reference itself directly or indirectly:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">directive @invalidExample(arg: String @invalidExample) on ARGUMENT_DEFINITION</div>
</div><!-- fragment --><p>Note: The order in which directives appear may be significant, including repeatable directives.</p>
<p><b>Type Validation</b></p>
<ol type="1">
<li>A Directive definition must include at least one DirectiveLocation.</li>
<li>A Directive definition must not contain the use of a Directive which references itself directly.</li>
<li>A Directive definition must not contain the use of a Directive which references itself indirectly by referencing a Type or Directive which transitively includes a reference to this Directive.</li>
<li>The Directive must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>For each argument of the Directive:<ol type="a">
<li>The argument must not have a name which begins with the characters {"\_\_"} (two underscores).</li>
<li>The argument must have a unique name within that Directive; no two arguments may share the same name.</li>
<li>The argument must accept a type where {IsInputType(argumentType)} returns {true}.</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md1126"></a>
@skip</h3>
<div class="fragment"><div class="line">directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT</div>
</div><!-- fragment --><p>The <code>@skip</code> <em>built-in directive</em> may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the <code>if</code> argument.</p>
<p>In this example <code>experimentalField</code> will only be queried if the variable <code>$someTest</code> has the value <code>false</code>.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query myQuery($someTest: Boolean!) {</div>
<div class="line">  experimentalField @skip(if: $someTest)</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1127"></a>
autotoc_md1127</h3>
<div class="fragment"><div class="line">directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT</div>
</div><!-- fragment --><p>The <code>@include</code> <em>built-in directive</em> may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the <code>if</code> argument.</p>
<p>In this example <code>experimentalField</code> will only be queried if the variable <code>$someTest</code> has the value <code>true</code></p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query myQuery($someTest: Boolean!) {</div>
<div class="line">  experimentalField @include(if: $someTest)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: Neither <code>@skip</code> nor <code>@include</code> has precedence over the other. In the case that both the <code>@skip</code> and <code>@include</code> directives are provided on the same field or fragment, it <em>must</em> be queried only if the <code>@skip</code> condition is false <em>and</em> the <code>@include</code> condition is true. Stated conversely, the field or fragment must <em>not</em> be queried if either the <code>@skip</code> condition is true <em>or</em> the <code>@include</code> condition is false.</p>
<h3><a class="anchor" id="autotoc_md1128"></a>
autotoc_md1128</h3>
<dl class="deprecated"><dt><b><a class="el" href="../../da/d58/deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd></dd></dl>
<div class="fragment"><div class="line">directive @deprecated(</div>
<div class="line">  reason: String! = &quot;No longer supported&quot;</div>
<div class="line">) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE</div>
</div><!-- fragment --><p>The <code>@deprecated</code> <em>built-in directive</em> is used within the type system definition language to indicate deprecated portions of a GraphQL service's schema, such as deprecated fields on a type, arguments on a field, input fields on an input type, or values of an enum type.</p>
<p>Deprecations include a reason for why it is deprecated, which is formatted using Markdown syntax (as specified by <a href="https://commonmark.org/">CommonMark</a>).</p>
<p>In this example type definition, <code>oldField</code> is deprecated in favor of using <code>newField</code> and <code>oldArg</code> is deprecated in favor of using <code>newArg</code>.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type ExampleType {</div>
<div class="line">  newField: String</div>
<div class="line">  oldField: String @deprecated(reason: &quot;Use `newField`.&quot;)</div>
<div class="line"> </div>
<div class="line">  anotherField(</div>
<div class="line">    newArg: String</div>
<div class="line">    oldArg: String @deprecated(reason: &quot;Use `newArg`.&quot;)</div>
<div class="line">  ): String</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>@deprecated</code> directive must not appear on required (non-null without a default) arguments or input object field definitions.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">type ExampleType {</div>
<div class="line">  invalidField(</div>
<div class="line">    newArg: String</div>
<div class="line">    oldArg: String! @deprecated(reason: &quot;Use `newArg`.&quot;)</div>
<div class="line">  ): String</div>
<div class="line">}</div>
</div><!-- fragment --><p>To deprecate a required argument or input field, it must first be made optional by either changing the type to nullable or adding a default value.</p>
<h3><a class="anchor" id="autotoc_md1129"></a>
@specifiedBy</h3>
<div class="fragment"><div class="line">directive @specifiedBy(url: String!) on SCALAR</div>
</div><!-- fragment --><p>The <code>@specifiedBy</code> <em>built-in directive</em> is used within the type system definition language to provide a <em>scalar specification URL</em> for specifying the behavior of custom scalar types. The URL should point to a human-readable specification of the data format, serialization, and coercion rules. It must not appear on built-in scalar types.</p>
<p>Note: Details on implementing a GraphQL scalar specification can be found in the <a href="https://scalars.graphql.org/implementation-guide">scalars.graphql.org implementation guide</a>.</p>
<p>In this example, a custom scalar type for <code>UUID</code> is defined with a URL pointing to the relevant IETF specification.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">scalar UUID @specifiedBy(url: &quot;https://tools.ietf.org/html/rfc4122&quot;)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1130"></a>
@oneOf</h3>
<div class="fragment"><div class="line">directive @oneOf on INPUT_OBJECT</div>
</div><!-- fragment --><p>The <code>@oneOf</code> <em>built-in directive</em> is used within the type system definition language to indicate an <em>Input Object</em> is a <em>OneOf Input Object</em>.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">input UserUniqueCondition @oneOf {</div>
<div class="line">  id: ID</div>
<div class="line">  username: String</div>
<div class="line">  organizationAndEmail: OrganizationAndEmailInput</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
