#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: federation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/dca/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2federation.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">federation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
 <h2><a class="anchor" id="autotoc_md899"></a>
sidebarTitle: Federation</h2>
<p>import { Tabs } from 'nextra/components'</p>
<h1><a class="anchor" id="autotoc_md900"></a>
GraphQL federation</h1>
<p>An alternative design approach to the classical monolith, often described as microservices, emphasizes breaking down complex systems into smaller, independently managed components. In some ways, GraphQL federation is like microservices for GraphQL - an architectural pattern that has found particular resonance in the GraphQL ecosystem.</p>
<p>GraphQL federation gained widespread adoption after <a href="https://www.apollographql.com/blog/apollo-federation-f260cf525d21">Apollo GraphQL introduced Apollo Federation in 2019</a>. Their implementation has become a reference point for the GraphQL community, helping establish federation as a standard architectural pattern for building a distributed graph in the GraphQL ecosystem.</p>
<p>With more companies and developers seeing the benefits of building a distributed GraphQL schema with federation, the GraphQL ecosystem is now moving towards standardization of federation patterns. The GraphQL Foundation's <a href="https://github.com/graphql/composite-schemas-wg">Composite Schema Working Group</a>, which includes engineers from various organizations across the industry including <a href="https://apollographql.com">Apollo GraphQL</a>, <a href="https://chillicream.com/">ChilliCream</a>, <a href="https://www.graphile.org/">Graphile</a>, <a href="https://hasura.io/">Hasura</a>, <a href="https://www.netflix.com/">Netflix</a> and <a href="https://the-guild.dev">The Guild</a>, is actively working on creating <a href="https://github.com/graphql/composite-schemas-spec">an official specification for GraphQL Federation</a>. This effort aims to standardize how GraphQL services can be composed and executed across distributed systems, while ensuring room for innovation and different implementations.</p>
<h2><a class="anchor" id="autotoc_md901"></a>
What is federation?</h2>
<p>Architecturally, federation is an approach to organizing and managing distributed systems. At its core, federation allows autonomous components to work together while maintaining their independence. Think of it like a federal government system: individual states maintain their sovereignty while cooperating under a central authority for shared concerns.</p>
<p>In software architecture, federation enables organizations to:</p>
<ul>
<li>Distribute responsibility across independent teams</li>
<li>Scale different components independently</li>
<li>Maintain clear boundaries between different domains</li>
<li>Enable autonomous development and deployment</li>
<li>Reduce single points of failure</li>
</ul>
<p>Think of the "Login with Google" or "Login with Facebook" buttons you see on websites. This is federation in action: you can use your Google or Facebook account to log into many different websites, even though each company manages their own login system separately.</p>
<h2><a class="anchor" id="autotoc_md902"></a>
What is federated GraphQL?</h2>
<p>GraphQL federation applies those principles to GraphQL APIs. It enables organizations to build a unified GraphQL schema from multiple independent services (most often called subgraphs), each responsible for its portion of the application's data graph.</p>
<p>Consider an e-commerce platform: You might have separate teams managing products, user accounts, and order processing. With GraphQL federation, each team can:</p>
<ul>
<li>Define their own GraphQL schema</li>
<li>Deploy and scale their service independently</li>
<li>Contribute to a unified GraphQL API without tight coupling</li>
<li>Maintain ownership of their domain-specific logic</li>
</ul>
<p>The magic happens through a federated gateway that acts as the central coordinator, composing these separate schemas into a unified schema that clients can query.</p>
<h2><a class="anchor" id="autotoc_md903"></a>
How federation works in GraphQL</h2>
<p>The federation process involves several key components:</p>
<ul>
<li><b>Subgraphs</b>: Individual services that define their own GraphQL schemas and resolvers</li>
<li><b>Gateway</b>: A specialized service that sits between clients and your federated services</li>
<li><b>Schema composition</b>: The process of merging schemas while resolving references between them, often handled by schema registries.</li>
</ul>
<p>&lt;Tabs items={['Products subgraph', 'Orders subgraph', 'Users subgraph']}&gt; &lt;Tabs.Tab&gt;</p>
<div class="fragment"><div class="line">type Product @key(fields: &quot;id&quot;) {</div>
<div class="line">  id: ID!</div>
<div class="line">  title: String!</div>
<div class="line">  price: Float!</div>
<div class="line">  inStock: Boolean!</div>
<div class="line">}</div>
</div><!-- fragment --><p>&lt;/Tabs.Tab&gt; &lt;Tabs.Tab&gt;</p>
<div class="fragment"><div class="line">type Order @key(fields: &quot;id&quot;) {</div>
<div class="line">  id: ID!</div>
<div class="line">  products: [Product!]!</div>
<div class="line">  total: Float!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Product {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
</div><!-- fragment --><p>&lt;/Tabs.Tab&gt; &lt;Tabs.Tab&gt;</p>
<div class="fragment"><div class="line">type Query {</div>
<div class="line">  user(id: ID!): User</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type User {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  email: String</div>
<div class="line">  orders: [Order!]!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Order {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
</div><!-- fragment --><p>&lt;/Tabs.Tab&gt; &lt;/Tabs&gt;</p>
<h3><a class="anchor" id="autotoc_md904"></a>
Schema composition</h3>
<p>Let's break down schema composition in GraphQL federation with more detail and examples. Schema composition is the process where multiple subgraph schemas are combined into one unified schema. It's more complex than simply merging schemas together, though, because it needs to handle relationships, detect incompatibilities, and ensure types are properly connected across services and subgraphs.</p>
<p>Based on the examples we provided before, here's the unified schema GraphQL clients will see and can query:</p>
<div class="fragment"><div class="line">type Query {</div>
<div class="line">  user(id: ID!): User</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type User {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  email: String</div>
<div class="line">  orders: [Order!]!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Order {</div>
<div class="line">  id: ID!</div>
<div class="line">  products: [Product!]!</div>
<div class="line">  total: Float!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Product {</div>
<div class="line">  id: ID!</div>
<div class="line">  title: String!</div>
<div class="line">  price: Float!</div>
<div class="line">  inStock: Boolean!</div>
<div class="line">}</div>
</div><!-- fragment --><p>This unified schema combines types and fields from all three subgraphs (Users, Orders, and Products), allowing clients to seamlessly query across these domains.</p>
<h3><a class="anchor" id="autotoc_md905"></a>
Gateway</h3>
<p>The federation gateway is the entry point to your distributed data graph. It presents a unified GraphQL endpoint to clients and handles the complexity of routing queries to the appropriate subgraphs and assembling the results, and often provides caching and performance optimizations.</p>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">  Client --&gt; FederationGateway</div>
<div class="line">  FederationGateway --&gt; UsersService</div>
<div class="line">  FederationGateway --&gt; OrdersService</div>
<div class="line">  FederationGateway --&gt; ProductsService</div>
<div class="line"> </div>
<div class="line">  Client[Client]</div>
<div class="line">  FederationGateway[Gateway]</div>
<div class="line">  UsersService[Users Service]</div>
<div class="line">  OrdersService[Orders Service]</div>
<div class="line">  ProductsService[Products Service]</div>
</div><!-- fragment --><p>Take the following query as an example:</p>
<div class="fragment"><div class="line">query {</div>
<div class="line">  user(id: &quot;123&quot;) {</div>
<div class="line">    # Resolved by Users subgraph</div>
<div class="line">    name</div>
<div class="line">    orders {</div>
<div class="line">      # Resolved by Orders subgraph</div>
<div class="line">      id</div>
<div class="line">      products {</div>
<div class="line">        # Resolved by Products subgraph</div>
<div class="line">        title</div>
<div class="line">        price</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The gateway will route parts of the query to the appropriate subgraphs, collect the results, and assemble them into a single response that the client can consume.</p>
<h2><a class="anchor" id="autotoc_md906"></a>
Benefits of GraphQL federation</h2>
<h3><a class="anchor" id="autotoc_md907"></a>
Domain-driven development</h3>
<p>Teams can work independently on their services while contributing to a cohesive API. This autonomy accelerates development and reduces coordination overhead.</p>
<h3><a class="anchor" id="autotoc_md908"></a>
Service integrity protection</h3>
<p>The schema composition step verifies integration between services by ensuring that changes in individual subgraphs do not conflict with other subgraphs.</p>
<h3><a class="anchor" id="autotoc_md909"></a>
Scalability and performance</h3>
<p>Subgraphs and services can be scaled independently based on their specific requirements. The product catalog might need different scaling characteristics than the order processing system.</p>
<h3><a class="anchor" id="autotoc_md910"></a>
Single, unified API</h3>
<p>Thanks to GraphQL, clients get a single endpoint with unified schema spanning multiple subgraphs. The complexity of distributed systems is hidden. The gateway ensures every query reaches its destination and returns with the right data.</p>
<h2><a class="anchor" id="autotoc_md911"></a>
Is GraphQL federation right for you?</h2>
<p>GraphQL federation aligns naturally with Domain Driven Design (DDD) principles by allowing teams to maintain clear boundaries around their domains, while maintaining explicit integration points through the GraphQL schema. It is particularly valuable for organizations where multiple teams need to work independently on different parts of the GraphQL API, with the flexibility to use different technologies and programming languages.</p>
<p>However, implementing federation requires substantial infrastructure support, including a dedicated team to manage the gateway, schema registry, to help connect subgraphs to the federated API and guide teams on best practices.</p>
<p>Before adopting federation, it's crucial to consider whether your organization truly needs this level of complexity. You can start with a monolithic setup and transition to federation as your needs evolve, rather than implementing it prematurely.</p>
<p>Meta (formerly Facebook), <a href="../..//blog/2015-09-14-graphql/">where GraphQL was created</a>, has continued to use a monolithic GraphQL API since 2012. However, companies like <a href="https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2">Netflix</a>, <a href="https://youtu.be/kpeVT7J6Bsw?si=srGWsoxf3kTmneTu&amp;t=79">Expedia Group</a>, <a href="https://www.apollographql.com/blog/volvo-cars-drives-into-the-future-of-online-car-shopping-with-the-supergraph">Volvo</a>, and <a href="https://youtu.be/2KsP_x50tGk?si=mu-MOG-xZQSDNDjh&amp;t=478">Booking</a> have adopted federation to better align with their organizational structures and microservices architecture.</p>
<p>As you see, some of the world's largest industry leaders have successfully federated their GraphQL APIs, proving that it works reliably for production applications at an extraordinary scale.</p>
<h2><a class="anchor" id="autotoc_md912"></a>
Getting started with GraphQL federation</h2>
<p>If you're considering adopting GraphQL federation, here are some steps to get started:</p>
<ol type="1">
<li><b>Identify Service Boundaries</b>: Define clear boundaries between different domains in your application</li>
<li><a href="../..//learn/schema/" title="Learn about the different elements of the GraphQL type system"><b>Design Schemas</b></a>: Create schemas that reflect these boundaries while considering how they'll interact</li>
<li><a href="../..//community/tools-and-libraries/?tags=server" title="Discover a list of GraphQL servers in our Tools and Libraries page"><b>Implement Subgraphs</b></a>: Build individual services that implement their portion of the schema</li>
<li><a href="../..//community/tools-and-libraries/?tags=gateways-supergraphs" title="Discover a list of GraphQL gateways in our Tools and Libraries page"><b>Set Up a Gateway</b></a>: Deploy a federation gateway to compose and serve the unified schema</li>
<li><a href="../..//community/tools-and-libraries/?tags=schema-registry" title="Discover a list of GraphQL schema registries in our Tools and Libraries page"><b>Use a Schema Registry</b></a>: Manage schema composition and validation to ensure integrity across subgraphs</li>
</ol>
<p>When migrating from a monolithic to federated GraphQL API, the simplest starting point is to treat your existing schema as your first subgraph. From there, you can follow the steps above to gradually decompose your schema into smaller pieces. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
