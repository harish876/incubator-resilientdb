#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: Section 2 &ndash; Language</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d51/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-spec_2Section_012_01--_01Language.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Section 2 &ndash; Language</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1059"></a>
Language</h1>
<p>Clients use the GraphQL query language to make requests to a GraphQL service. We refer to these <em>request</em> sources as documents. A document may contain operations (queries, mutations, and subscriptions) as well as fragments, a common unit of composition allowing for data requirement reuse.</p>
<p>A GraphQL document is defined as a syntactic grammar where terminal symbols are tokens (indivisible lexical units). These tokens are defined in a lexical grammar which matches patterns of source characters. In this document, syntactic grammar productions are distinguished with a colon <code>:</code> while lexical grammar productions are distinguished with a double-colon <code>::</code>.</p>
<p>The source text of a GraphQL document must be a sequence of {SourceCharacter}. The character sequence must be described by a sequence of {Token} and {Ignored} lexical grammars. The lexical token sequence, omitting {Ignored}, must be described by a single {Document} syntactic grammar.</p>
<p>Note: See Appendix A for more information about the lexical and syntactic grammar and other notational conventions used throughout this document.</p>
<p><b>Lexical Analysis &amp; Syntactic Parse</b></p>
<p>The source text of a GraphQL document is first converted into a sequence of lexical tokens ({Token}) and ignored tokens ({Ignored}). The source text is scanned from left to right, repeatedly taking the next possible sequence of code points allowed by the lexical grammar productions as the next token. This sequence of lexical tokens is then scanned from left to right to produce an abstract syntax tree (AST) according to the {Document} syntactic grammar.</p>
<p>Lexical grammar productions in this document use <em>lookahead restrictions</em> to remove ambiguity and ensure a single valid lexical analysis. A lexical token is only valid if not followed by a character in its lookahead restriction.</p>
<p>For example, an {IntValue} has the restriction {[lookahead != Digit]}, so cannot be followed by a {Digit}. Because of this, the sequence {<code>123</code>} cannot represent the tokens ({<code>12</code>}, {<code>3</code>}) since {<code>12</code>} is followed by the {Digit} {<code>3</code>} and so must only represent a single token. Use {Whitespace} or other {Ignored} between characters to represent multiple tokens.</p>
<p>Note: This typically has the same behavior as a "[maximal munch](https://en.wikipedia.org/wiki/Maximal_munch)" longest possible match, however some lookahead restrictions include additional constraints.</p>
<h2><a class="anchor" id="autotoc_md1060"></a>
Source Text</h2>
<p>SourceCharacter :: "Any Unicode scalar value"</p>
<p>GraphQL documents are interpreted from a source text, which is a sequence of {SourceCharacter}, each {SourceCharacter} being a <em>Unicode scalar value</em> which may be any Unicode code point from U+0000 to U+D7FF or U+E000 to U+10FFFF (informally referred to as <em>"characters"</em> through most of this specification).</p>
<p>A GraphQL document may be expressed only in the ASCII range to be as widely compatible with as many existing tools, languages, and serialization formats as possible and avoid display issues in text editors and source control. Non-ASCII Unicode scalar values may appear within {StringValue} and {Comment}.</p>
<p>Note: An implementation which uses <em>UTF-16</em> to represent GraphQL documents in memory (for example, JavaScript or Java) may encounter a <em>surrogate pair</em>. This encodes one <em>supplementary code point</em> and is a single valid source character, however an unpaired <em>surrogate code point</em> is not a valid source character.</p>
<h3><a class="anchor" id="autotoc_md1061"></a>
White Space</h3>
<p>Whitespace ::</p>
<ul>
<li>"Horizontal Tab (U+0009)"</li>
<li>"Space (U+0020)"</li>
</ul>
<p>Whitespace is used to improve legibility of source text and separates other tokens. Any amount of whitespace may appear before or after any token. Whitespace between tokens is not significant to the semantic meaning of a GraphQL document, however whitespace characters may appear within a {String} or {Comment} token.</p>
<p>Note: GraphQL intentionally does not consider Unicode "Zs" category characters as whitespace, avoiding misinterpretation by text editors and source control tools.</p>
<h3><a class="anchor" id="autotoc_md1062"></a>
Line Terminators</h3>
<p>LineTerminator ::</p>
<ul>
<li>"New Line (U+000A)"</li>
<li>"Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]</li>
<li>"Carriage Return (U+000D)" "New Line (U+000A)"</li>
</ul>
<p>Like whitespace, line terminators are used to improve the legibility of source text and separate lexical tokens, any amount may appear before or after any other token and have no significance to the semantic meaning of a GraphQL Document.</p>
<p>Note: Any error reporting which provides the line number in the source of the offending syntax should use the preceding amount of {LineTerminator} to produce the line number.</p>
<h3><a class="anchor" id="autotoc_md1063"></a>
Comments</h3>
<p>Comment :: <code>#</code> CommentChar* [lookahead != CommentChar]</p>
<p>CommentChar :: SourceCharacter but not LineTerminator</p>
<p>GraphQL source documents may contain single-line comments, starting with the {<code>#</code>} marker.</p>
<p>A comment may contain any {SourceCharacter} except {LineTerminator} so a comment always consists of all {SourceCharacter} starting with the {<code>#</code>} character up to but not including the {LineTerminator} (or end of the source).</p>
<p>Comments are {Ignored} like whitespace and may appear after any token, or before a {LineTerminator}, and have no significance to the semantic meaning of a GraphQL document.</p>
<h3><a class="anchor" id="autotoc_md1064"></a>
Insignificant Commas</h3>
<p>Comma :: ,</p>
<p>Similar to whitespace and line terminators, commas ({<code>,</code>}) are used to improve the legibility of source text and separate lexical tokens but are otherwise syntactically and semantically insignificant within GraphQL documents.</p>
<p>Non-significant comma characters ensure that the absence or presence of a comma does not meaningfully alter the interpreted syntax of the document, as this can be a common user error in other languages. It also allows for the stylistic use of either trailing commas or line terminators as list delimiters which are both often desired for legibility and maintainability of source code.</p>
<h3><a class="anchor" id="autotoc_md1065"></a>
Lexical Tokens</h3>
<p>Token ::</p>
<ul>
<li>Punctuator</li>
<li>Name</li>
<li>IntValue</li>
<li>FloatValue</li>
<li>StringValue</li>
</ul>
<p>A GraphQL document is composed of several kinds of indivisible lexical tokens defined here in a lexical grammar by patterns of source Unicode characters. Lexical tokens may be separated by {Ignored} tokens.</p>
<p>Tokens are later used as terminal symbols in GraphQL syntactic grammar rules.</p>
<h3><a class="anchor" id="autotoc_md1066"></a>
Ignored Tokens</h3>
<p>Ignored ::</p>
<ul>
<li>UnicodeBOM</li>
<li>Whitespace</li>
<li>LineTerminator</li>
<li>Comment</li>
<li>Comma</li>
</ul>
<p>{Ignored} tokens are used to improve readability and provide separation between lexical tokens, but are otherwise insignificant and not referenced in syntactic grammar productions.</p>
<p>Any amount of {Ignored} may appear before and after every lexical token. No ignored regions of a source document are significant, however {SourceCharacter} which appear in {Ignored} may also appear within a lexical {Token} in a significant way, for example a {StringValue} may contain whitespace characters. No {Ignored} may appear <em>within</em> a {Token}, for example no whitespace characters are permitted between the characters defining a {FloatValue}.</p>
<p><b>Byte Order Mark</b></p>
<p>UnicodeBOM :: "Byte Order Mark (U+FEFF)"</p>
<p>The <em>Byte Order Mark</em> is a special Unicode code point which may appear at the beginning of a file which programs may use to determine the fact that the text stream is Unicode, and what specific encoding has been used. As files are often concatenated, a <em>Byte Order Mark</em> may appear before or after any lexical token and is {Ignored}.</p>
<h3><a class="anchor" id="autotoc_md1067"></a>
Punctuators</h3>
<p>Punctuator :: one of ! $ &amp; ( ) ... : = @ [ ] { | }</p>
<p>GraphQL documents include punctuation in order to describe structure. GraphQL is a data description language and not a programming language; therefore, GraphQL lacks the punctuation often used to describe mathematical expressions.</p>
<h3><a class="anchor" id="autotoc_md1068"></a>
Names</h3>
<p>Name ::</p>
<ul>
<li>NameStart NameContinue* [lookahead != NameContinue]</li>
</ul>
<p>NameStart ::</p>
<ul>
<li>Letter</li>
<li><code>_</code></li>
</ul>
<p>NameContinue ::</p>
<ul>
<li>Letter</li>
<li>Digit</li>
<li><code>_</code></li>
</ul>
<p>Letter :: one of</p>
<ul>
<li><code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> <code>K</code> <code>L</code> <code>M</code></li>
<li><code>N</code> <code>O</code> <code>P</code> <code>Q</code> <code>R</code> <code>S</code> <code>T</code> <code>U</code> <code>V</code> <code>W</code> <code>X</code> <code>Y</code> <code>Z</code></li>
<li><code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>g</code> <code>h</code> <code>i</code> <code>j</code> <code>k</code> <code>l</code> <code>m</code></li>
<li><code>n</code> <code>o</code> <code>p</code> <code>q</code> <code>r</code> <code>s</code> <code>t</code> <code>u</code> <code>v</code> <code>w</code> <code>x</code> <code>y</code> <code>z</code></li>
</ul>
<p>Digit :: one of</p>
<ul>
<li><code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code></li>
</ul>
<p>GraphQL documents are full of named things: operations, fields, arguments, types, directives, fragments, and variables. All names must follow the same grammatical form.</p>
<p>Names in GraphQL are case-sensitive. That is to say <code>name</code>, <code>Name</code>, and <code>NAME</code> all refer to different names. Underscores are significant, which means <code>other_name</code> and <code>othername</code> are two different names.</p>
<p>A {Name} must not be followed by a {NameContinue}. In other words, a {Name} token is always the longest possible valid sequence. The source characters {<code>a1</code>} cannot be interpreted as two tokens since {<code>a</code>} is followed by the {NameContinue} {<code>1</code>}.</p>
<p>Note: Names in GraphQL are limited to the Latin &lt;acronym&gt;ASCII&lt;/acronym&gt; subset of {SourceCharacter} in order to support interoperation with as many other systems as possible.</p>
<p><b>Reserved Names</b></p>
<p>Any {Name} within a GraphQL type system must not start with two underscores {"\_\_"} unless it is part of the introspection system as defined by this specification.</p>
<h2><a class="anchor" id="autotoc_md1069"></a>
Descriptions</h2>
<p>Description : StringValue</p>
<p>Documentation is a first-class feature of GraphQL by including written descriptions on all named definitions in executable {Document} and GraphQL type systems, which is also made available via introspection ensuring the documentation of a GraphQL service remains consistent with its capabilities (see Type System Descriptions).</p>
<p>GraphQL descriptions are provided as Markdown (as specified by <a href="https://commonmark.org/">CommonMark</a>). Description strings (often {BlockString}) occur immediately before the definition they describe.</p>
<p>Descriptions in GraphQL executable documents are purely for documentation purposes. They MUST NOT affect the execution, validation, or response of a GraphQL document. It is safe to remove all descriptions and comments from executable documents without changing their behavior or results.</p>
<p>This is an example of a well-described operation:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">Request the current status of a time machine and its operator.</div>
<div class="line">You can also check the status for a particular year.</div>
<div class="line">**Warning:** certain years may trigger an anomaly in the space-time continuum.</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">query GetTimeMachineStatus(</div>
<div class="line">  &quot;The unique serial number of the time machine to inspect.&quot;</div>
<div class="line">  $machineId: ID!</div>
<div class="line">  &quot;The year to check the status for.&quot;</div>
<div class="line">  $year: Int</div>
<div class="line">) {</div>
<div class="line">  timeMachine(id: $machineId) {</div>
<div class="line">    ...TimeMachineDetails</div>
<div class="line">    status(year: $year)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;Details about a time machine and its operator.&quot;</div>
<div class="line">fragment TimeMachineDetails on TimeMachine {</div>
<div class="line">  id</div>
<div class="line">  model</div>
<div class="line">  lastMaintenance</div>
<div class="line">  operator {</div>
<div class="line">    name</div>
<div class="line">    licenseLevel</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1070"></a>
Document</h2>
<p>Document : Definition+</p>
<p>Definition :</p>
<ul>
<li>ExecutableDefinition</li>
<li>TypeSystemDefinitionOrExtension</li>
</ul>
<p>ExecutableDocument : ExecutableDefinition+</p>
<p>ExecutableDefinition :</p>
<ul>
<li>OperationDefinition</li>
<li>FragmentDefinition</li>
</ul>
<p>A GraphQL document describes a complete file or request string operated on by a GraphQL service or client. A document contains multiple definitions, either executable or representative of a GraphQL type system.</p>
<p>Documents are only executable by a GraphQL service if they are {ExecutableDocument} and contain at least one {OperationDefinition}. A Document which contains {TypeSystemDefinitionOrExtension} must not be executed; GraphQL execution services which receive a Document containing these should return a descriptive error.</p>
<p>GraphQL services which only seek to execute GraphQL requests and not construct a new GraphQL schema may choose to only permit {ExecutableDocument}.</p>
<p>Documents which do not contain {OperationDefinition} or do contain {TypeSystemDefinitionOrExtension} may still be parsed and validated to allow client tools to represent many GraphQL uses which may appear across many individual files.</p>
<p>If a Document contains only one operation, that operation may be unnamed. If that operation is a query without variables or directives then it may also be represented in the shorthand form, omitting both the {<code>query</code>} keyword as well as the operation name. Otherwise, if a GraphQL document contains multiple operations, each operation must be named. When submitting a Document with multiple operations to a GraphQL service, the name of the desired operation to be executed must also be provided.</p>
<h2><a class="anchor" id="autotoc_md1071"></a>
Operations</h2>
<p>OperationDefinition :</p>
<ul>
<li>Description? OperationType Name? VariablesDefinition? Directives? SelectionSet</li>
<li>SelectionSet</li>
</ul>
<p>OperationType : one of <code>query</code> <code>mutation</code> <code>subscription</code></p>
<p>There are three types of operations that GraphQL models:</p>
<ul>
<li>query - a read-only fetch.</li>
<li>mutation - a write followed by a fetch.</li>
<li>subscription - a long-lived request that fetches data in response to a sequence of events over time.</li>
</ul>
<p>Each operation is represented by an optional operation name and a <em>selection set</em>.</p>
<p>For example, this mutation operation might "like" a story and then retrieve the new number of likes:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">Mark story 12345 as &quot;liked&quot;</div>
<div class="line">and return the updated number of likes on the story</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">mutation {</div>
<div class="line">  likeStory(storyID: 12345) {</div>
<div class="line">    story {</div>
<div class="line">      likeCount</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Query Shorthand</b></p>
<p>If a document contains only one operation and that operation is a query which defines no variables and has no directives applied to it then that operation may be represented in a shorthand form which omits the {<code>query</code>} keyword and operation name.</p>
<p>For example, this unnamed query operation is written via query shorthand.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  field</div>
<div class="line">}</div>
</div><!-- fragment --><p>Descriptions are not permitted on query shorthand.</p>
<p>Note: many examples below will use the query shorthand syntax.</p>
<h2><a class="anchor" id="autotoc_md1072"></a>
Selection Sets</h2>
<p>SelectionSet : { Selection+ }</p>
<p>Selection :</p>
<ul>
<li>Field</li>
<li>FragmentSpread</li>
<li>InlineFragment</li>
</ul>
<p>An operation selects the set of information it needs, and will receive exactly that information and nothing more, avoiding over-fetching and under-fetching data.</p>
<p>:: A <em>selection set</em> defines an ordered set of selections (fields, fragment spreads and inline fragments) against an object, union or interface type.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  id</div>
<div class="line">  firstName</div>
<div class="line">  lastName</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this query operation, the <code>id</code>, <code>firstName</code>, and <code>lastName</code> fields form a <em>selection set</em>. Selection sets may also contain fragment references.</p>
<h2><a class="anchor" id="autotoc_md1073"></a>
Fields</h2>
<p>Field : Alias? Name Arguments? Directives? SelectionSet?</p>
<p>A <em>selection set</em> is primarily composed of fields. A field describes one discrete piece of information available to request within a selection set.</p>
<p>Some fields describe complex data or relationships to other data. In order to further explore this data, a field may itself contain a selection set, allowing for deeply nested requests. All GraphQL operations must specify their selections down to fields which return scalar values to ensure an unambiguously shaped response.</p>
<p>For example, this operation selects fields of complex data and relationships down to scalar values.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  me {</div>
<div class="line">    id</div>
<div class="line">    firstName</div>
<div class="line">    lastName</div>
<div class="line">    birthday {</div>
<div class="line">      month</div>
<div class="line">      day</div>
<div class="line">    }</div>
<div class="line">    friends {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Fields in the top-level <em>selection set</em> of an operation often represent some information that is globally accessible to your application and its current viewer. Some typical examples of these top fields include references to a current logged-in viewer, or accessing certain types of data referenced by a unique identifier.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line"># `me` could represent the currently logged in viewer.</div>
<div class="line">{</div>
<div class="line">  me {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"># `user` represents one of many users in a graph of data, referred to by a</div>
<div class="line"># unique identifier.</div>
<div class="line">{</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1074"></a>
Arguments</h2>
<p>Arguments[Const] : ( Argument[?Const]+ )</p>
<p>Argument[Const] : Name : Value[?Const]</p>
<p>Fields are conceptually functions which return values, and occasionally accept arguments which alter their behavior. These arguments often map directly to function arguments within a GraphQL service's implementation.</p>
<p>In this example, we want to query a specific user (requested via the <code>id</code> argument) and their profile picture of a specific <code>size</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">    profilePic(size: 100)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Many arguments can exist for a given field:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">    profilePic(width: 100, height: 50)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Arguments Are Unordered</b></p>
<p>Arguments may be provided in any syntactic order and maintain identical semantic meaning.</p>
<p>These two operations are semantically identical:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  picture(width: 200, height: 100)</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  picture(height: 100, width: 200)</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1075"></a>
Field Alias</h2>
<p>Alias : Name :</p>
<p>:: A <em>response name</em> is the key in the response object which correlates with a field's result. By default the response name will use the field's name; however, you can define a different response name by specifying an alias.</p>
<p>In this example, we can fetch two profile pictures of different sizes and ensure the resulting response object will not have duplicate keys:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">    smallPic: profilePic(size: 64)</div>
<div class="line">    bigPic: profilePic(size: 1024)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>which returns the result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;user&quot;: {</div>
<div class="line">    &quot;id&quot;: 4,</div>
<div class="line">    &quot;name&quot;: &quot;Mark Zuckerberg&quot;,</div>
<div class="line">    &quot;smallPic&quot;: &quot;https://cdn.site.io/pic-4-64.jpg&quot;,</div>
<div class="line">    &quot;bigPic&quot;: &quot;https://cdn.site.io/pic-4-1024.jpg&quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The fields at the top level of an operation can also be given an alias:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  zuck: user(id: 4) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>which returns the result:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;zuck&quot;: {</div>
<div class="line">    &quot;id&quot;: 4,</div>
<div class="line">    &quot;name&quot;: &quot;Mark Zuckerberg&quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1076"></a>
Fragments</h2>
<p>FragmentSpread : ... FragmentName Directives?</p>
<p>FragmentDefinition : Description? fragment FragmentName TypeCondition Directives? SelectionSet</p>
<p>FragmentName : Name but not <code>on</code></p>
<p>Fragments are the primary unit of composition in GraphQL.</p>
<p>Fragments allow for the reuse of common repeated selections of fields, reducing duplicated text in the document. Inline Fragments can be used directly within a selection to condition upon a type condition when querying against an interface or union.</p>
<p>For example, if we wanted to fetch some common information about mutual friends as well as friends of some user:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query noFragments {</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    friends(first: 10) {</div>
<div class="line">      id</div>
<div class="line">      name</div>
<div class="line">      profilePic(size: 50)</div>
<div class="line">    }</div>
<div class="line">    mutualFriends(first: 10) {</div>
<div class="line">      id</div>
<div class="line">      name</div>
<div class="line">      profilePic(size: 50)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The repeated fields could be extracted into a fragment and composed by a parent fragment or operation.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query withFragments {</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    friends(first: 10) {</div>
<div class="line">      ...friendFields</div>
<div class="line">    }</div>
<div class="line">    mutualFriends(first: 10) {</div>
<div class="line">      ...friendFields</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;Common fields for a user&#39;s friends.&quot;</div>
<div class="line">fragment friendFields on User {</div>
<div class="line">  id</div>
<div class="line">  name</div>
<div class="line">  profilePic(size: 50)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Fragments are consumed by using the spread operator (<code>...</code>). All fields selected by the fragment will be added to the field selection at the same level as the fragment invocation. This happens through multiple levels of fragment spreads.</p>
<p>For example:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query withNestedFragments {</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    friends(first: 10) {</div>
<div class="line">      ...friendFields</div>
<div class="line">    }</div>
<div class="line">    mutualFriends(first: 10) {</div>
<div class="line">      ...friendFields</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment friendFields on User {</div>
<div class="line">  id</div>
<div class="line">  name</div>
<div class="line">  ...standardProfilePic</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment standardProfilePic on User {</div>
<div class="line">  profilePic(size: 50)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The operations <code>noFragments</code>, <code>withFragments</code>, and <code>withNestedFragments</code> all produce the same response object.</p>
<h3><a class="anchor" id="autotoc_md1077"></a>
Type Conditions</h3>
<p>TypeCondition : on NamedType</p>
<p>Fragments must specify the type they apply to. In this example, <code>friendFields</code> can be used in the context of querying a <code>User</code>.</p>
<p>Fragments cannot be specified on any input value (scalar, enumeration, or input object).</p>
<p>Fragments can be specified on object types, interfaces, and unions.</p>
<p>Selections within fragments only return values when the concrete type of the object it is operating on matches the type of the fragment.</p>
<p>For example in this operation using the Facebook data model:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query FragmentTyping {</div>
<div class="line">  profiles(handles: [&quot;zuck&quot;, &quot;coca-cola&quot;]) {</div>
<div class="line">    handle</div>
<div class="line">    ...userFragment</div>
<div class="line">    ...pageFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment userFragment on User {</div>
<div class="line">  friends {</div>
<div class="line">    count</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment pageFragment on Page {</div>
<div class="line">  likers {</div>
<div class="line">    count</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>profiles</code> root field returns a list where each element could be a <code>Page</code> or a <code>User</code>. When the object in the <code>profiles</code> result is a <code>User</code>, <code>friends</code> will be present and <code>likers</code> will not. Conversely when the result is a <code>Page</code>, <code>likers</code> will be present and <code>friends</code> will not.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;profiles&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;handle&quot;: &quot;zuck&quot;,</div>
<div class="line">      &quot;friends&quot;: { &quot;count&quot;: 1234 }</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      &quot;handle&quot;: &quot;coca-cola&quot;,</div>
<div class="line">      &quot;likers&quot;: { &quot;count&quot;: 90234512 }</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1078"></a>
Inline Fragments</h3>
<p>InlineFragment : ... TypeCondition? Directives? SelectionSet</p>
<p>Fragments can also be defined inline within a <em>selection set</em>. This is useful for conditionally including fields based on a type condition or applying a directive to a selection set.</p>
<p>This feature of standard fragment inclusion was demonstrated in the <code>query FragmentTyping</code> example above. We could accomplish the same thing using inline fragments.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query inlineFragmentTyping {</div>
<div class="line">  profiles(handles: [&quot;zuck&quot;, &quot;coca-cola&quot;]) {</div>
<div class="line">    handle</div>
<div class="line">    ... on User {</div>
<div class="line">      friends {</div>
<div class="line">        count</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    ... on Page {</div>
<div class="line">      likers {</div>
<div class="line">        count</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Inline fragments may also be used to apply a directive to a group of fields. If the TypeCondition is omitted, an inline fragment is considered to be of the same type as the enclosing context.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query inlineFragmentNoType($expandedInfo: Boolean) {</div>
<div class="line">  user(handle: &quot;zuck&quot;) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">    ... @include(if: $expandedInfo) {</div>
<div class="line">      firstName</div>
<div class="line">      lastName</div>
<div class="line">      birthday</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1079"></a>
Input Values</h2>
<p>Value[Const] :</p>
<ul>
<li>[~Const] Variable</li>
<li>IntValue</li>
<li>FloatValue</li>
<li>StringValue</li>
<li>BooleanValue</li>
<li>NullValue</li>
<li>EnumValue</li>
<li>ListValue[?Const]</li>
<li>ObjectValue[?Const]</li>
</ul>
<p>Field and directive arguments accept input values of various literal primitives; input values can be scalars, enumeration values, lists, or input objects.</p>
<p>If not defined as constant (for example, in {DefaultValue}), input values can be specified as a variable. List and inputs objects may also contain variables (unless defined to be constant).</p>
<h3><a class="anchor" id="autotoc_md1080"></a>
Int Value</h3>
<p>IntValue :: IntegerPart [lookahead != {Digit, <code>.</code>, NameStart}]</p>
<p>IntegerPart ::</p>
<ul>
<li>NegativeSign? 0</li>
<li>NegativeSign? NonZeroDigit Digit*</li>
</ul>
<p>NegativeSign :: -</p>
<p>NonZeroDigit :: Digit but not <code>0</code></p>
<p>An {IntValue} is specified without a decimal point or exponent but may be negative (e.g. {-123}). It must not have any leading {0}.</p>
<p>An {IntValue} must not be followed by a {Digit}. In other words, an {IntValue} token is always the longest possible valid sequence. The source characters {12} cannot be interpreted as two tokens since {1} is followed by the {Digit} {2}. This also means the source {00} is invalid since it can neither be interpreted as a single token nor two {0} tokens.</p>
<p>An {IntValue} must not be followed by a {<code>.</code>} or {NameStart}. If either {<code>.</code>} or {ExponentIndicator} follows then the token must only be interpreted as a possible {FloatValue}. No other {NameStart} character can follow. For example the sequences <code>0x123</code> and <code>123L</code> have no valid lexical representations.</p>
<h3><a class="anchor" id="autotoc_md1081"></a>
Float Value</h3>
<p>FloatValue ::</p>
<ul>
<li>IntegerPart FractionalPart ExponentPart [lookahead != {Digit, <code>.</code>, NameStart}]</li>
<li>IntegerPart FractionalPart [lookahead != {Digit, <code>.</code>, NameStart}]</li>
<li>IntegerPart ExponentPart [lookahead != {Digit, <code>.</code>, NameStart}]</li>
</ul>
<p>FractionalPart :: . Digit+</p>
<p>ExponentPart :: ExponentIndicator Sign? Digit+</p>
<p>ExponentIndicator :: one of <code>e</code> <code>E</code></p>
<p>Sign :: one of + -</p>
<p>A {FloatValue} includes either a decimal point (e.g. {1.0}) or an exponent (e.g. {1e50}) or both (e.g. {6.0221413e23}) and may be negative. Like {IntValue}, it also must not have any leading {0}.</p>
<p>A {FloatValue} must not be followed by a {Digit}. In other words, a {FloatValue} token is always the longest possible valid sequence. The source characters {1.23} cannot be interpreted as two tokens since {1.2} is followed by the {Digit} {3}.</p>
<p>A {FloatValue} must not be followed by a {.}. For example, the sequence {1.23.4} cannot be interpreted as two tokens ({1.2}, {3.4}).</p>
<p>A {FloatValue} must not be followed by a {NameStart}. For example the sequence <code>0x1.2p3</code> has no valid lexical representation.</p>
<p>Note: The numeric literals {IntValue} and {FloatValue} both restrict being immediately followed by a letter (or other {NameStart}) to reduce confusion or unexpected behavior since GraphQL only supports decimal numbers.</p>
<h3><a class="anchor" id="autotoc_md1082"></a>
Boolean Value</h3>
<p>BooleanValue : one of <code>true</code> <code>false</code></p>
<p>The two keywords <code>true</code> and <code>false</code> represent the two boolean values.</p>
<h3><a class="anchor" id="autotoc_md1083"></a>
String Value</h3>
<p>StringValue ::</p>
<ul>
<li><code>""</code> [lookahead != <code>"&lt;/tt&gt;]
- &lt;tt&gt;"</code> StringCharacter+ <code>"&lt;/tt&gt;
- BlockString

StringCharacter ::

- SourceCharacter but not &lt;tt&gt;"</code> or <code>\</code> or LineTerminator</li>
<li><code>\u</code> EscapedUnicode</li>
<li><code>\</code> EscapedCharacter</li>
</ul>
<p>EscapedUnicode ::</p>
<ul>
<li><code>{</code> HexDigit+ <code>}</code></li>
<li>HexDigit HexDigit HexDigit HexDigit</li>
</ul>
<p>HexDigit :: one of</p>
<ul>
<li><code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code></li>
<li><code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code></li>
<li><code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code></li>
</ul>
<p>EscapedCharacter :: one of <code>"&lt;/tt&gt; &lt;tt&gt;\\&lt;/tt&gt; &lt;tt&gt;/&lt;/tt&gt; &lt;tt&gt;b&lt;/tt&gt; &lt;tt&gt;f&lt;/tt&gt; &lt;tt&gt;n&lt;/tt&gt; &lt;tt&gt;r&lt;/tt&gt; &lt;tt&gt;t&lt;/tt&gt;

BlockString :: &lt;tt&gt;"""</code> BlockStringCharacter* <code>"""&lt;/tt&gt;

BlockStringCharacter ::

- SourceCharacter but not &lt;tt&gt;"""</code> or <code>\"""&lt;/tt&gt;
- &lt;tt&gt;\\"""&lt;/tt&gt;

A {StringValue} is evaluated to a &lt;em&gt;Unicode text&lt;/em&gt; value, a sequence of &lt;em&gt;Unicode
scalar value&lt;/em&gt;, by interpreting all escape sequences using the static semantics
defined below. Whitespace and other characters ignored between lexical tokens
are significant within a string value.

The empty string {&lt;tt&gt;""&lt;/tt&gt;} must not be followed by another {&lt;tt&gt;"</code>} otherwise it would be interpreted as the beginning of a block string. As an example, the source {<code>""""""</code>} can only be interpreted as a single empty block string and not three empty strings.</p>
<p><b>Escape Sequences</b></p>
<p>In a single-quoted {StringValue}, any <em>Unicode scalar value</em> may be expressed using an escape sequence. GraphQL strings allow both C-style escape sequences (for example <code>\n</code>) and two forms of Unicode escape sequences: one with a fixed-width of 4 hexadecimal digits (for example <code>\u000A</code>) and one with a variable-width most useful for representing a <em>supplementary character</em> such as an Emoji (for example <code>\u{1F4A9}</code>).</p>
<p>The hexadecimal number encoded by a Unicode escape sequence must describe a <em>Unicode scalar value</em>, otherwise must result in a parse error. For example both sources <code>"\uDEAD"</code> and <code>"\u{110000}"</code> should not be considered valid {StringValue}.</p>
<p>Escape sequences are only meaningful within a single-quoted string. Within a block string, they are simply that sequence of characters (for example <code>"""\n"""</code> represents the <em>Unicode text</em> [U+005C, U+006E]). Within a comment an escape sequence is not a significant sequence of characters. They may not appear elsewhere in a GraphQL document.</p>
<p>Since {StringCharacter} must not contain some code points directly (for example, a {LineTerminator}), escape sequences must be used to represent them. All other escape sequences are optional and unescaped non-ASCII Unicode characters are allowed within strings. If using GraphQL within a system which only supports ASCII, then escape sequences may be used to represent all Unicode characters outside of the ASCII range.</p>
<p>For legacy reasons, a <em>supplementary character</em> may be escaped by two fixed-width unicode escape sequences forming a <em>surrogate pair</em>. For example the input <code>"\uD83D\uDCA9"</code> is a valid {StringValue} which represents the same <em>Unicode text</em> as <code>"\u{1F4A9}"</code>. While this legacy form is allowed, it should be avoided as a variable-width unicode escape sequence is a clearer way to encode such code points.</p>
<p>When producing a {StringValue}, implementations should use escape sequences to represent non-printable control characters (U+0000 to U+001F and U+007F to U+009F). Other escape sequences are not necessary, however an implementation may use escape sequences to represent any other range of code points (for example, when producing ASCII-only output). If an implementation chooses to escape a <em>supplementary character</em>, it should only use a variable-width unicode escape sequence.</p>
<p><b>Block Strings</b></p>
<p>Block strings are sequences of characters wrapped in triple-quotes (<code>"""&lt;/tt&gt;).
Whitespace, line terminators, quote, and backslash characters may all be used
unescaped to enable verbatim text. Characters must all be valid
{SourceCharacter}.

Since block strings represent freeform text often used in indented positions,
the string value semantics of a block string excludes uniform indentation and
blank initial and trailing lines via {BlockStringValue()}.

For example, the following operation containing a block string:

@icode{raw} graphql example
mutation {
  sendEmail(message: """ Hello, World!</code></p>
<p><code> Yours, GraphQL. """)
}
@endicode 

Is identical to the standard quoted string:

@icode{graphql} example
mutation {
  sendEmail(message: "Hello,<br  />
 World!<br  />
\nYours,<br  />
 GraphQL.")
}
@endicode 

Since block string values strip leading and trailing empty lines, there is no
single canonical printed block string for a given value. Because block strings
typically represent freeform text, it is considered easier to read if they begin
and end with an empty line.

@icode{graphql} example
""" This starts with and ends with an empty line, which makes it easier to read. """
@endicode 

@icode{graphql} counter-example
"""This does not start with or end with any empty lines, which makes it a little harder to read."""
@endicode 

Note: If non-printable ASCII characters are needed in a string value, a standard
quoted string with appropriate escape sequences must be used instead of a block
string.

&lt;strong&gt;Static Semantics&lt;/strong&gt;

:: A {StringValue} describes a &lt;em&gt;Unicode text&lt;/em&gt; value, which is a sequence of
&lt;em&gt;Unicode scalar value&lt;/em&gt;.

These semantics describe how to apply the {StringValue} grammar to a source text
to evaluate a &lt;em&gt;Unicode text&lt;/em&gt;. Errors encountered during this evaluation are
considered a failure to apply the {StringValue} grammar to a source and must
result in a parsing error.

StringValue :: &lt;tt&gt;""&lt;/tt&gt;

- Return an empty sequence.

StringValue :: &lt;tt&gt;"</code> StringCharacter+ <code>"&lt;/tt&gt;

- Return the &lt;em&gt;Unicode text&lt;/em&gt; by concatenating the evaluation of all
  {StringCharacter}.

StringCharacter :: SourceCharacter but not &lt;tt&gt;"</code> or <code>\</code> or LineTerminator</p>
<ul>
<li>Return the <em>Unicode scalar value</em> {SourceCharacter}.</li>
</ul>
<p>StringCharacter :: <code>\u</code> EscapedUnicode</p>
<ul>
<li>Let {value} be the hexadecimal value represented by the sequence of {HexDigit} within {EscapedUnicode}.</li>
<li>Assert: {value} is a within the <em>Unicode scalar value</em> range (&gt;= 0x0000 and &lt;= 0xD7FF or &gt;= 0xE000 and &lt;= 0x10FFFF).</li>
<li>Return the <em>Unicode scalar value</em> {value}.</li>
</ul>
<p>StringCharacter :: <code>\u</code> HexDigit HexDigit HexDigit HexDigit <code>\u</code> HexDigit HexDigit HexDigit HexDigit</p>
<ul>
<li>Let {leadingValue} be the hexadecimal value represented by the first sequence of {HexDigit}.</li>
<li>Let {trailingValue} be the hexadecimal value represented by the second sequence of {HexDigit}.</li>
<li>If {leadingValue} is &gt;= 0xD800 and &lt;= 0xDBFF (a <em>Leading Surrogate</em>):<ul>
<li>Assert: {trailingValue} is &gt;= 0xDC00 and &lt;= 0xDFFF (a <em>Trailing Surrogate</em>).</li>
<li>Return ({leadingValue} - 0xD800) Ã— 0x400 + ({trailingValue} - 0xDC00) + 0x10000.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Assert: {leadingValue} is within the <em>Unicode scalar value</em> range.</li>
<li>Assert: {trailingValue} is within the <em>Unicode scalar value</em> range.</li>
<li>Return the sequence of the <em>Unicode scalar value</em> {leadingValue} followed by the <em>Unicode scalar value</em> {trailingValue}.</li>
</ul>
</li>
</ul>
<p>Note: If both escape sequences encode a <em>Unicode scalar value</em>, then this semantic is identical to applying the prior semantic on each fixed-width escape sequence. A variable-width escape sequence must only encode a <em>Unicode scalar value</em>.</p>
<p>StringCharacter :: <code>\</code> EscapedCharacter</p>
<ul>
<li>Return the <em>Unicode scalar value</em> represented by {EscapedCharacter} according to the table below.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Escaped Character   </th><th class="markdownTableHeadNone">Scalar Value   </th><th class="markdownTableHeadNone">Character Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">{<code>"</code>}   </td><td class="markdownTableBodyNone">U+0022   </td><td class="markdownTableBodyNone">double quote    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">{<code>\</code>}   </td><td class="markdownTableBodyNone">U+005C   </td><td class="markdownTableBodyNone">reverse solidus (back slash)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">{<code>/</code>}   </td><td class="markdownTableBodyNone">U+002F   </td><td class="markdownTableBodyNone">solidus (forward slash)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">{<code>b</code>}   </td><td class="markdownTableBodyNone">U+0008   </td><td class="markdownTableBodyNone">backspace    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">{<code>f</code>}   </td><td class="markdownTableBodyNone">U+000C   </td><td class="markdownTableBodyNone">form feed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">{<code>n</code>}   </td><td class="markdownTableBodyNone">U+000A   </td><td class="markdownTableBodyNone">line feed (new line)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">{<code>r</code>}   </td><td class="markdownTableBodyNone">U+000D   </td><td class="markdownTableBodyNone">carriage return    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">{<code>t</code>}   </td><td class="markdownTableBodyNone">U+0009   </td><td class="markdownTableBodyNone">horizontal tab   </td></tr>
</table>
<p>StringValue :: BlockString</p>
<ul>
<li>Return the <em>Unicode text</em> by evaluating the {BlockString}.</li>
</ul>
<p>BlockString :: <code>"""&lt;/tt&gt; BlockStringCharacter* &lt;tt&gt;"""</code></p>
<ul>
<li>Let {rawValue} be the <em>Unicode text</em> by concatenating the evaluation of all {BlockStringCharacter} (which may be an empty sequence).</li>
<li>Return the result of {BlockStringValue(rawValue)}.</li>
</ul>
<p>BlockStringCharacter :: SourceCharacter but not <code>"""&lt;/tt&gt; or &lt;tt&gt;\\"""&lt;/tt&gt;

- Return the &lt;em&gt;Unicode scalar value&lt;/em&gt; {SourceCharacter}.

BlockStringCharacter :: &lt;tt&gt;\\"""&lt;/tt&gt;

- Return the character sequence &lt;tt&gt;"""</code>.</p>
<p>BlockStringValue(rawValue):</p>
<ul>
<li>Let {lines} be the result of splitting {rawValue} by {LineTerminator}.</li>
<li>Let {commonIndent} be {null}.</li>
<li>For each {line} in {lines}:<ul>
<li>If {line} is the first item in {lines}, continue to the next {line}.</li>
<li>Let {length} be the number of characters in {line}.</li>
<li>Let {indent} be the number of leading consecutive {Whitespace} characters in {line}.</li>
<li>If {indent} is less than {length}:<ul>
<li>If {commonIndent} is {null} or {indent} is less than {commonIndent}:<ul>
<li>Let {commonIndent} be {indent}.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If {commonIndent} is not {null}:<ul>
<li>For each {line} in {lines}:<ul>
<li>If {line} is the first item in {lines}, continue to the next line.</li>
<li>Remove {commonIndent} characters from the beginning of {line}.</li>
</ul>
</li>
</ul>
</li>
<li>While the first item {line} in {lines} contains only {Whitespace}:<ul>
<li>Remove the first item from {lines}.</li>
</ul>
</li>
<li>While the last item {line} in {lines} contains only {Whitespace}:<ul>
<li>Remove the last item from {lines}.</li>
</ul>
</li>
<li>Let {formatted} be the empty character sequence.</li>
<li>For each {line} in {lines}:<ul>
<li>If {line} is the first item in {lines}:<ul>
<li>Append {formatted} with {line}.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Append {formatted} with a line feed character (U+000A).</li>
<li>Append {formatted} with {line}.</li>
</ul>
</li>
</ul>
</li>
<li>Return {formatted}.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1084"></a>
Null Value</h3>
<p>NullValue : <code>null</code></p>
<p>Null values are represented as the keyword {null}.</p>
<p>GraphQL has two semantically different ways to represent the lack of a value:</p>
<ul>
<li>Explicitly providing the literal value: {null}.</li>
<li>Implicitly not providing a value at all.</li>
</ul>
<p>For example, these two field calls are similar, but are not identical:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  field(arg: null)</div>
<div class="line">  field</div>
<div class="line">}</div>
</div><!-- fragment --><p>The first has explicitly provided {null} to the argument "arg", while the second has implicitly not provided a value to the argument "arg". These two forms may be interpreted differently. For example, a mutation representing deleting a field vs not altering a field, respectively. Neither form may be used for an input expecting a Non-Null type.</p>
<p>Note: The same two methods of representing the lack of a value are possible via variables by either providing the variable value as {null} or not providing a variable value at all.</p>
<h3><a class="anchor" id="autotoc_md1085"></a>
Enum Value</h3>
<p>EnumValue : Name but not <code>true</code>, <code>false</code> or <code>null</code></p>
<p>Enum values are represented as unquoted names (e.g. <code>MOBILE_WEB</code>). It is recommended that Enum values be "all caps". Enum values are only used in contexts where the precise enumeration type is known. Therefore it is not necessary to supply an enumeration type name in the literal.</p>
<h3><a class="anchor" id="autotoc_md1086"></a>
List Value</h3>
<p>ListValue[Const] :</p>
<ul class="check">
<li class="unchecked"></li>
</ul>
<ul>
<li>[ Value[?Const]+ ]</li>
</ul>
<p>Lists are ordered sequences of values wrapped in square brackets <code>[ ]</code>. The values of a List literal may be any value literal or variable (e.g. <code>[1, 2, 3]</code>).</p>
<p>Commas are optional throughout GraphQL so trailing commas are allowed and repeated commas do not represent missing values.</p>
<p><b>Semantics</b></p>
<p>ListValue : [ ]</p>
<ul>
<li>Return a new empty list value.</li>
</ul>
<p>ListValue : [ Value+ ]</p>
<ul>
<li>Let {inputList} be a new empty list value.</li>
<li>For each {Value+}:<ul>
<li>Let {value} be the result of evaluating {Value}.</li>
<li>Append {value} to {inputList}.</li>
</ul>
</li>
<li>Return {inputList}.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1087"></a>
Input Object Values</h3>
<p>ObjectValue[Const] :</p>
<ul>
<li>{ }</li>
<li>{ ObjectField[?Const]+ }</li>
</ul>
<p>ObjectField[Const] : Name : Value[?Const]</p>
<p>Input object literal values are unordered lists of keyed input values wrapped in curly braces <code>{ }</code>. The values of an object literal may be any input value literal or variable (e.g. <code>{ name: "Hello world", score: 1.0 }</code>). We refer to literal representation of input objects as "object literals."</p>
<p><b>Input Object Fields Are Unordered</b></p>
<p>Input object fields may be provided in any syntactic order and maintain identical semantic meaning.</p>
<p>These two operations are semantically identical:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  nearestThing(location: { lon: 12.43, lat: -53.211 })</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  nearestThing(location: { lat: -53.211, lon: 12.43 })</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Semantics</b></p>
<p>ObjectValue : { }</p>
<ul>
<li>Return a new input object value with no fields.</li>
</ul>
<p>ObjectValue : { ObjectField+ }</p>
<ul>
<li>Let {inputObject} be a new input object value with no fields.</li>
<li>For each {field} in {ObjectField+}:<ul>
<li>Let {name} be {Name} in {field}.</li>
<li>Let {value} be the result of evaluating {Value} in {field}.</li>
<li>Add a field to {inputObject} of name {name} containing value {value}.</li>
</ul>
</li>
<li>Return {inputObject}.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1088"></a>
Variables</h2>
<p>Variable : $ Name</p>
<p>VariablesDefinition : ( VariableDefinition+ )</p>
<p>VariableDefinition : Description? Variable : Type DefaultValue? Directives[Const]?</p>
<p>DefaultValue : = Value[Const]</p>
<p>A GraphQL operation can be parameterized with variables, maximizing reuse, and avoiding costly string building in clients at runtime.</p>
<p>If not defined as constant (for example, in {DefaultValue}), a {Variable} can be supplied for an input value.</p>
<p>Variables must be defined at the top of an operation and are in scope throughout the execution of that operation. Values for those variables are provided to a GraphQL service as part of a request so they may be substituted in during execution.</p>
<p>In this example, we want to fetch a profile picture size based on the size of a particular device:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query getZuckProfile(</div>
<div class="line">  &quot;The size of the profile picture to fetch.&quot;</div>
<div class="line">  $devicePicSize: Int</div>
<div class="line">) {</div>
<div class="line">  user(id: 4) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">    profilePic(size: $devicePicSize)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If providing JSON for the variables' values, we could request a <code>profilePic</code> of size <code>60</code>:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  &quot;devicePicSize&quot;: 60</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Variable Use Within Fragments</b></p>
<p>Variables can be used within fragments. Variables have global scope with a given operation, so a variable used within a fragment must be declared in any top-level operation that transitively consumes that fragment. If a variable is referenced in a fragment and is included by an operation that does not define that variable, that operation is invalid (see All Variable Uses Defined).</p>
<h2><a class="anchor" id="autotoc_md1089"></a>
Type References</h2>
<p>Type :</p>
<ul>
<li>NamedType</li>
<li>ListType</li>
<li>NonNullType</li>
</ul>
<p>NamedType : Name</p>
<p>ListType : [ Type ]</p>
<p>NonNullType :</p>
<ul>
<li>NamedType !</li>
<li>ListType !</li>
</ul>
<p>GraphQL describes the types of data expected by arguments and variables. Input types may be lists of another input type, or a non-null variant of any other input type.</p>
<p><b>Semantics</b></p>
<p>Type : Name</p>
<ul>
<li>Let {name} be the string value of {Name}.</li>
<li>Let {type} be the type defined in the Schema named {name}.</li>
<li>{type} must exist.</li>
<li>Return {type}.</li>
</ul>
<p>Type : [ Type ]</p>
<ul>
<li>Let {itemType} be the result of evaluating {Type}.</li>
<li>Let {type} be a List type where {itemType} is the contained type.</li>
<li>Return {type}.</li>
</ul>
<p>Type : Type !</p>
<ul>
<li>Let {nullableType} be the result of evaluating {Type}.</li>
<li>Let {type} be a Non-Null type where {nullableType} is the contained type.</li>
<li>Return {type}.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1090"></a>
Directives</h2>
<p>Directives[Const] : Directive[?Const]+</p>
<p>Directive[Const] : @ Name Arguments[?Const]?</p>
<p>Directives provide a way to describe alternate runtime execution and type validation behavior in a GraphQL document.</p>
<p>In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.</p>
<p>Directives have a name along with a list of arguments which may accept values of any input type.</p>
<p>Directives can be used to describe additional information for types, fields, fragments and operations.</p>
<p>As future versions of GraphQL adopt new configurable execution capabilities, they may be exposed via directives. GraphQL services and tools may also provide any additional <em>custom directive</em> beyond those described here.</p>
<p><b>Directive Order Is Significant</b></p>
<p>Directives may be provided in a specific syntactic order which may have semantic interpretation.</p>
<p>These two type definitions may have different semantic meaning:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Person</div>
<div class="line">  @addExternalFields(source: &quot;profiles&quot;)</div>
<div class="line">  @excludeField(name: &quot;photo&quot;) {</div>
<div class="line">  name: String</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> example</div>
<div class="line">type Person</div>
<div class="line">  @excludeField(name: &quot;photo&quot;)</div>
<div class="line">  @addExternalFields(source: &quot;profiles&quot;) {</div>
<div class="line">  name: String</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1091"></a>
Schema Coordinates</h2>
<p>SchemaCoordinate ::</p>
<ul>
<li>TypeCoordinate</li>
<li>MemberCoordinate</li>
<li>ArgumentCoordinate</li>
<li>DirectiveCoordinate</li>
<li>DirectiveArgumentCoordinate</li>
</ul>
<p>TypeCoordinate :: Name</p>
<p>MemberCoordinate :: Name . Name</p>
<p>ArgumentCoordinate :: Name . Name ( Name : )</p>
<p>DirectiveCoordinate :: @ Name</p>
<p>DirectiveArgumentCoordinate :: @ Name ( Name : )</p>
<p>:: A <em>schema coordinate</em> is a human readable string that uniquely identifies a <em>schema element</em> within a GraphQL Schema, intended to be used by tools to reference types, fields, and other <em>schema element</em>. Examples include: references within documentation to refer to types and fields in a schema, a lookup key that can be used in logging tools to track how often particular fields are queried in production.</p>
<p>:: A <em>schema element</em> can be a named type, a field, an input field, an enum value, a field argument, a directive, or a directive argument defined within a schema (including built-in types and directives).</p>
<p>Note: Meta-fields are not defined within a schema, and thus are not <em>schema element</em>. By extension, an introspection type is not a <em>schema element</em>.</p>
<p>:: The <em>containing element</em> of a <em>schema element</em> is the schema element with one fewer {Name} token that syntactically contains it. Specifically:</p>
<ul>
<li>The containing element of an {ArgumentCoordinate} is a {MemberCoordinate}.</li>
<li>The containing element of a {MemberCoordinate} is a {TypeCoordinate}.</li>
<li>The containing element of a {DirectiveArgumentCoordinate} is a {DirectiveCoordinate}.</li>
<li>{TypeCoordinate} and {DirectiveCoordinate} have no containing element.</li>
</ul>
<p>A <em>schema coordinate</em> is always unique. Each <em>schema element</em> can be referenced by exactly one possible schema coordinate.</p>
<p>A <em>schema coordinate</em> may refer to either a defined or built-in <em>schema element</em>. For example, <code>String</code> and <code>@deprecated(reason:)</code> are both valid schema coordinates which refer to built-in schema elements.</p>
<p>Note: A union member references a type in the schema. A type in the schema is identified by a {TypeCoordinate}. There is no schema coordinate which indicates a union member; this preserves the uniqueness property of a <em>schema coordinate</em> as stated above.</p>
<p><b>Parsing a Schema Coordinate</b></p>
<p>SchemaCoordinateToken ::</p>
<ul>
<li>SchemaCoordinatePunctuator</li>
<li>Name</li>
</ul>
<p>SchemaCoordinatePunctuator :: one of ( ) . : @</p>
<p>A {SchemaCoordinate} is a self-contained grammar with its own set of lexical tokens, it is not contained within a {Document}. The source text of a SchemaCoordinate must be a sequence of {SourceCharacter}.</p>
<p>Unlike other GraphQL documents, {SchemaCoordinate} must not contain {Whitespace} or other {Ignored} grammars within the character sequence. This ensures that every schema coordinates has a single unambiguous and unique lexical form.</p>
<p><b>Resolving a Schema Coordinate</b></p>
<p>To refer to a <em>schema element</em>, a <em>schema coordinate</em> must be interpreted in the context of a GraphQL {schema}.</p>
<p>If the <em>schema element</em> cannot be found, the resolve function will not yield a value (without raising an error). However, an error will be raised if any non-leaf nodes within a <em>schema coordinate</em> cannot be found in the {schema}.</p>
<p>Note: Although it is syntactically possible to describe a meta-field or element of the introspection schema with a schema coordinate (e.g. <code>Business.__typename</code> or <code>__Type.fields(includeDeprecated:)</code>), they are not <em>schema element</em> and therefore resolving such coordinates does not have a defined behavior.</p>
<p>TypeCoordinate :: Name</p>
<ol type="1">
<li>Let {typeName} be the value of {Name}.</li>
<li>Return the type in {schema} named {typeName} if it exists.</li>
</ol>
<p>MemberCoordinate :: Name . Name</p>
<ol type="1">
<li>Let {typeName} be the value of the first {Name}.</li>
<li>Let {type} be the type in {schema} named {typeName}.</li>
<li>Assert: {type} must exist, and must be an Enum, Input Object, Object or Interface type.</li>
<li>If {type} is an Enum type:<ol type="a">
<li>Let {enumValueName} be the value of the second {Name}.</li>
<li>Return the enum value of {type} named {enumValueName} if it exists.</li>
</ol>
</li>
<li>Otherwise, if {type} is an Input Object type:<ol type="a">
<li>Let {inputFieldName} be the value of the second {Name}.</li>
<li>Return the input field of {type} named {inputFieldName} if it exists.</li>
</ol>
</li>
<li>Otherwise:<ol type="a">
<li>Let {fieldName} be the value of the second {Name}.</li>
<li>Return the field of {type} named {fieldName} if it exists.</li>
</ol>
</li>
</ol>
<p>ArgumentCoordinate :: Name . Name ( Name : )</p>
<ol type="1">
<li>Let {typeName} be the value of the first {Name}.</li>
<li>Let {type} be the type in {schema} named {typeName}.</li>
<li>Assert: {type} must exist, and be an Object or Interface type.</li>
<li>Let {fieldName} be the value of the second {Name}.</li>
<li>Let {field} be the field of {type} named {fieldName}.</li>
<li>Assert: {field} must exist.</li>
<li>Let {fieldArgumentName} be the value of the third {Name}.</li>
<li>Return the argument of {field} named {fieldArgumentName} if it exists.</li>
</ol>
<p>DirectiveCoordinate :: @ Name</p>
<ol type="1">
<li>Let {directiveName} be the value of {Name}.</li>
<li>Return the directive in {schema} named {directiveName} if it exists.</li>
</ol>
<p>DirectiveArgumentCoordinate :: @ Name ( Name : )</p>
<ol type="1">
<li>Let {directiveName} be the value of the first {Name}.</li>
<li>Let {directive} be the directive in {schema} named {directiveName}.</li>
<li>Assert: {directive} must exist.</li>
<li>Let {directiveArgumentName} be the value of the second {Name}.</li>
<li>Return the argument of {directive} named {directiveArgumentName} if it exists.</li>
</ol>
<p><b>Examples</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Element Kind   </th><th class="markdownTableHeadNone">Schema Coordinate   </th><th class="markdownTableHeadNone">Schema Element    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Named Type   </td><td class="markdownTableBodyNone"><code>Business</code>   </td><td class="markdownTableBodyNone"><code>Business</code> type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Field   </td><td class="markdownTableBodyNone"><code>Business.name</code>   </td><td class="markdownTableBodyNone"><code>name</code> field on the <code>Business</code> type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Input Field   </td><td class="markdownTableBodyNone"><code>SearchCriteria.filter</code>   </td><td class="markdownTableBodyNone"><code>filter</code> input field on the <code>SearchCriteria</code> input object type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Enum Value   </td><td class="markdownTableBodyNone"><code>SearchFilter.OPEN_NOW</code>   </td><td class="markdownTableBodyNone"><code>OPEN_NOW</code> value of the <code>SearchFilter</code> enum    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field Argument   </td><td class="markdownTableBodyNone"><code>Query.searchBusiness(criteria:)</code>   </td><td class="markdownTableBodyNone"><code>criteria</code> argument on the <code>searchBusiness</code> field on the <code>Query</code> type    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Directive   </td><td class="markdownTableBodyNone"><code>@private</code>   </td><td class="markdownTableBodyNone"><code>@private</code> directive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Directive Argument   </td><td class="markdownTableBodyNone"><code>@private(scope:)</code>   </td><td class="markdownTableBodyNone"><code>scope</code> argument on the <code>@private</code> directive   </td></tr>
</table>
<p>The table above shows an example of a <em>schema coordinate</em> for every kind of <em>schema element</em> based on the schema below.</p>
<div class="fragment"><div class="line">type Query {</div>
<div class="line">  searchBusiness(criteria: SearchCriteria!): [Business]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input SearchCriteria {</div>
<div class="line">  name: String</div>
<div class="line">  filter: SearchFilter</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">enum SearchFilter {</div>
<div class="line">  OPEN_NOW</div>
<div class="line">  DELIVERS_TAKEOUT</div>
<div class="line">  VEGETARIAN_MENU</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Business {</div>
<div class="line">  id: ID</div>
<div class="line">  name: String</div>
<div class="line">  email: String @private(scope: &quot;loggedIn&quot;)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">directive @private(scope: String!) on FIELD_DEFINITION</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
