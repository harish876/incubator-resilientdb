#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_storage_layer</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/db2/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_206__storage__layer.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_storage_layer</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> layout: default title: 'Chapter 6: Storage Layer' parent: 'ResilientDB' </p>
<h2><a class="anchor" id="autotoc_md133"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md134"></a>
Chapter 6: Storage Layer</h1>
<p>In the previous chapter, <a class="el" href="../../d6/d63/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_205__transaction__execution.html">Chapter 5: Transaction Execution</a>, we saw how ResilientDB takes agreed-upon transactions and executes them using specialists like <code>KVExecutor</code> or <code><a class="el" href="../../d2/d1d/classUTXOExecutor.html">UTXOExecutor</a></code>. For example, the <code>KVExecutor</code> handles a command like <code>Set("myKey", "myValue")</code>.</p>
<p>But where does that <code>myValue</code> actually get stored so that it isn't lost when the computer restarts? And how can we retrieve it later using <code>Get("myKey")</code>?</p>
<p>Welcome to Chapter 6! We're diving into the <b>Storage Layer</b>. This is the component that handles the actual saving and loading of data – the blockchain state and transaction history.</p>
<p>Think of the Storage Layer as the <b>filing cabinet or hard drive</b> of ResilientDB. After the committee (Chapter 3) agrees on a decision and the specialist (Chapter 5) knows <em>what</em> change to make, the Storage Layer is responsible for actually <em>writing it down</em> and putting it in the right place.</p>
<h2><a class="anchor" id="autotoc_md135"></a>
Why Do We Need a Storage Layer?</h2>
<p>Imagine you're using ResilientDB as a super-reliable notepad. You tell it to remember "Meeting at 3 PM".</p>
<ul>
<li>The command gets sent (Chapter 1), communicated (Chapter 2), agreed upon (Chapter 3), collected (Chapter 4), and the execution logic (Chapter 5) knows it needs to store this note.</li>
<li>But if the computer running ResilientDB shuts down, how does it remember "Meeting at 3 PM" when it starts back up?</li>
</ul>
<p>We need <b>persistence</b> – the ability to save data in a way that survives restarts. This usually means writing to a hard disk drive (HDD) or solid-state drive (SSD).</p>
<p>However, sometimes, especially during testing or for specific high-speed scenarios, we might prioritize speed over durability. We might want to store data directly in the computer's fast memory (RAM), even if it gets lost on restart.</p>
<p>The Storage Layer provides an abstraction to handle both needs: reliable disk storage and fast memory storage.</p>
<h2><a class="anchor" id="autotoc_md136"></a>
The Blueprint: The <code>Storage</code> Interface</h2>
<p>ResilientDB defines a standard "blueprint" for how storage should work, called the <code>Storage</code> interface (defined in <code><a class="el" href="../../d8/d6b/storage_8h.html">chain/storage/storage.h</a></code>). This interface lists the basic operations any storage engine must support, like:</p>
<ul>
<li><code>SetValue(key, value)</code>: Store a piece of data (value) associated with a name (key).</li>
<li><code>GetValue(key)</code>: Retrieve the data associated with a key.</li>
<li>Other operations like getting ranges of data or handling data versions.</li>
</ul>
<p><b>Analogy:</b> The <code>Storage</code> interface is like the job description for a librarian. It says the librarian must be able to check books in (<code>SetValue</code>) and check books out (<code>GetValue</code>), but it doesn't specify <em>how</em> they organize the shelves or <em>which</em> specific building they work in.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified view from chain/storage/storage.h</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="../../d5/d10/namespaceresdb.html">resdb</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Storage {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="../../d2/d14/classresdb_1_1Storage.html#a043b87c929e00dd9cce9366f1d3c38c9">Storage</a>() = <span class="keywordflow">default</span>;</div>
<div class="line">  <span class="keyword">virtual</span> <a class="code hl_function" href="../../d2/d14/classresdb_1_1Storage.html#a6890672501d28f0ede54be1236f10a28">~Storage</a>() = <span class="keywordflow">default</span>; <span class="comment">// Virtual destructor is important for interfaces</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Store the key-value pair. Returns 0 on success.</span></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code hl_function" href="../../d2/d14/classresdb_1_1Storage.html#a25813c70209abf748b0e2532132999b9">SetValue</a>(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value) = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Retrieve the value for the given key. Returns empty string if not found.</span></div>
<div class="line">  <span class="keyword">virtual</span> std::string <a class="code hl_function" href="../../d2/d14/classresdb_1_1Storage.html#a8d2a1873cd805da6a6adde8ad11a9b25">GetValue</a>(<span class="keyword">const</span> std::string&amp; key) = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// === Other methods omitted for simplicity ===</span></div>
<div class="line">  <span class="comment">// virtual std::string GetAllValues() = 0;</span></div>
<div class="line">  <span class="comment">// virtual std::string GetRange(...) = 0;</span></div>
<div class="line">  <span class="comment">// virtual int SetValueWithVersion(...) = 0;</span></div>
<div class="line">  <span class="comment">// virtual std::pair&lt;std::string, int&gt; GetValueWithVersion(...) = 0;</span></div>
<div class="line">  <span class="comment">// virtual ... GetHistory(...) = 0;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace resdb</span></div>
<div class="ttc" id="aclassresdb_1_1Storage_html_a043b87c929e00dd9cce9366f1d3c38c9"><div class="ttname"><a href="../../d2/d14/classresdb_1_1Storage.html#a043b87c929e00dd9cce9366f1d3c38c9">resdb::Storage::Storage</a></div><div class="ttdeci">Storage()=default</div></div>
<div class="ttc" id="aclassresdb_1_1Storage_html_a25813c70209abf748b0e2532132999b9"><div class="ttname"><a href="../../d2/d14/classresdb_1_1Storage.html#a25813c70209abf748b0e2532132999b9">resdb::Storage::SetValue</a></div><div class="ttdeci">virtual int SetValue(const std::string &amp;key, const std::string &amp;value)=0</div></div>
<div class="ttc" id="aclassresdb_1_1Storage_html_a6890672501d28f0ede54be1236f10a28"><div class="ttname"><a href="../../d2/d14/classresdb_1_1Storage.html#a6890672501d28f0ede54be1236f10a28">resdb::Storage::~Storage</a></div><div class="ttdeci">virtual ~Storage()=default</div></div>
<div class="ttc" id="aclassresdb_1_1Storage_html_a8d2a1873cd805da6a6adde8ad11a9b25"><div class="ttname"><a href="../../d2/d14/classresdb_1_1Storage.html#a8d2a1873cd805da6a6adde8ad11a9b25">resdb::Storage::GetValue</a></div><div class="ttdeci">virtual std::string GetValue(const std::string &amp;key)=0</div></div>
<div class="ttc" id="anamespaceresdb_html"><div class="ttname"><a href="../../d5/d10/namespaceresdb.html">resdb</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/d85/chain__state_8cpp_source.html#l00024">chain_state.cpp:24</a></div></div>
</div><!-- fragment --><p>This code defines the basic contract. Any class that claims to be a <code>Storage</code> provider <em>must</em> provide implementations for these <code>virtual</code> functions (indicated by <code>= 0</code>).</p>
<h2><a class="anchor" id="autotoc_md137"></a>
The Implementations: Different Ways to Store Data</h2>
<p>ResilientDB comes with different implementations (librarians who follow the job description) of the <code>Storage</code> interface:</p>
<ol type="1">
<li><b><code>ResLevelDB</code> (Disk Storage):</b><ul>
<li><b>What it is:</b> This uses <b>LevelDB</b>, a fast key-value storage library developed by Google that writes data to disk.</li>
<li><b>Analogy:</b> This is like a traditional library with physical shelves. When you check in a book (<code>SetValue</code>), the librarian carefully files it on the correct shelf. It stays there even if the library closes overnight (persistence). Checking out (<code>GetValue</code>) involves finding it on the shelf.</li>
<li><b>Pros:</b> Data is persistent (survives restarts). Well-suited for production use where durability is crucial.</li>
<li><b>Cons:</b> Disk access is slower than memory access.</li>
</ul>
</li>
<li><b><code>MemoryDB</code> (Memory Storage):</b><ul>
<li><b>What it is:</b> This stores everything directly in the computer's RAM using standard data structures like maps.</li>
<li><b>Analogy:</b> This is like a librarian using only sticky notes on their desk. Checking in (<code>SetValue</code>) means writing on a new note and sticking it somewhere. Checking out (<code>GetValue</code>) is quick – just glance at the notes. But when the librarian goes home (program stops), the desk is cleared, and all notes are lost (non-persistent).</li>
<li><b>Pros:</b> Very fast access because it avoids slow disk operations. Useful for testing or scenarios where data loss on restart is acceptable.</li>
<li><b>Cons:</b> Data is lost when the program stops or restarts.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md138"></a>
How is Storage Used? (Example: <code>KVExecutor</code>)</h2>
<p>Remember the <code>KVExecutor</code> from Chapter 5? It needs to store the key-value data somewhere. When it's created, it's given an instance of a <code>Storage</code> object (which could be <code>ResLevelDB</code> or <code>MemoryDB</code> depending on the configuration).</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from executor/kv/kv_executor.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d72/kv__executor_8h.html">executor/kv/kv_executor.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d6b/storage_8h.html">chain/storage/storage.h</a>&quot;</span> <span class="comment">// Include the Storage interface</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Constructor - takes a Storage object</span></div>
<div class="line">KVExecutor::KVExecutor(std::unique_ptr&lt;Storage&gt; storage)</div>
<div class="line">    : storage_(std::move(storage)) {} <span class="comment">// Store the passed-in storage object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method to handle SET command</span></div>
<div class="line"><span class="keywordtype">void</span> KVExecutor::Set(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value) {</div>
<div class="line">  <span class="comment">// Call the SetValue method ON THE STORAGE OBJECT</span></div>
<div class="line">  <span class="comment">// We don&#39;t know or care here if it&#39;s LevelDB or MemoryDB!</span></div>
<div class="line">  storage_-&gt;SetValue(key, value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method to handle GET command</span></div>
<div class="line">std::string KVExecutor::Get(<span class="keyword">const</span> std::string&amp; key) {</div>
<div class="line">  <span class="comment">// Call the GetValue method ON THE STORAGE OBJECT</span></div>
<div class="line">  <span class="keywordflow">return</span> storage_-&gt;GetValue(key);</div>
<div class="line">}</div>
<div class="ttc" id="akv__executor_8h_html"><div class="ttname"><a href="../../d1/d72/kv__executor_8h.html">kv_executor.h</a></div></div>
<div class="ttc" id="astorage_8h_html"><div class="ttname"><a href="../../d8/d6b/storage_8h.html">storage.h</a></div></div>
</div><!-- fragment --><p>The <code>KVExecutor</code> code doesn't need to know the specific <em>type</em> of storage. It just calls the methods defined in the <code>Storage</code> interface (<code>storage_-&gt;SetValue</code>, <code>storage_-&gt;GetValue</code>). This makes the <code>KVExecutor</code> flexible – it can work with any storage backend that follows the <code>Storage</code> blueprint.</p>
<h2><a class="anchor" id="autotoc_md139"></a>
Internal Implementation Walkthrough</h2>
<p>Let's see what happens when <code>KVExecutor</code> calls <code>storage_-&gt;SetValue("myKey", "myValue")</code>:</p>
<ol type="1">
<li><b><code>KVExecutor</code> Call:</b> The <code>KVExecutor</code> invokes the <code>SetValue</code> method on the <code>storage_</code> object it holds.</li>
<li><b>Polymorphism (Magic Dispatch):</b> Because <code>SetValue</code> is a <code>virtual</code> function in the <code>Storage</code> base class, the C++ runtime figures out the <em>actual type</em> of the <code>storage_</code> object (is it <code>ResLevelDB</code> or <code>MemoryDB</code>?). It then calls the <code>SetValue</code> implementation specific to that type.</li>
<li><b>Specific Implementation Executes:</b><ul>
<li><b>If <code>storage_</code> is <code>ResLevelDB</code>:</b> The <code>ResLevelDB::SetValue</code> method is called. This method will interact with the LevelDB library, preparing the data to be written to disk (often using a write batch for efficiency).</li>
<li><b>If <code>storage_</code> is <code>MemoryDB</code>:</b> The <code>MemoryDB::SetValue</code> method is called. This method will simply update its internal in-memory map (e.g., <code>kv_map_["myKey"] = "myValue"</code>).</li>
</ul>
</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant KVE as KVExecutor</div>
<div class="line">    participant StoreIF as Storage Interface</div>
<div class="line">    participant LDB as ResLevelDB (Implementation)</div>
<div class="line">    participant MDB as MemoryDB (Implementation)</div>
<div class="line"> </div>
<div class="line">    KVE-&gt;&gt;StoreIF: storage_-&gt;SetValue(&quot;myKey&quot;, &quot;myValue&quot;)</div>
<div class="line"> </div>
<div class="line">    alt Storage is LevelDB</div>
<div class="line">        StoreIF-&gt;&gt;+LDB: SetValue(&quot;myKey&quot;, &quot;myValue&quot;)</div>
<div class="line">        Note right of LDB: Add to LevelDB batch buffer&lt;br/&gt;(Disk write might happen later)</div>
<div class="line">        LDB--&gt;&gt;-StoreIF: Return status (e.g., 0)</div>
<div class="line">    else Storage is MemoryDB</div>
<div class="line">        StoreIF-&gt;&gt;+MDB: SetValue(&quot;myKey&quot;, &quot;myValue&quot;)</div>
<div class="line">        Note right of MDB: Update internal map:&lt;br/&gt;kv_map_[&quot;myKey&quot;] = &quot;myValue&quot;</div>
<div class="line">        MDB--&gt;&gt;-StoreIF: Return status (e.g., 0)</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    StoreIF--&gt;&gt;KVE: Return status (e.g., 0)</div>
</div><!-- fragment --><p>This diagram shows how the <code>KVExecutor</code> interacts with the abstract <code>Storage</code> interface, and how the call is routed to the correct implementation (<code>ResLevelDB</code> or <code>MemoryDB</code>).</p>
<h2><a class="anchor" id="autotoc_md140"></a>
Diving Deeper into Code</h2>
<p>Let's look at simplified versions of the implementations.</p>
<p><b><code>ResLevelDB</code> (Disk Storage):</b></p>
<p>This class wraps the actual LevelDB library (<code>leveldb::DB</code>).</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from chain/storage/leveldb.h and chain/storage/leveldb.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d6b/storage_8h.html">chain/storage/storage.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;leveldb/db.h&quot;</span> <span class="comment">// Include LevelDB&#39;s header</span></div>
<div class="line"><span class="preprocessor">#include &quot;leveldb/write_batch.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="../../d5/d10/namespaceresdb.html">resdb</a> {</div>
<div class="line"><span class="keyword">namespace </span>storage {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ResLevelDB : <span class="keyword">public</span> Storage { <span class="comment">// Inherits from Storage interface</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#a6e22825b820afcecc56c50a932a83021">ResLevelDB</a>(<span class="comment">/* ... path, config ... */</span>) {</div>
<div class="line">    <span class="comment">// Open the LevelDB database file at the given path</span></div>
<div class="line">    leveldb::Options options;</div>
<div class="line">    options.create_if_missing = <span class="keyword">true</span>;</div>
<div class="line">    leveldb::Status status = leveldb::DB::Open(options, path, &amp;db_ptr_);</div>
<div class="line">    <span class="comment">// Handle errors...</span></div>
<div class="line">    db_ = std::unique_ptr&lt;leveldb::DB&gt;(db_ptr_); <span class="comment">// Manage DB pointer</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Implement SetValue using LevelDB</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#a8292adeea1801c40b56dd31e0f057718">SetValue</a>(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Add the operation to a batch for efficiency</span></div>
<div class="line">    batch_.Put(key, value);</div>
<div class="line">    <span class="comment">// Maybe write the batch to disk if it&#39;s full enough</span></div>
<div class="line">    <span class="keywordflow">if</span> (batch_.ApproximateSize() &gt;= write_batch_size_) {</div>
<div class="line">       leveldb::Status status = db_-&gt;Write(leveldb::WriteOptions(), &amp;batch_);</div>
<div class="line">       <span class="comment">// Handle status, clear batch_ on success</span></div>
<div class="line">       <span class="keywordflow">return</span> status.ok() ? 0 : -1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0; <span class="comment">// Success (batched)</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Implement GetValue using LevelDB</span></div>
<div class="line">  std::string <a class="code hl_function" href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#ab727b1a4df6ea5487f68f05f10ab8916">GetValue</a>(<span class="keyword">const</span> std::string&amp; key)<span class="keyword"> override </span>{</div>
<div class="line">    std::string value;</div>
<div class="line">    leveldb::Status status = db_-&gt;Get(leveldb::ReadOptions(), key, &amp;value);</div>
<div class="line">    <span class="keywordflow">return</span> status.ok() ? value : <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// Return value or empty if not found</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::unique_ptr&lt;leveldb::DB&gt; db_; <span class="comment">// Pointer to the actual LevelDB object</span></div>
<div class="line">  leveldb::WriteBatch batch_;      <span class="comment">// Buffer for writes</span></div>
<div class="line">  <span class="comment">// ... other members like config ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Factory function to create a LevelDB storage instance</span></div>
<div class="line">std::unique_ptr&lt;Storage&gt; <a class="code hl_function" href="../../dd/dae/namespaceresdb_1_1storage.html#a52f999f3e613d6732418a58dfd4a0a7e">NewResLevelDB</a>(<span class="keyword">const</span> std::string&amp; path, ...) {</div>
<div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;ResLevelDB&gt;(path, ...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace storage</span></div>
<div class="line">} <span class="comment">// namespace resdb</span></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1ResLevelDB_html_a6e22825b820afcecc56c50a932a83021"><div class="ttname"><a href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#a6e22825b820afcecc56c50a932a83021">resdb::storage::ResLevelDB::ResLevelDB</a></div><div class="ttdeci">ResLevelDB(std::optional&lt; LevelDBInfo &gt; config_data=std::nullopt)</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d4e/leveldb_8cpp_source.html#l00046">leveldb.cpp:46</a></div></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1ResLevelDB_html_a8292adeea1801c40b56dd31e0f057718"><div class="ttname"><a href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#a8292adeea1801c40b56dd31e0f057718">resdb::storage::ResLevelDB::SetValue</a></div><div class="ttdeci">int SetValue(const std::string &amp;key, const std::string &amp;value) override</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d4e/leveldb_8cpp_source.html#l00161">leveldb.cpp:161</a></div></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1ResLevelDB_html_ab727b1a4df6ea5487f68f05f10ab8916"><div class="ttname"><a href="../../d3/d39/classresdb_1_1storage_1_1ResLevelDB.html#ab727b1a4df6ea5487f68f05f10ab8916">resdb::storage::ResLevelDB::GetValue</a></div><div class="ttdeci">std::string GetValue(const std::string &amp;key) override</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d4e/leveldb_8cpp_source.html#l00181">leveldb.cpp:181</a></div></div>
<div class="ttc" id="anamespaceresdb_1_1storage_html_a52f999f3e613d6732418a58dfd4a0a7e"><div class="ttname"><a href="../../dd/dae/namespaceresdb_1_1storage.html#a52f999f3e613d6732418a58dfd4a0a7e">resdb::storage::NewResLevelDB</a></div><div class="ttdeci">std::unique_ptr&lt; Storage &gt; NewResLevelDB(const std::string &amp;path, std::optional&lt; LevelDBInfo &gt; config)</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d4e/leveldb_8cpp_source.html#l00033">leveldb.cpp:33</a></div></div>
</div><!-- fragment --><p>This shows <code>ResLevelDB</code> implementing <code>SetValue</code> and <code>GetValue</code> by calling the corresponding methods on the underlying <code>leveldb::DB</code> object. It uses a <code>WriteBatch</code> to group multiple writes together before sending them to the disk, which is much more efficient.</p>
<p><b><code>MemoryDB</code> (Memory Storage):</b></p>
<p>This implementation is much simpler, using standard C++ maps.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from chain/storage/memory_db.h and chain/storage/memory_db.cpp</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d8/d6b/storage_8h.html">chain/storage/storage.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span> <span class="comment">// Use a hash map for key-value storage</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="../../d5/d10/namespaceresdb.html">resdb</a> {</div>
<div class="line"><span class="keyword">namespace </span>storage {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MemoryDB : <span class="keyword">public</span> Storage { <span class="comment">// Inherits from Storage interface</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#a0dc9b3a6a890cd54a9c493103013ec09">MemoryDB</a>() {} <span class="comment">// Constructor is simple</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Implement SetValue using an in-memory map</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#abef9cd0ffd55a2ef9edf54b4e543cf73">SetValue</a>(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Just insert or update the key in the map</span></div>
<div class="line">    kv_map_[key] = value;</div>
<div class="line">    <span class="keywordflow">return</span> 0; <span class="comment">// Always succeeds in this simple model</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Implement GetValue using an in-memory map</span></div>
<div class="line">  std::string <a class="code hl_function" href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#a1b491fc064a42b63a48c2792286f8b3e">GetValue</a>(<span class="keyword">const</span> std::string&amp; key)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keyword">auto</span> it = kv_map_.find(key); <span class="comment">// Search the map</span></div>
<div class="line">    <span class="keywordflow">if</span> (it != kv_map_.end()) {</div>
<div class="line">      <span class="keywordflow">return</span> it-&gt;second; <span class="comment">// Found: return the value</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>; <span class="comment">// Not found: return empty string</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// The actual storage: a map from string keys to string values</span></div>
<div class="line">  std::unordered_map&lt;std::string, std::string&gt; kv_map_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Factory function to create a MemoryDB storage instance</span></div>
<div class="line">std::unique_ptr&lt;Storage&gt; <a class="code hl_function" href="../../dd/dae/namespaceresdb_1_1storage.html#af746efcdd125b19e8c880e4712fc6a51">NewMemoryDB</a>() {</div>
<div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;MemoryDB&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace storage</span></div>
<div class="line">} <span class="comment">// namespace resdb</span></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1MemoryDB_html_a0dc9b3a6a890cd54a9c493103013ec09"><div class="ttname"><a href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#a0dc9b3a6a890cd54a9c493103013ec09">resdb::storage::MemoryDB::MemoryDB</a></div><div class="ttdeci">MemoryDB()</div><div class="ttdef"><b>Definition</b> <a href="../../dc/dee/memory__db_8cpp_source.html#l00029">memory_db.cpp:29</a></div></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1MemoryDB_html_a1b491fc064a42b63a48c2792286f8b3e"><div class="ttname"><a href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#a1b491fc064a42b63a48c2792286f8b3e">resdb::storage::MemoryDB::GetValue</a></div><div class="ttdeci">std::string GetValue(const std::string &amp;key) override</div><div class="ttdef"><b>Definition</b> <a href="../../dc/dee/memory__db_8cpp_source.html#l00051">memory_db.cpp:51</a></div></div>
<div class="ttc" id="aclassresdb_1_1storage_1_1MemoryDB_html_abef9cd0ffd55a2ef9edf54b4e543cf73"><div class="ttname"><a href="../../da/d75/classresdb_1_1storage_1_1MemoryDB.html#abef9cd0ffd55a2ef9edf54b4e543cf73">resdb::storage::MemoryDB::SetValue</a></div><div class="ttdeci">int SetValue(const std::string &amp;key, const std::string &amp;value) override</div><div class="ttdef"><b>Definition</b> <a href="../../dc/dee/memory__db_8cpp_source.html#l00031">memory_db.cpp:31</a></div></div>
<div class="ttc" id="anamespaceresdb_1_1storage_html_af746efcdd125b19e8c880e4712fc6a51"><div class="ttname"><a href="../../dd/dae/namespaceresdb_1_1storage.html#af746efcdd125b19e8c880e4712fc6a51">resdb::storage::NewMemoryDB</a></div><div class="ttdeci">std::unique_ptr&lt; Storage &gt; NewMemoryDB()</div><div class="ttdef"><b>Definition</b> <a href="../../dc/dee/memory__db_8cpp_source.html#l00027">memory_db.cpp:27</a></div></div>
</div><!-- fragment --><p>Here, <code>SetValue</code> just assigns the value to the key in the <code>kv_map_</code>, and <code>GetValue</code> looks up the key in the map. It's fast but, crucially, <code>kv_map_</code> exists only in RAM and disappears when the program stops.</p>
<h2><a class="anchor" id="autotoc_md141"></a>
Choosing Your Storage</h2>
<p>So, which one should you use?</p>
<ul>
<li>For <b>production deployments</b> where you need your data to be safe and survive restarts, you'll almost always use <code>ResLevelDB</code>.</li>
<li>For <b>unit testing</b> components like <code>KVExecutor</code>, using <code>MemoryDB</code> can make tests much faster as they don't need to read/write from the disk.</li>
<li>For <b>performance testing</b> or specific applications where maximum speed is needed and persistence isn't the top priority, <code>MemoryDB</code> might be considered.</li>
</ul>
<p>How do you tell ResilientDB which storage to use? This is typically done through configuration files, which we'll explore in Chapter 8: ResilientDB Configuration (ResDBConfig).</p>
<h2><a class="anchor" id="autotoc_md142"></a>
Conclusion</h2>
<p>You've now learned about the Storage Layer, the foundation where ResilientDB keeps its data!</p>
<ul>
<li>We saw that the Storage Layer acts as the <b>filing cabinet or hard drive</b>, responsible for saving and retrieving the blockchain state.</li>
<li>The <b><code>Storage</code> interface</b> provides a standard blueprint for storage operations (<code>SetValue</code>, <code>GetValue</code>).</li>
<li><b><code>ResLevelDB</code></b> is an implementation using LevelDB for <b>persistent disk storage</b> (durable but slower).</li>
<li><b><code>MemoryDB</code></b> is an implementation using in-memory maps for <b>fast, temporary storage</b> (quick but data lost on restart).</li>
<li>Components like <code>KVExecutor</code> interact with the <code>Storage</code> interface, allowing them to work with either disk or memory storage without changing their own code.</li>
</ul>
<p>Now that we know how data is stored, how does ResilientDB ensure that even if a replica crashes, it can recover its state correctly? How does it periodically save snapshots of its state to avoid replaying the entire transaction history from the beginning? That's where Checkpointing and Recovery come in, the topic of our next chapter!</p>
<p><b>Next:</b> <a class="el" href="../../d8/d9e/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_207__checkpointing.html">Chapter 7: Checkpointing &amp; Recovery</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
