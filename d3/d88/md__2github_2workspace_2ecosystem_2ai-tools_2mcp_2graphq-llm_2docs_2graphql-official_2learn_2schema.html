#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: schema</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d88/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2schema.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">schema</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>import { Callout } from "nextra/components"</p>
<h1><a class="anchor" id="autotoc_md992"></a>
Schemas and Types</h1>
<p>Learn about the different elements of the GraphQL type system</p>
<p>The GraphQL <a href="https://spec.graphql.org/draft/#sec-Type-System">type system</a> describes what data can be queried from the API. The collection of those capabilities is referred to as the service's <em>schema</em> and clients can use that schema to send queries to the API that return predictable results.</p>
<p>On this page, we'll explore GraphQL's <a href="https://spec.graphql.org/draft/#sec-Types">six kinds of named type definitions</a> as well as other features of the type system to learn how they may be used to describe your data and the relationships between them. Since GraphQL can be used with any backend framework or programming language, we'll avoid implementation-specific details and talk only about the concepts.</p>
<h2><a class="anchor" id="autotoc_md993"></a>
Type system</h2>
<p>If you've seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    appearsIn</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li>We start with a special "root" object</li>
<li>We select the <code>hero</code> field on that</li>
<li>For the object returned by <code>hero</code>, we select the <code>name</code> and <code>appearsIn</code> fields</li>
</ol>
<p>Because the shape of a GraphQL query closely matches the result, we can predict what the query will return without knowing that much about the server. But it's useful to have an exact description of the data we can request. For example, what fields can we select? What kinds of objects might they return? What fields are available on those sub-objects?</p>
<p>That's where the schema comes in. Every GraphQL service defines a set of types that completely describe the set of possible data we can query on that service. Then, when requests come in, they are validated and executed against that schema.</p>
<h2><a class="anchor" id="autotoc_md994"></a>
Type language</h2>
<p>GraphQL services can be written in any language and there are many different approaches you can take when defining the types in a schema:</p>
<ul>
<li>Some libraries have you construct the schema types, fields, and resolver functions together using the same programming language that was used to write the GraphQL implementation.</li>
<li>Some libraries allow you to define types and fields more ergonomically using what's commonly called the schema definition language (or SDL) and then write the resolver functions for the corresponding fields separately.</li>
<li>Some libraries allow you to write and annotate the resolver functions, and then infer the schema from that.</li>
<li>Some libraries may even infer both the types and resolver functions for you, based on some underlying data source(s).</li>
</ul>
<p>Since we can't rely on a specific programming language to discuss GraphQL schemas in this guide, we'll use SDL because it's similar to the query language that we've seen so far and allows us to talk about GraphQL schemas in a language-agnostic way.</p>
<h2><a class="anchor" id="autotoc_md995"></a>
Object types and fields</h2>
<p>The most basic components of a GraphQL schema are <a href="https://spec.graphql.org/draft/#sec-Objects">Object types</a>, which just represent a kind of object you can fetch from your service, and what fields it has. In SDL, we represent it like this:</p>
<div class="fragment"><div class="line">type Character {</div>
<div class="line">  name: String!</div>
<div class="line">  appearsIn: [Episode!]!</div>
<div class="line">}</div>
</div><!-- fragment --><p>The language is readable, but let's go over it so that we can have a shared vocabulary:</p>
<ul>
<li><code>Character</code> is a GraphQL Object type, meaning it's a type with some fields. Most of the types in your schema will be Object types.</li>
<li><code>name</code> and <code>appearsIn</code> are fields on the <code>Character</code> type. That means that <code>name</code> and <code>appearsIn</code> are the only fields that can appear in any part of a GraphQL query that operates on the <code>Character</code> type.</li>
<li><code>String</code> is one of the built-in Scalar types. These are types that resolve to a single scalar value and can't have sub-selections in the query. We'll go over Scalar types more later.</li>
<li><code>String!</code> means that the field is a Non-Null type, meaning the GraphQL service promises to give you a value whenever you query this field. In SDL, we represent those with an exclamation mark.</li>
<li><code>[Episode!]!</code> represents a List type of <code>Episode</code> objects. When a List is Non-Null, you can always expect an array (with zero or more items) when you query the <code>appearsIn</code> field. In this case, since <code>Episode!</code> is also Non-Null within the list, you can always expect every item in the array to be an <code>Episode</code> object.</li>
</ul>
<p>Now you know what a GraphQL Object type looks like and how to read the basics of SDL.</p>
<h3><a class="anchor" id="autotoc_md996"></a>
Arguments</h3>
<p>Every field on a GraphQL Object type can have zero or more <a href="https://spec.graphql.org/draft/#sec-Field-Arguments">arguments</a>, for example, the <code>length</code> field below:</p>
<div class="fragment"><div class="line">type Starship {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  length(unit: LengthUnit = METER): Float</div>
<div class="line">}</div>
</div><!-- fragment --><p>All arguments are named. Unlike languages such as JavaScript and Python where functions take a list of ordered arguments, all arguments in GraphQL are passed by name specifically. In this case, the <code>length</code> field has one defined argument called <code>unit</code>.</p>
<p>Arguments can be either required or optional. When an argument is optional, we can define a <em>default value</em>. If the <code>unit</code> argument is not passed, then it will be set to <code>METER</code> by default.</p>
<h3><a class="anchor" id="autotoc_md997"></a>
The Query, Mutation, and Subscription types</h3>
<p>Every GraphQL schema must support <code>query</code> operations. The <em>entry point</em> for this <a href="https://spec.graphql.org/draft/#sec-Root-Operation-Types">root operation type</a> is a regular Object type called <code>Query</code> by default. So if you see a query that looks like this:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  droid(id: &quot;2000&quot;) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>That means that the GraphQL service needs to have a <code>Query</code> type with a <code>droid</code> field:</p>
<div class="fragment"><div class="line">type Query {</div>
<div class="line">  droid(id: ID!): Droid</div>
<div class="line">}</div>
</div><!-- fragment --><p>Schemas may also support <code>mutation</code> and <code>subscription</code> operations by adding additional <code>Mutation</code> and <code>Subscription</code> types and then defining fields on the corresponding root operation types.</p>
<p>It's important to remember that other than the special status of being entry points into the schema, the <code>Query</code>, <code>Mutation</code>, and <code>Subscription</code> types are the same as any other GraphQL Object type, and their fields work exactly the same way.</p>
<p>You can name your root operation types differently too; if you choose to do so then you will need to inform GraphQL of the new names using the <code>schema</code> keyword:</p>
<div class="fragment"><div class="line">schema {</div>
<div class="line">  query: MyQueryType</div>
<div class="line">  mutation: MyMutationType</div>
<div class="line">  subscription: MySubscriptionType</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md998"></a>
Scalar types</h2>
<p>A GraphQL Object type has a name and fields, but at some point, those fields must resolve to some concrete data. That's where the <a href="https://spec.graphql.org/draft/#sec-Scalars">Scalar types</a> come in: they represent the leaf values of the query.</p>
<p>In the following query, the <code>name</code> and <code>appearsIn</code> fields will resolve to Scalar types:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    appearsIn</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We know this because those fields don't have any sub-fields—they are the leaves of the query.</p>
<p>GraphQL comes with a set of <a href="https://spec.graphql.org/draft/#sec-Scalars.Built-in-Scalars">default Scalar types</a> out of the box:</p>
<ul>
<li><code>Int</code>: A signed 32‐bit integer.</li>
<li><code>Float</code>: A signed double-precision floating-point value.</li>
<li><code>String</code>: A UTF‐8 character sequence.</li>
<li><code>Boolean</code>: <code>true</code> or <code>false</code>.</li>
<li><code>ID</code>: A unique identifier, often used to refetch an object or as the key for a cache. The <code>ID</code> type is serialized in the same way as a <code>String</code>; however, defining it as an <code>ID</code> signifies that it is not intended to be human‐readable.</li>
</ul>
<p>In most GraphQL service implementations, there is also a way to specify custom Scalar types. For example, we could define a <code>Date</code> type:</p>
<div class="fragment"><div class="line">scalar Date</div>
</div><!-- fragment --><p>Then it's up to our implementation to define how that type should be serialized, deserialized, and validated. For example, you could specify that the <code>Date</code> type should always be serialized into an integer timestamp, and your client should know to expect that format for any date fields.</p>
<h2><a class="anchor" id="autotoc_md999"></a>
Enum types</h2>
<p><a href="https://spec.graphql.org/draft/#sec-Enums">Enum types</a>, also known as enumeration types, are a special kind of scalar that is restricted to a particular set of allowed values. This allows you to:</p>
<ol type="1">
<li>Validate that any arguments of this type are one of the allowed values</li>
<li>Communicate through the type system that a field will always be one of a finite set of values</li>
</ol>
<p>Here's what an Enum type definition looks like in SDL:</p>
<div class="fragment"><div class="line">enum Episode {</div>
<div class="line">  NEWHOPE</div>
<div class="line">  EMPIRE</div>
<div class="line">  JEDI</div>
<div class="line">}</div>
</div><!-- fragment --><p>This means that wherever we use the type <code>Episode</code> in our schema, we expect it to be exactly one of <code>NEWHOPE</code>, <code>EMPIRE</code>, or <code>JEDI</code>.</p>
<p>&lt;Callout type="info"&gt;GraphQL service implementations in various languages will have a language-specific way of dealing with Enum types. In languages that support enums as a first-class citizen, the implementation might take advantage of that; in a language like JavaScript with no enum support, these values might be internally mapped to a set of integers. However, these details don't leak out to the client, which can operate entirely in terms of the string names of the Enum type's values.&lt;/Callout&gt;</p>
<h2><a class="anchor" id="autotoc_md1000"></a>
Type modifiers</h2>
<p>Types are assumed to be nullable and singular by default in GraphQL. However, when you use these named types in a schema (or in <a href="../..//learn/queries/#variables">query variable declarations</a>) you can apply additional <em>type modifiers</em> that will affect the meaning of those values.</p>
<p>As we saw with the Object type example above, GraphQL supports two type modifiers—the <a href="https://spec.graphql.org/draft/#sec-List">List</a> and <a href="https://spec.graphql.org/draft/#sec-Non-Null">Non-Null</a> types—and they can be used individually or in combination with each other.</p>
<h3><a class="anchor" id="autotoc_md1001"></a>
Non-Null</h3>
<p>Let's look at an example:</p>
<div class="fragment"><div class="line">type Character {</div>
<div class="line">  name: String!</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, we're using a <code>String</code> type and marking it as a Non-Null type by adding an exclamation mark (<code>!</code>) after the type name. This means that our server always expects to return a non-null value for this field, and if the resolver produces a null value, then that will trigger a GraphQL execution error, letting the client know that something has gone wrong.</p>
<p>As we saw in an example above, the Non-Null type modifier can also be used when defining arguments for a field, which will cause the GraphQL server to return a validation error if a null value is passed as that argument:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  droid(id: null) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1002"></a>
List</h3>
<p>Lists work in a similar way. We can use a type modifier to mark a type as a List type, which indicates that this field will return an array of that type. In SDL, this is denoted by wrapping the type in square brackets, <code>[</code> and <code>]</code>. It works the same for arguments, where the validation step will expect an array for that value. Here's an example:</p>
<div class="fragment"><div class="line">type Character {</div>
<div class="line">  name: String!</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">}</div>
</div><!-- fragment --><p>As we see above, the Non-Null and List modifiers can be combined. For example, you can have a List of Non-Null <code>String</code> types:</p>
<p>{/* */} </p><div class="fragment"><div class="line">myField: [String!]</div>
</div><!-- fragment --><p>This means that the <em>list itself</em> can be null, but it can't have any null members. For example, in JSON:</p>
<div class="fragment"><div class="line">myField: null // valid</div>
<div class="line">myField: [] // valid</div>
<div class="line">myField: [&quot;a&quot;, &quot;b&quot;] // valid</div>
<div class="line">myField: [&quot;a&quot;, null, &quot;b&quot;] // error</div>
</div><!-- fragment --><p>Now, let's say we defined a Non-Null List of <code>String</code> types:</p>
<p>{/* */} </p><div class="fragment"><div class="line">myField: [String]!</div>
</div><!-- fragment --><p>This means that the list itself cannot be null, but it can contain null values:</p>
<div class="fragment"><div class="line">myField: null // error</div>
<div class="line">myField: [] // valid</div>
<div class="line">myField: [&quot;a&quot;, &quot;b&quot;] // valid</div>
<div class="line">myField: [&quot;a&quot;, null, &quot;b&quot;] // valid</div>
</div><!-- fragment --><p>Lastly, you can also have a Non-Null List of Non-Null <code>String</code> types:</p>
<p>{/* */} </p><div class="fragment"><div class="line">myField: [String!]!</div>
</div><!-- fragment --><p>This means that the list cannot be null and it cannot contain null values:</p>
<div class="fragment"><div class="line">myField: null // error</div>
<div class="line">myField: [] // valid</div>
<div class="line">myField: [&quot;a&quot;, &quot;b&quot;] // valid</div>
<div class="line">myField: [&quot;a&quot;, null, &quot;b&quot;] // error</div>
</div><!-- fragment --><p>You can arbitrarily nest any number of Non-Null and List modifiers, according to your needs.</p>
<p>&lt;Callout type="info"&gt;In GraphQL, there is no way to define a type so that the field's data will only be considered valid if a non-empty list is provided. In other words, <code>[]</code> would still be a valid response for a Non-Null List of a Non-Null type.&lt;/Callout&gt;</p>
<h2><a class="anchor" id="autotoc_md1003"></a>
Interface types</h2>
<p>Like many type systems, GraphQL supports <em>abstract types</em>. The first of these types that we'll explore is an <a href="https://spec.graphql.org/draft/#sec-Interfaces">Interface type</a>, which defines a certain set of fields that a concrete Object type or other Interface type must also include to implement it.</p>
<p>For example, you could have a <code>Character</code> Interface type that represents any character in the Star Wars trilogy:</p>
<div class="fragment"><div class="line">interface Character {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  friends: [Character]</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">}</div>
</div><!-- fragment --><p>This means that any type that <em>implements</em> <code>Character</code> needs to have these exact fields as well as the same arguments and return types.</p>
<p>For example, here are some types that might implement <code>Character</code>:</p>
<div class="fragment"><div class="line">type Human implements Character {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  friends: [Character]</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">  starships: [Starship]</div>
<div class="line">  totalCredits: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Droid implements Character {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  friends: [Character]</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">  primaryFunction: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can see that both of these types have all of the fields from the <code>Character</code> Interface type, but also bring in extra fields—<code>totalCredits</code>, <code>starships</code> and <code>primaryFunction</code>—that are specific to that particular type of character.</p>
<p>Interface types are useful when you want to return an object or set of objects, but those might be of several different types. For example, note that the following query produces an error:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  hero(episode: JEDI) {</div>
<div class="line">    name</div>
<div class="line">    primaryFunction</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>hero</code> field returns the type <code>Character</code>, which means it might be either a <code>Human</code> or a <code>Droid</code> depending on the <code>episode</code> argument. In the query above, you can only ask for fields that exist on the <code>Character</code> Interface type, which doesn't include <code>primaryFunction</code>.</p>
<p>To ask for a field on a specific Object type, you need to use an <a href="../..//learn/queries/#inline-fragments">inline fragment</a>:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  hero(episode: JEDI) {</div>
<div class="line">    name</div>
<div class="line">    ... on Droid {</div>
<div class="line">      primaryFunction</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Interface types may also implement other Interface types:</p>
<div class="fragment"><div class="line">interface Node {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Character implements Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  friends: [Character]</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that Interface types may not implement themselves or contain any cyclic references to each other.</p>
<p>&lt;Callout type="info"&gt;While types may share common fields in a GraphQL API, that may not always warrant the use of an Interface type to enforce that those fields remain consistently named. Interface types are a powerful way to indicate shared behavior across the types that implement them. When used, they should be semantically meaningful to client developers, just like <code>Character</code> is a useful abstraction for humans and droids.&lt;/Callout&gt;</p>
<h2><a class="anchor" id="autotoc_md1004"></a>
Union types</h2>
<p>GraphQL supports a second abstract type called a <a href="https://spec.graphql.org/draft/#sec-Unions">Union type</a>. Union types share similarities with Interface types, but they cannot define any shared fields among the constituent types.</p>
<p>A Union type is defined by indicating its member Object types:</p>
<div class="fragment"><div class="line">union SearchResult = Human | Droid | Starship</div>
</div><!-- fragment --><p>Wherever we return a <code>SearchResult</code> type in our schema, we might get a <code>Human</code>, a <code>Droid</code>, or a <code>Starship</code>. Note that members of a Union type need to be concrete Object types; you can't define one using Interface types or other Union types as members.</p>
<p>In this case, if you query a field that returns the <code>SearchResult</code> Union type, you need to use an <a href="../..//learn/queries/#inline-fragments">inline fragment</a> to be able to query any fields that are defined on the member Object types:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true}</div>
<div class="line">{</div>
<div class="line">  search(text: &quot;an&quot;) {</div>
<div class="line">    __typename</div>
<div class="line">    ... on Human {</div>
<div class="line">      name</div>
<div class="line">      height</div>
<div class="line">    }</div>
<div class="line">    ... on Droid {</div>
<div class="line">      name</div>
<div class="line">      primaryFunction</div>
<div class="line">    }</div>
<div class="line">    ... on Starship {</div>
<div class="line">      name</div>
<div class="line">      length</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>__typename</code> field is a special <em>meta-field</em> that automatically exists on every Object type and resolves to the name of that type, providing a way to differentiate between data types on the client.</p>
<p>Also, in this case, since <code>Human</code> and <code>Droid</code> share a common interface (<code>Character</code>), you can query their common fields in one place and still get the same result:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true}</div>
<div class="line">{</div>
<div class="line">  search(text: &quot;an&quot;) {</div>
<div class="line">    __typename</div>
<div class="line">    ... on Character {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">    ... on Human {</div>
<div class="line">      height</div>
<div class="line">    }</div>
<div class="line">    ... on Droid {</div>
<div class="line">      primaryFunction</div>
<div class="line">    }</div>
<div class="line">    ... on Starship {</div>
<div class="line">      name</div>
<div class="line">      length</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that <code>name</code> is still specified on <code>Starship</code> because otherwise it wouldn't show up in the results given that <code>Starship</code> is not a <code>Character</code>!</p>
<h2><a class="anchor" id="autotoc_md1005"></a>
Input Object types</h2>
<p>Most of the examples we've covered on this page demonstrate how Object, Scalar, Enum, Interface, and Union types may be used as <em>output types</em> for the fields in a schema. But we have also seen that field arguments must specify their <em>input types</em>.</p>
<p>So far, we've only talked about using scalar values (like Enums or String types) as an input type for a field argument. However, you can also pass complex objects as arguments using an <a href="https://spec.graphql.org/draft/#sec-Input-Objects">Input Object type</a>, which is the last kind of named types in GraphQL that we'll explore.</p>
<p>This is particularly valuable in the case of <a href="../..//learn/mutations/">mutations</a>, where you might want to pass in a whole object to be created. In SDL, Input Object types look similar to regular Object types, but with the keyword <code>input</code> instead of <code>type</code>:</p>
<div class="fragment"><div class="line">input ReviewInput {</div>
<div class="line">  stars: Int!</div>
<div class="line">  commentary: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Mutation {</div>
<div class="line">  createReview(episode: Episode, review: ReviewInput!): Review</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here is how you could use the Input Object type in a mutation:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">mutation {</div>
<div class="line">  createReview(</div>
<div class="line">    episode: JEDI, </div>
<div class="line">    review: {</div>
<div class="line">      stars: 5</div>
<div class="line">      commentary: &quot;This is a great movie!&quot;</div>
<div class="line">    }</div>
<div class="line">  ) {</div>
<div class="line">    stars</div>
<div class="line">    commentary</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The fields on an Input Object type can refer to other Input Object types, but you can't mix input and output types in your schema. Input Object types also can't have arguments on their fields.</p>
<h2><a class="anchor" id="autotoc_md1006"></a>
Directives</h2>
<p>In certain instances where field arguments are insufficient or certain common behaviors must be replicated in multiple locations, <a href="https://spec.graphql.org/draft/#sec-Type-System.Directives">directives</a> allow us to modify parts of a GraphQL schema or operation by using an <code>@</code> character followed by the directive's name.</p>
<p><em>Type system directives</em> allow us to annotate the types, fields, and arguments in a schema so that they may be validated or executed differently.</p>
<p>&lt;Callout type="info"&gt; Directives may also be defined for use in GraphQL operations as <em>executable directives</em>. <a href="../..//learn/queries/#directives">Read more about executable directives on the Queries page.</a> &lt;/Callout&gt;</p>
<p>The GraphQL specification defines several <a href="https://spec.graphql.org/draft/#sec-Type-System.Directives.Built-in-Directives">built-in directives</a>. For example, for implementations that support SDL, the <code>@deprecated</code> directive will be available to annotate deprecated parts of the schema:</p>
<div class="fragment"><div class="line">type User {</div>
<div class="line">  fullName: String</div>
<div class="line">  name: String @deprecated(reason: &quot;Use `fullName`.&quot;)</div>
<div class="line">}</div>
</div><!-- fragment --><p>While you won't need to define the <code>@deprecated</code> directive in your schema explicitly if you're using a GraphQL implementation that supports SDL, it's underlying definition would look like this:</p>
<div class="fragment"><div class="line">directive @deprecated(</div>
<div class="line">  reason: String = &quot;No longer supported&quot;</div>
<div class="line">) on FIELD_DEFINITION | ENUM_VALUE</div>
</div><!-- fragment --><p>Note that, just like fields, directives can accept arguments and those arguments can have default values. The <code>@deprecated</code> directive has a nullable <code>reason</code> argument that accepts a <code>String</code> as an input type and falls back to <code>"No longer supported"</code>. And with directives, we must specify where they may be used, such as on a <code>FIELD_DEFINITION</code> or <code>ENUM_VALUE</code> for the <code>@deprecated</code> directive.</p>
<p>In addition to GraphQL's built-in directives, you may define your own <em>custom directives</em>. As with custom Scalar types, it's up to your chosen GraphQL implementation to determine how to handle custom directives during query execution.</p>
<h2><a class="anchor" id="autotoc_md1007"></a>
Documentation</h2>
<h3><a class="anchor" id="autotoc_md1008"></a>
Descriptions</h3>
<p>GraphQL allows you to add documentation to the types, fields, and arguments in a schema. In fact, the GraphQL specification encourages you to do this in all cases unless the name of the type, field, or argument is self-descriptive. Schema descriptions are defined using Markdown syntax and can be multiline or single line.</p>
<p>In SDL, they would look like this:</p>
<div class="fragment"><div class="line">&quot;&quot;&quot;</div>
<div class="line">A character from the Star Wars universe</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">type Character {</div>
<div class="line">  &quot;The name of the character.&quot;</div>
<div class="line">  name: String!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">The episodes in the Star Wars trilogy</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">enum Episode {</div>
<div class="line">  &quot;Star Wars Episode IV: A New Hope, released in 1977.&quot; </div>
<div class="line">  NEWHOPE</div>
<div class="line">  &quot;Star Wars Episode V: The Empire Strikes Back, released in 1980.&quot;</div>
<div class="line">  EMPIRE</div>
<div class="line">  &quot;Star Wars Episode VI: Return of the Jedi, released in 1983.&quot;</div>
<div class="line">  JEDI</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">The query type, represents all of the entry points into our object graph</div>
<div class="line">&quot;&quot;&quot;</div>
<div class="line">type Query {</div>
<div class="line">  &quot;&quot;&quot;</div>
<div class="line">  Fetches the hero of a specified Star Wars film.</div>
<div class="line">  &quot;&quot;&quot;</div>
<div class="line">  hero(</div>
<div class="line">    &quot;The name of the film that the hero appears in.&quot;</div>
<div class="line">    episode: Episode</div>
<div class="line">  ): Character</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to making a GraphQL API schema more expressive, descriptions are helpful to client developers because they are available in <a href="../..//learn/introspection/">introspection queries</a> and visible in developer tools such as <a href="https://github.com/graphql/graphiql">GraphiQL</a>.</p>
<h3><a class="anchor" id="autotoc_md1009"></a>
Comments</h3>
<p>Occasionally, you may need to add comments in a schema that do not describe types, fields, or arguments, and are not meant to be seen by clients. In those cases, you can add a single-line comment to SDL by preceding the text with a <code>#</code> character:</p>
<div class="fragment"><div class="line"># This line is treated like whitespace and ignored by GraphQL</div>
<div class="line">type Character {</div>
<div class="line">  name: String!</div>
<div class="line">}</div>
</div><!-- fragment --><p>Comments may also be added to client queries:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">{</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    # Queries can have comments!</div>
<div class="line">    friends {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1010"></a>
Next steps</h2>
<p>To recap what we've learned about schemas and types:</p>
<ul>
<li>Depending on what library is selected to build a GraphQL service, we can define a schema in a language-agnostic way using SDL or by compiling the schema from the code that provides data for its fields</li>
<li>There are six kinds of named type definitions in GraphQL: Object, Scalar, Enum, Interface, Union, and Input Object types</li>
<li>Object types contain fields that specify output types, and those fields may have arguments that specify input types</li>
<li>The <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, and <code>ID</code> Scalar types are built into GraphQL, and you can also define your own custom scalars</li>
<li>Like Scalar types, Enum types represent leaf values in a GraphQL schema but they are limited to a finite set of values</li>
<li>The List (<code>[]</code>) and Non-Null (<code>!</code>) type modifiers allow you to change the default behavior for a field's output type or argument's input type</li>
<li>Interface and Union types are abstract types that allow different concrete Object types to be output from a single field</li>
<li>Input Object types allow you to pass more complex values into a field argument or directive argument than Scalar and Enum types allow</li>
<li>Type system directives can be applied to the types, fields, and arguments in a schema to alter how they are validated and executed during a query</li>
<li>GraphQL supports schema documentation using type, field, and argument descriptions, and it also supports comments that are ignored by the parser</li>
</ul>
<p>Now that you understand the key features of the type system, you're ready to learn more about how to <a href="../..//learn/queries/">query data from a GraphQL API</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
