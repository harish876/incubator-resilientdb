#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: Section 5 &ndash; Validation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d5b/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-spec_2Section_015_01--_01Validation.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Section 5 &ndash; Validation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1131"></a>
Validation</h1>
<p>A GraphQL service does not just verify if a request is syntactically correct, but also ensures that it is unambiguous and mistake-free in the context of a given GraphQL schema.</p>
<p>An invalid request is still technically executable, and will always produce a stable result as defined by the algorithms in the Execution section, however that result may be ambiguous, surprising, or unexpected relative to a request containing validation errors, so execution should only occur for valid requests.</p>
<p>Typically validation is performed in the context of a request immediately before execution, however a GraphQL service may execute a request without explicitly validating it if that exact same request is known to have been validated before. For example: the request may be validated during development, provided it does not later change, or a service may validate a request once and memoize the result to avoid validating the same request again in the future. Any client-side or development-time tool should report validation errors and not allow the formulation or execution of requests known to be invalid at that given point in time.</p>
<p><b>Type System Evolution</b></p>
<p>As GraphQL type system schema evolves over time by adding new types and new fields, it is possible that a request which was previously valid could later become invalid. Any change that can cause a previously valid request to become invalid is considered a <em>breaking change</em>. GraphQL services and schema maintainers are encouraged to avoid breaking changes, however in order to be more resilient to these breaking changes, sophisticated GraphQL systems may still allow for the execution of requests which <em>at some point</em> were known to be free of any validation errors, and have not changed since.</p>
<p><b>Examples</b></p>
<p>The examples in this section will use the following types:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Query {</div>
<div class="line">  dog: Dog</div>
<div class="line">  findDog(searchBy: FindDogInput): Dog</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Mutation {</div>
<div class="line">  addPet(pet: PetInput!): Pet</div>
<div class="line">  addPets(pets: [PetInput!]!): [Pet]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">enum DogCommand {</div>
<div class="line">  SIT</div>
<div class="line">  DOWN</div>
<div class="line">  HEEL</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Dog implements Pet {</div>
<div class="line">  name: String!</div>
<div class="line">  nickname: String</div>
<div class="line">  barkVolume: Int</div>
<div class="line">  doesKnowCommand(dogCommand: DogCommand!): Boolean!</div>
<div class="line">  isHouseTrained(atOtherHomes: Boolean): Boolean!</div>
<div class="line">  owner: Human</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Sentient {</div>
<div class="line">  name: String!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Pet {</div>
<div class="line">  name: String!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Alien implements Sentient {</div>
<div class="line">  name: String!</div>
<div class="line">  homePlanet: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Human implements Sentient {</div>
<div class="line">  name: String!</div>
<div class="line">  pets: [Pet!]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">enum CatCommand {</div>
<div class="line">  JUMP</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Cat implements Pet {</div>
<div class="line">  name: String!</div>
<div class="line">  nickname: String</div>
<div class="line">  doesKnowCommand(catCommand: CatCommand!): Boolean!</div>
<div class="line">  meowVolume: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">union CatOrDog = Cat | Dog</div>
<div class="line">union DogOrHuman = Dog | Human</div>
<div class="line">union HumanOrAlien = Human | Alien</div>
<div class="line"> </div>
<div class="line">input FindDogInput {</div>
<div class="line">  name: String</div>
<div class="line">  owner: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input CatInput {</div>
<div class="line">  name: String!</div>
<div class="line">  nickname: String</div>
<div class="line">  meowVolume: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input DogInput {</div>
<div class="line">  name: String!</div>
<div class="line">  nickname: String</div>
<div class="line">  barkVolume: Int</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input PetInput @oneOf {</div>
<div class="line">  cat: CatInput</div>
<div class="line">  dog: DogInput</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1132"></a>
Documents</h2>
<h3><a class="anchor" id="autotoc_md1133"></a>
Executable Definitions</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each definition {definition} in the document:<ul>
<li>{definition} must be {ExecutableDefinition} (it must not be {TypeSystemDefinitionOrExtension}).</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>GraphQL execution will only consider the executable definitions Operation and Fragment. Type system definitions and extensions are not executable, and are not considered during execution.</p>
<p>To avoid ambiguity, a document containing {TypeSystemDefinitionOrExtension} is invalid for execution.</p>
<p>GraphQL documents not intended to be directly executed may include {TypeSystemDefinitionOrExtension}.</p>
<p>For example, the following document is invalid for execution since the original executing schema may not know about the provided type extension:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query getDogName {</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">    color</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extend type Dog {</div>
<div class="line">  color: String</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1134"></a>
Operations</h2>
<h3><a class="anchor" id="autotoc_md1135"></a>
All Operation Definitions</h3>
<h4><a class="anchor" id="autotoc_md1136"></a>
Operation Type Existence</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each operation definition {operation} in the document:<ul>
<li>Let {rootOperationType} be the <em>root operation type</em> in {schema} corresponding to the kind of {operation}.</li>
<li>{rootOperationType} must exist.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>A schema defines the <em>root operation type</em> for each kind of operation that it supports. Every schema must support <code>query</code> operations, however support for <code>mutation</code> and <code>subscription</code> operations is optional.</p>
<p>If the schema does not include the necessary <em>root operation type</em> for the kind of an operation defined in the document, that operation is invalid since it cannot be executed.</p>
<p>For example given the following schema:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Query {</div>
<div class="line">  hello: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following operation is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query helloQuery {</div>
<div class="line">  hello</div>
<div class="line">}</div>
</div><!-- fragment --><p>While the following operation is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">mutation goodbyeMutation {</div>
<div class="line">  goodbye</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1137"></a>
Named Operation Definitions</h3>
<h4><a class="anchor" id="autotoc_md1138"></a>
Operation Name Uniqueness</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each operation definition {operation} in the document:<ul>
<li>Let {operationName} be the name of {operation}.</li>
<li>If {operationName} exists:<ul>
<li>Let {operations} be all operation definitions in the document named {operationName}.</li>
<li>{operations} must be a set of one.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Each named operation definition must be unique within a document when referred to by its name.</p>
<p>For example the following document is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query getDogName {</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query getOwnerName {</div>
<div class="line">  dog {</div>
<div class="line">    owner {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While this document is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query getName {</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query getName {</div>
<div class="line">  dog {</div>
<div class="line">    owner {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is invalid even if the type of each operation is different:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query dogOperation {</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation dogOperation {</div>
<div class="line">  mutateDog {</div>
<div class="line">    id</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1139"></a>
Anonymous Operation Definitions</h3>
<h4><a class="anchor" id="autotoc_md1140"></a>
Lone Anonymous Operation</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>Let {operations} be all operation definitions in the document.</li>
<li>Let {anonymous} be all anonymous operation definitions in the document.</li>
<li>If {operations} is a set of more than 1:<ul>
<li>{anonymous} must be empty.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>GraphQL allows a shorthand form for defining query operations when only that one operation exists in the document.</p>
<p>For example the following document is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While this document is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query getName {</div>
<div class="line">  dog {</div>
<div class="line">    owner {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1141"></a>
Subscription Operation Definitions</h3>
<h4><a class="anchor" id="autotoc_md1142"></a>
Single Root Field</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>Let {subscriptionType} be the root Subscription type in {schema}.</li>
<li>For each subscription operation definition {subscription} in the document:<ul>
<li>Let {selectionSet} be the top level selection set on {subscription}.</li>
<li>Let {collectedFieldsMap} be the result of {CollectSubscriptionFields(subscriptionType, selectionSet)}.</li>
<li>{collectedFieldsMap} must have exactly one entry, which must not be an introspection field.</li>
</ul>
</li>
</ul>
<p>CollectSubscriptionFields(objectType, selectionSet, visitedFragments):</p>
<ul>
<li>If {visitedFragments} is not provided, initialize it to the empty set.</li>
<li>Initialize {collectedFieldsMap} to an empty ordered map of ordered sets.</li>
<li>For each {selection} in {selectionSet}:<ul>
<li>{selection} must not provide the <code>@skip</code> directive.</li>
<li>{selection} must not provide the <code>@include</code> directive.</li>
<li>If {selection} is a {Field}:<ul>
<li>Let {responseName} be the <em>response name</em> of {selection} (the alias if defined, otherwise the field name).</li>
<li>Let {fieldsForResponseKey} be the <em>field set</em> value in {collectedFieldsMap} for the key {responseName}; otherwise create the entry with an empty ordered set.</li>
<li>Add {selection} to the {fieldsForResponseKey}.</li>
</ul>
</li>
<li>If {selection} is a {FragmentSpread}:<ul>
<li>Let {fragmentSpreadName} be the name of {selection}.</li>
<li>If {fragmentSpreadName} is in {visitedFragments}, continue with the next {selection} in {selectionSet}.</li>
<li>Add {fragmentSpreadName} to {visitedFragments}.</li>
<li>Let {fragment} be the Fragment in the current Document whose name is {fragmentSpreadName}.</li>
<li>If no such {fragment} exists, continue with the next {selection} in {selectionSet}.</li>
<li>Let {fragmentType} be the type condition on {fragment}.</li>
<li>If {DoesFragmentTypeApply(objectType, fragmentType)} is {false}, continue with the next {selection} in {selectionSet}.</li>
<li>Let {fragmentSelectionSet} be the top-level selection set of {fragment}.</li>
<li>Let {fragmentCollectedFieldsMap} be the result of calling {CollectSubscriptionFields(objectType, fragmentSelectionSet,
      visitedFragments)}.</li>
<li>For each {responseName} and {fragmentFields} in {fragmentCollectedFieldsMap}:<ul>
<li>Let {fieldsForResponseKey} be the <em>field set</em> value in {collectedFieldsMap} for the key {responseName}; otherwise create the entry with an empty ordered set.</li>
<li>Add each item from {fragmentFields} to {fieldsForResponseKey}.</li>
</ul>
</li>
</ul>
</li>
<li>If {selection} is an {InlineFragment}:<ul>
<li>Let {fragmentType} be the type condition on {selection}.</li>
<li>If {fragmentType} is not {null} and {DoesFragmentTypeApply(objectType,
      fragmentType)} is {false}, continue with the next {selection} in {selectionSet}.</li>
<li>Let {fragmentSelectionSet} be the top-level selection set of {selection}.</li>
<li>Let {fragmentCollectedFieldsMap} be the result of calling {CollectSubscriptionFields(objectType, fragmentSelectionSet,
      visitedFragments)}.</li>
<li>For each {responseName} and {fragmentFields} in {fragmentCollectedFieldsMap}:<ul>
<li>Let {fieldsForResponseKey} be the <em>field set</em> value in {collectedFieldsMap} for the key {responseName}; otherwise create the entry with an empty ordered set.</li>
<li>Add each item from {fragmentFields} to {fieldsForResponseKey}.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return {collectedFieldsMap}.</li>
</ul>
<p>Note: This algorithm is very similar to {CollectFields()}, it differs in that it does not have access to runtime variables and thus the <code>@skip</code> and <code>@include</code> directives cannot be used.</p>
<p><b>Explanatory Text</b></p>
<p>Subscription operations must have exactly one root field.</p>
<p>To enable us to determine this without access to runtime variables, we must forbid the <code>@skip</code> and <code>@include</code> directives in the root selection set.</p>
<p>Valid examples:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">subscription sub {</div>
<div class="line">  newMessage {</div>
<div class="line">    body</div>
<div class="line">    sender</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> example</div>
<div class="line">subscription sub {</div>
<div class="line">  ...newMessageFields</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment newMessageFields on Subscription {</div>
<div class="line">  newMessage {</div>
<div class="line">    body</div>
<div class="line">    sender</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">subscription sub {</div>
<div class="line">  newMessage {</div>
<div class="line">    body</div>
<div class="line">    sender</div>
<div class="line">  }</div>
<div class="line">  disallowedSecondRootField</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> counter-example</div>
<div class="line">subscription sub {</div>
<div class="line">  ...multipleSubscriptions</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment multipleSubscriptions on Subscription {</div>
<div class="line">  newMessage {</div>
<div class="line">    body</div>
<div class="line">    sender</div>
<div class="line">  }</div>
<div class="line">  disallowedSecondRootField</div>
<div class="line">}</div>
</div><!-- fragment --><p>We do not allow the <code>@skip</code> and <code>@include</code> directives at the root of the subscription operation. The following example is also invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">subscription requiredRuntimeValidation($bool: Boolean!) {</div>
<div class="line">  newMessage @include(if: $bool) {</div>
<div class="line">    body</div>
<div class="line">    sender</div>
<div class="line">  }</div>
<div class="line">  disallowedSecondRootField @skip(if: $bool)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The root field of a subscription operation must not be an introspection field. The following example is also invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">subscription sub {</div>
<div class="line">  __typename</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: While each subscription must have exactly one root field, a document may contain any number of operations, each of which may contain different root fields. When executed, a document containing multiple subscription operations must provide the operation name as described in {GetOperation()}.</p>
<h2><a class="anchor" id="autotoc_md1143"></a>
Fields</h2>
<h3><a class="anchor" id="autotoc_md1144"></a>
Field Selections</h3>
<p>Field selections must exist on Object, Interface, and Union types.</p>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {selection} in the document:<ul>
<li>Let {fieldName} be the target field of {selection}.</li>
<li>{fieldName} must be defined on type in scope.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>The target field of a field selection must be defined on the scoped type of the selection set. There are no limitations on alias names.</p>
<p>For example the following fragment would not pass validation:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment fieldNotDefined on Dog {</div>
<div class="line">  meowVolume</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment aliasedLyingFieldTargetNotDefined on Dog {</div>
<div class="line">  barkVolume: kawVolume</div>
<div class="line">}</div>
</div><!-- fragment --><p>For interfaces, direct field selection can only be done on fields. Fields of concrete implementers are not relevant to the validity of the given interface-typed selection set.</p>
<p>For example, the following is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment interfaceFieldSelection on Pet {</div>
<div class="line">  name</div>
<div class="line">}</div>
</div><!-- fragment --><p>and the following is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment definedOnImplementersButNotInterface on Pet {</div>
<div class="line">  nickname</div>
<div class="line">}</div>
</div><!-- fragment --><p>Because unions do not define fields, fields may not be directly selected from a union-typed selection set, with the exception of the meta-field {__typename}. Fields from a union-typed selection set must only be queried indirectly via a fragment.</p>
<p>For example the following is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment inDirectFieldSelectionOnUnion on CatOrDog {</div>
<div class="line">  __typename</div>
<div class="line">  ... on Pet {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">  ... on Dog {</div>
<div class="line">    barkVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>But the following is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment directFieldSelectionOnUnion on CatOrDog {</div>
<div class="line">  name</div>
<div class="line">  barkVolume</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1145"></a>
Field Selection Merging</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>Let {set} be any selection set defined in the GraphQL document.</li>
<li>{FieldsInSetCanMerge(set)} must be true.</li>
</ul>
<p>FieldsInSetCanMerge(set):</p>
<ul>
<li>Let {fieldsForName} be the set of selections with a given <em>response name</em> in {set} including visiting fragments and inline fragments.</li>
<li>Given each pair of distinct members {fieldA} and {fieldB} in {fieldsForName}:<ul>
<li>{SameResponseShape(fieldA, fieldB)} must be true.</li>
<li>If the parent types of {fieldA} and {fieldB} are equal or if either is not an Object Type:<ul>
<li>{fieldA} and {fieldB} must have identical field names.</li>
<li>{fieldA} and {fieldB} must have identical sets of arguments.</li>
<li>Let {mergedSet} be the result of adding the selection set of {fieldA} and the selection set of {fieldB}.</li>
<li>{FieldsInSetCanMerge(mergedSet)} must be true.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SameResponseShape(fieldA, fieldB):</p>
<ul>
<li>Let {typeA} be the return type of {fieldA}.</li>
<li>Let {typeB} be the return type of {fieldB}.</li>
<li>If {typeA} or {typeB} is Non-Null:<ul>
<li>If {typeA} or {typeB} is nullable, return {false}.</li>
<li>Let {typeA} be the nullable type of {typeA}.</li>
<li>Let {typeB} be the nullable type of {typeB}.</li>
</ul>
</li>
<li>If {typeA} or {typeB} is List:<ul>
<li>If {typeA} or {typeB} is not List, return {false}.</li>
<li>Let {typeA} be the item type of {typeA}.</li>
<li>Let {typeB} be the item type of {typeB}.</li>
<li>Repeat from step 3.</li>
</ul>
</li>
<li>If {typeA} or {typeB} is Scalar or Enum:<ul>
<li>If {typeA} and {typeB} are the same type return {true}, otherwise return {false}.</li>
</ul>
</li>
<li>Assert: {typeA} is an object, union or interface type.</li>
<li>Assert: {typeB} is an object, union or interface type.</li>
<li>Let {mergedSet} be the result of adding the selection set of {fieldA} and the selection set of {fieldB}.</li>
<li>Let {fieldsForName} be the set of selections with a given <em>response name</em> in {mergedSet} including visiting fragments and inline fragments.</li>
<li>Given each pair of distinct members {subfieldA} and {subfieldB} in {fieldsForName}:<ul>
<li>If {SameResponseShape(subfieldA, subfieldB)} is {false}, return {false}.</li>
</ul>
</li>
<li>Return {true}.</li>
</ul>
<p>Note: In prior versions of the spec the term "composite" was used to signal a type that is either an Object, Interface or Union type.</p>
<p><b>Explanatory Text</b></p>
<p>If multiple field selections with the same <em>response name</em> are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.</p>
<p>During execution, the simultaneous execution of fields with the same response name is accomplished by performing {CollectSubfields()} before their execution.</p>
<p>For simple hand-written GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually.</p>
<p>The following selections correctly merge:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment mergeIdenticalFields on Dog {</div>
<div class="line">  name</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment mergeIdenticalAliasesAndFields on Dog {</div>
<div class="line">  otherName: name</div>
<div class="line">  otherName: name</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following is not able to merge:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment conflictingBecauseAlias on Dog {</div>
<div class="line">  name: nickname</div>
<div class="line">  name</div>
<div class="line">}</div>
</div><!-- fragment --><p>Identical fields are also merged if they have identical arguments. Both values and variables can be correctly merged.</p>
<p>For example the following correctly merge:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment mergeIdenticalFieldsWithIdenticalValues on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: $dogCommand)</div>
<div class="line">  doesKnowCommand(dogCommand: $dogCommand)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following do not correctly merge:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment conflictingArgsOnValues on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">  doesKnowCommand(dogCommand: HEEL)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment conflictingArgsValueAndVar on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">  doesKnowCommand(dogCommand: $dogCommand)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment conflictingArgsWithVars on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: $varOne)</div>
<div class="line">  doesKnowCommand(dogCommand: $varTwo)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment differingArgs on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">  doesKnowCommand</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following fields would not merge together, however both cannot be encountered against the same object, so they are safe:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment safeDifferingFields on Pet {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    volume: barkVolume</div>
<div class="line">  }</div>
<div class="line">  ... on Cat {</div>
<div class="line">    volume: meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment safeDifferingArgs on Pet {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    doesKnowCommand(dogCommand: SIT)</div>
<div class="line">  }</div>
<div class="line">  ... on Cat {</div>
<div class="line">    doesKnowCommand(catCommand: JUMP)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, the field responses must be shapes which can be merged. For example, leaf types must not differ. In this example, <code>someValue</code> might be a <code>String</code> or an <code>Int</code>:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment conflictingDifferingResponses on Pet {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    someValue: nickname</div>
<div class="line">  }</div>
<div class="line">  ... on Cat {</div>
<div class="line">    someValue: meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1146"></a>
Leaf Field Selections</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {selection} in the document:<ul>
<li>Let {selectionType} be the unwrapped result type of {selection}.</li>
<li>If {selectionType} is a scalar or enum:<ul>
<li>The subselection set of that selection must be empty.</li>
</ul>
</li>
<li>If {selectionType} is an interface, union, or object:<ul>
<li>The subselection set of that selection must not be empty.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>A field subselection is not allowed on leaf fields. A leaf field is any field with a scalar or enum unwrapped type.</p>
<p>The following is valid.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment scalarSelection on Dog {</div>
<div class="line">  barkVolume</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following is invalid.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment scalarSelectionsNotAllowedOnInt on Dog {</div>
<div class="line">  barkVolume {</div>
<div class="line">    sinceWhen</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Conversely, non-leaf fields must have a field subselection. A non-leaf field is any field with an object, interface, or union unwrapped type.</p>
<p>Let's assume the following additions to the query root operation type of the schema:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend type Query {</div>
<div class="line">  human: Human</div>
<div class="line">  pet: Pet</div>
<div class="line">  catOrDog: CatOrDog</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following examples are invalid because they include non-leaf fields without a field subselection.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query directQueryOnObjectWithoutSubFields {</div>
<div class="line">  human</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query directQueryOnInterfaceWithoutSubFields {</div>
<div class="line">  pet</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query directQueryOnUnionWithoutSubFields {</div>
<div class="line">  catOrDog</div>
<div class="line">}</div>
</div><!-- fragment --><p>However the following example is valid since it includes a field subselection.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query directQueryOnObjectWithSubFields {</div>
<div class="line">  human {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1147"></a>
Arguments</h2>
<p>Arguments are provided to both fields and directives. The following validation rules apply in both cases.</p>
<h3><a class="anchor" id="autotoc_md1148"></a>
Argument Names</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {argument} in the document:<ul>
<li>Let {argumentName} be the Name of {argument}.</li>
<li>Let {argumentDefinition} be the argument definition provided by the parent field or definition named {argumentName}.</li>
<li>{argumentDefinition} must exist.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive.</p>
<p>For example the following are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment argOnRequiredArg on Dog {</div>
<div class="line">  doesKnowCommand(dogCommand: SIT)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment argOnOptional on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: true) @include(if: true)</div>
<div class="line">}</div>
</div><!-- fragment --><p>the following is invalid since <code>command</code> is not defined on <code>DogCommand</code>.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment invalidArgName on Dog {</div>
<div class="line">  doesKnowCommand(command: CLEAN_UP_HOUSE)</div>
<div class="line">}</div>
</div><!-- fragment --><p>and this is also invalid as <code>unless</code> is not defined on <code>@include</code>.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment invalidArgName on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: true) @include(unless: false)</div>
<div class="line">}</div>
</div><!-- fragment --><p>In order to explore more complicated argument examples, let's add the following to our type system:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">type Arguments {</div>
<div class="line">  multipleRequirements(x: Int!, y: Int!): Int!</div>
<div class="line">  booleanArgField(booleanArg: Boolean): Boolean</div>
<div class="line">  floatArgField(floatArg: Float): Float</div>
<div class="line">  intArgField(intArg: Int): Int</div>
<div class="line">  nonNullBooleanArgField(nonNullBooleanArg: Boolean!): Boolean!</div>
<div class="line">  booleanListArgField(booleanListArg: [Boolean]!): [Boolean]</div>
<div class="line">  optionalNonNullBooleanArgField(optionalBooleanArg: Boolean! = false): Boolean!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">extend type Query {</div>
<div class="line">  arguments: Arguments</div>
<div class="line">}</div>
</div><!-- fragment --><p>Order does not matter in arguments. Therefore both the following examples are valid.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment multipleArgs on Arguments {</div>
<div class="line">  multipleRequirements(x: 1, y: 2)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment multipleArgsReverseOrder on Arguments {</div>
<div class="line">  multipleRequirements(y: 2, x: 1)</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1149"></a>
Argument Uniqueness</h3>
<p>Fields and directives treat arguments as a mapping of argument name to value. More than one argument with the same name in an argument set is ambiguous and invalid.</p>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {argument} in the Document:<ul>
<li>Let {argumentName} be the Name of {argument}.</li>
<li>Let {arguments} be all Arguments named {argumentName} in the Argument Set which contains {argument}.</li>
<li>{arguments} must be the set containing only {argument}.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md1150"></a>
Required Arguments</h3>
<ul>
<li>For each Field or Directive in the document:<ul>
<li>Let {arguments} be the arguments provided by the Field or Directive.</li>
<li>Let {argumentDefinitions} be the set of argument definitions of that Field or Directive.</li>
<li>For each {argumentDefinition} in {argumentDefinitions}:<ul>
<li>Let {type} be the expected type of {argumentDefinition}.</li>
<li>Let {defaultValue} be the default value of {argumentDefinition}.</li>
<li>If {type} is Non-Null and {defaultValue} does not exist:<ul>
<li>Let {argumentName} be the name of {argumentDefinition}.</li>
<li>Let {argument} be the argument in {arguments} named {argumentName}.</li>
<li>{argument} must exist.</li>
<li>Let {value} be the value of {argument}.</li>
<li>{value} must not be the {null} literal.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Arguments can be required. An argument is required if the argument type is non-null and does not have a default value. Otherwise, the argument is optional.</p>
<p>For example the following are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment goodBooleanArg on Arguments {</div>
<div class="line">  booleanArgField(booleanArg: true)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment goodNonNullArg on Arguments {</div>
<div class="line">  nonNullBooleanArgField(nonNullBooleanArg: true)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The argument can be omitted from a field with a nullable argument.</p>
<p>Therefore the following fragment is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment goodBooleanArgDefault on Arguments {</div>
<div class="line">  booleanArgField</div>
<div class="line">}</div>
</div><!-- fragment --><p>but this is not valid on a required argument.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment missingRequiredArg on Arguments {</div>
<div class="line">  nonNullBooleanArgField</div>
<div class="line">}</div>
</div><!-- fragment --><p>Providing the explicit value {null} is also not valid since required arguments always have a non-null type.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment missingRequiredArg on Arguments {</div>
<div class="line">  nonNullBooleanArgField(nonNullBooleanArg: null)</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1151"></a>
Fragments</h2>
<h3><a class="anchor" id="autotoc_md1152"></a>
Fragment Declarations</h3>
<h4><a class="anchor" id="autotoc_md1153"></a>
Fragment Name Uniqueness</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each fragment definition {fragment} in the document:<ul>
<li>Let {fragmentName} be the name of {fragment}.</li>
<li>Let {fragments} be all fragment definitions in the document named {fragmentName}.</li>
<li>{fragments} must be a set of one.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Fragment definitions are referenced in fragment spreads by name. To avoid ambiguity, each fragment's name must be unique within a document.</p>
<p>Inline fragments are not considered fragment definitions, and are unaffected by this validation rule.</p>
<p>For example the following document is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    ...fragmentOne</div>
<div class="line">    ...fragmentTwo</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragmentOne on Dog {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragmentTwo on Dog {</div>
<div class="line">  owner {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While this document is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    ...fragmentOne</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragmentOne on Dog {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragmentOne on Dog {</div>
<div class="line">  owner {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1154"></a>
Fragment Spread Type Existence</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each named spread {namedSpread} in the document:<ul>
<li>Let {fragment} be the target of {namedSpread}.</li>
<li>The target type of {fragment} must be defined in the schema.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Fragments must be specified on types that exist in the schema. This applies for both named and inline fragments. If they are not defined in the schema, the fragment is invalid.</p>
<p>For example the following fragments are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment correctType on Dog {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment inlineFragment on Dog {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment inlineFragment2 on Dog {</div>
<div class="line">  ... @include(if: true) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>and the following do not validate:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment notOnExistingType on NotInSchema {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment inlineNotExistingType on Dog {</div>
<div class="line">  ... on NotInSchema {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1155"></a>
Fragments on Object, Interface or Union Types</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {fragment} defined in the document:<ul>
<li>The target type of fragment must have kind {UNION}, {INTERFACE}, or {OBJECT}.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Fragments can only be declared on unions, interfaces, and objects. They are invalid on scalars. They can only be applied on non-leaf fields. This rule applies to both inline and named fragments.</p>
<p>The following fragment declarations are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment fragOnObject on Dog {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragOnInterface on Pet {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment fragOnUnion on CatOrDog {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>and the following are invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment fragOnScalar on Int {</div>
<div class="line">  something</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment inlineFragOnScalar on Dog {</div>
<div class="line">  ... on Boolean {</div>
<div class="line">    somethingElse</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1156"></a>
Fragments Must Be Used</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {fragment} defined in the document:<ul>
<li>{fragment} must be the target of at least one spread in the document.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Defined fragments must be used within a document.</p>
<p>For example the following is an invalid document:</p>
<div class="fragment"><div class="line"> graphql counter-example</div>
<div class="line">fragment nameFragment on Dog { # unused</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1157"></a>
Fragment Spreads</h3>
<p>Field selection is also determined by spreading fragments into one another. The selection set of the target fragment is combined into the selection set at the level at which the target fragment is referenced.</p>
<h4><a class="anchor" id="autotoc_md1158"></a>
Fragment Spread Target Defined</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {namedSpread} in the document:<ul>
<li>Let {fragment} be the target of {namedSpread}.</li>
<li>{fragment} must be defined in the document.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Named fragment spreads must refer to fragments defined within the document. It is a validation error if the target of a spread is not defined.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    ...undefinedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1159"></a>
Fragment Spreads Must Not Form Cycles</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {fragmentDefinition} in the document:<ul>
<li>Let {visited} be the empty set.</li>
<li>{DetectFragmentCycles(fragmentDefinition, visited)}.</li>
</ul>
</li>
</ul>
<p>DetectFragmentCycles(fragmentDefinition, visited):</p>
<ul>
<li>Let {spreads} be all fragment spread descendants of {fragmentDefinition}.</li>
<li>For each {spread} in {spreads}:<ul>
<li>{visited} must not contain {spread}.</li>
<li>Let {nextVisited} be the set including {spread} and members of {visited}.</li>
<li>Let {nextFragmentDefinition} be the target of {spread}.</li>
<li>{DetectFragmentCycles(nextFragmentDefinition, nextVisited)}.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.</p>
<p>This invalidates fragments that would result in an infinite spread:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    ...nameFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment nameFragment on Dog {</div>
<div class="line">  name</div>
<div class="line">  ...barkVolumeFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment barkVolumeFragment on Dog {</div>
<div class="line">  barkVolume</div>
<div class="line">  ...nameFragment</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the above fragments were inlined, this would result in the infinitely large:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    name</div>
<div class="line">    barkVolume</div>
<div class="line">    name</div>
<div class="line">    barkVolume</div>
<div class="line">    name</div>
<div class="line">    barkVolume</div>
<div class="line">    name</div>
<div class="line">    # forever...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This also invalidates fragments that would result in an infinite recursion when executed against cyclic data:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  dog {</div>
<div class="line">    ...dogFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment dogFragment on Dog {</div>
<div class="line">  name</div>
<div class="line">  owner {</div>
<div class="line">    ...ownerFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment ownerFragment on Human {</div>
<div class="line">  name</div>
<div class="line">  pets {</div>
<div class="line">    ...dogFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md1160"></a>
Fragment Spread Is Possible</h4>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {spread} (named or inline) defined in the document:<ul>
<li>Let {fragment} be the target of {spread}.</li>
<li>Let {fragmentType} be the type condition of {fragment}.</li>
<li>Let {parentType} be the type of the selection set containing {spread}.</li>
<li>Let {applicableTypes} be the intersection of {GetPossibleTypes(fragmentType)} and {GetPossibleTypes(parentType)}.</li>
<li>{applicableTypes} must not be empty.</li>
</ul>
</li>
</ul>
<p>GetPossibleTypes(type):</p>
<ul>
<li>If {type} is an object type, return a set containing {type}.</li>
<li>If {type} is an interface type, return the set of types implementing {type}.</li>
<li>If {type} is a union type, return the set of possible types of {type}.</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.</p>
<h5><a class="anchor" id="autotoc_md1161"></a>
Object Spreads in Object Scope</h5>
<p>In the scope of an object type, the only valid object type fragment spread is one that applies to the same type that is in scope.</p>
<p>For example</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment dogFragment on Dog {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    barkVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>and the following is invalid</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment catInDogFragmentInvalid on Dog {</div>
<div class="line">  ... on Cat {</div>
<div class="line">    meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h5><a class="anchor" id="autotoc_md1162"></a>
Abstract Spreads in Object Scope</h5>
<p>In scope of an object type, unions or interface spreads can be used if the object type implements the interface or is a member of the union.</p>
<p>For example</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment petNameFragment on Pet {</div>
<div class="line">  name</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment interfaceWithinObjectFragment on Dog {</div>
<div class="line">  ...petNameFragment</div>
<div class="line">}</div>
</div><!-- fragment --><p>is valid because {Dog} implements Pet.</p>
<p>Likewise</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment catOrDogNameFragment on CatOrDog {</div>
<div class="line">  ... on Cat {</div>
<div class="line">    meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment unionWithObjectFragment on Dog {</div>
<div class="line">  ...catOrDogNameFragment</div>
<div class="line">}</div>
</div><!-- fragment --><p>is valid because {Dog} is a member of the {CatOrDog} union. It is worth noting that if one inspected the contents of the {CatOrDogNameFragment} you could note that no valid results would ever be returned. However we do not specify this as invalid because we only consider the fragment declaration, not its body.</p>
<h5><a class="anchor" id="autotoc_md1163"></a>
Object Spreads in Abstract Scope</h5>
<p>Union or interface spreads can be used within the context of an object type fragment, but only if the object type is one of the possible types of that interface or union.</p>
<p>For example, the following fragments are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment petFragment on Pet {</div>
<div class="line">  name</div>
<div class="line">  ... on Dog {</div>
<div class="line">    barkVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment catOrDogFragment on CatOrDog {</div>
<div class="line">  ... on Cat {</div>
<div class="line">    meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>{petFragment} is valid because {Dog} implements the interface {Pet}. {catOrDogFragment} is valid because {Cat} is a member of the {CatOrDog} union.</p>
<p>By contrast the following fragments are invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment sentientFragment on Sentient {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    barkVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment humanOrAlienFragment on HumanOrAlien {</div>
<div class="line">  ... on Cat {</div>
<div class="line">    meowVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>{Dog} does not implement the interface {Sentient} and therefore {sentientFragment} can never return meaningful results. Therefore the fragment is invalid. Likewise {Cat} is not a member of the union {HumanOrAlien}, and it can also never return meaningful results, making it invalid.</p>
<h5><a class="anchor" id="autotoc_md1164"></a>
Abstract Spreads in Abstract Scope</h5>
<p>Union or interfaces fragments can be used within each other. As long as there exists at least <em>one</em> object type that exists in the intersection of the possible types of the scope and the spread, the spread is considered valid.</p>
<p>So for example</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment unionWithInterface on Pet {</div>
<div class="line">  ...dogOrHumanFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment dogOrHumanFragment on DogOrHuman {</div>
<div class="line">  ... on Dog {</div>
<div class="line">    barkVolume</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>is considered valid because {Dog} implements interface {Pet} and is a member of {DogOrHuman}.</p>
<p>However</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment nonIntersectingInterfaces on Pet {</div>
<div class="line">  ...sentientFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment sentientFragment on Sentient {</div>
<div class="line">  name</div>
<div class="line">}</div>
</div><!-- fragment --><p>is not valid because there exists no type that implements both {Pet} and {Sentient}.</p>
<p><b>Interface Spreads in Implemented Interface Scope</b></p>
<p>Additionally, an interface type fragment can always be spread into an interface scope which it implements.</p>
<p>In the example below, the <code>...resourceFragment</code> fragments spreads is valid, since <code>Resource</code> implements <code>Node</code>.</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">interface Node {</div>
<div class="line">  id: ID!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">interface Resource implements Node {</div>
<div class="line">  id: ID!</div>
<div class="line">  url: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment interfaceWithInterface on Node {</div>
<div class="line">  ...resourceFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment resourceFragment on Resource {</div>
<div class="line">  url</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1165"></a>
Values</h2>
<h3><a class="anchor" id="autotoc_md1166"></a>
Values of Correct Type</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each literal Input Value {value} in the document:<ul>
<li>Let {type} be the type expected in the position {value} is found.</li>
<li>{value} must be coercible to {type} (with the assumption that any {variableUsage} nested within {value} will represent a runtime value valid for usage in its position).</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Literal values must be compatible with the type expected in the position they are found as per the coercion rules defined in the Type System chapter.</p>
<p>Note: A {ListValue} or {ObjectValue} may contain nested Input Values, some of which may be a variable usage. The All Variable Usages Are Allowed validation rule ensures that each {variableUsage} is of a type allowed in its position. The Coercing Variable Values algorithm ensures runtime values for variables coerce correctly. Therefore, for the purposes of the "coercible" assertion in this validation rule, we can assume the runtime value of each {variableUsage} is valid for usage in its position.</p>
<p>The type expected in a position includes the type defined by the argument a value is provided for, the type defined by an input object field a value is provided for, and the type of a variable definition a default value is provided for.</p>
<p>The following examples are valid use of value literals:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">fragment goodBooleanArg on Arguments {</div>
<div class="line">  booleanArgField(booleanArg: true)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment coercedIntIntoFloatArg on Arguments {</div>
<div class="line">  # Note: The input coercion rules for Float allow Int literals.</div>
<div class="line">  floatArgField(floatArg: 123)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query goodComplexDefaultValue($search: FindDogInput = { name: &quot;Fido&quot; }) {</div>
<div class="line">  findDog(searchBy: $search) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation addPet($pet: PetInput! = { cat: { name: &quot;Brontie&quot; } }) {</div>
<div class="line">  addPet(pet: $pet) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Non-coercible values (such as a String into an Int) are invalid. The following examples are invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">fragment stringIntoInt on Arguments {</div>
<div class="line">  intArgField(intArg: &quot;123&quot;)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query badComplexValue {</div>
<div class="line">  findDog(searchBy: { name: 123 }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation oneOfWithNoFields {</div>
<div class="line">  addPet(pet: {}) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation oneOfWithTwoFields($dog: DogInput) {</div>
<div class="line">  addPet(pet: { cat: { name: &quot;Brontie&quot; }, dog: $dog }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation listOfOneOfWithNullableVariable($dog: DogInput) {</div>
<div class="line">  addPets(pets: [{ dog: $dog }]) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1167"></a>
Input Object Field Names</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each Input Object Field {inputField} in the document:<ul>
<li>Let {inputFieldName} be the Name of {inputField}.</li>
<li>Let {inputFieldDefinition} be the input field definition provided by the parent input object type named {inputFieldName}.</li>
<li>{inputFieldDefinition} must exist.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Every input field provided in an input object value must be defined in the set of possible fields of that input object's expected type.</p>
<p>For example the following example input object is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">{</div>
<div class="line">  findDog(searchBy: { name: &quot;Fido&quot; }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While the following example input-object uses a field "favoriteCookieFlavor" which is not defined on the expected type:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  findDog(searchBy: { favoriteCookieFlavor: &quot;Bacon&quot; }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1168"></a>
Input Object Field Uniqueness</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each input object value {inputObject} in the document:<ul>
<li>For every {inputField} in {inputObject}:<ul>
<li>Let {name} be the Name of {inputField}.</li>
<li>Let {fields} be all Input Object Fields named {name} in {inputObject}.</li>
<li>{fields} must be the set containing only {inputField}.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Input objects must not contain more than one field of the same name, otherwise an ambiguity would exist which includes an ignored portion of syntax.</p>
<p>For example the following document will not pass validation.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">{</div>
<div class="line">  field(arg: { field: true, field: false })</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1169"></a>
Input Object Required Fields</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each Input Object in the document:<ul>
<li>Let {fields} be the fields provided by that Input Object.</li>
<li>Let {fieldDefinitions} be the set of input field definitions of that Input Object.</li>
<li>For each {fieldDefinition} in {fieldDefinitions}:<ul>
<li>Let {type} be the expected type of {fieldDefinition}.</li>
<li>Let {defaultValue} be the default value of {fieldDefinition}.</li>
<li>If {type} is Non-Null and {defaultValue} does not exist:<ul>
<li>Let {fieldName} be the name of {fieldDefinition}.</li>
<li>Let {field} be the input field in {fields} named {fieldName}.</li>
<li>{field} must exist.</li>
<li>Let {value} be the value of {field}.</li>
<li>{value} must not be the {null} literal.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Input object fields may be required. Much like a field may have required arguments, an input object may have required fields. An input field is required if it has a non-null type and does not have a default value. Otherwise, the input object field is optional.</p>
<h2><a class="anchor" id="autotoc_md1170"></a>
Directives</h2>
<h3><a class="anchor" id="autotoc_md1171"></a>
Directives Are Defined</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {directive} in a document:<ul>
<li>Let {directiveName} be the name of {directive}.</li>
<li>Let {directiveDefinition} be the directive named {directiveName}.</li>
<li>{directiveDefinition} must exist.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>GraphQL services define what directives they support. For each usage of a directive, the directive must be available on that service.</p>
<h3><a class="anchor" id="autotoc_md1172"></a>
Directives Are in Valid Locations</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {directive} in a document:<ul>
<li>Let {directiveName} be the name of {directive}.</li>
<li>Let {directiveDefinition} be the directive named {directiveName}.</li>
<li>Let {locations} be the valid locations for {directiveDefinition}.</li>
<li>Let {adjacent} be the AST node the directive affects.</li>
<li>{adjacent} must be represented by an item within {locations}.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>GraphQL services define what directives they support and where they support them. For each usage of a directive, the directive must be used in a location that the service has declared support for.</p>
<p>For example the following document will not pass validation because <code>@skip</code> does not provide <code>QUERY</code> as a valid location.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query @skip(if: $foo) {</div>
<div class="line">  field</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1173"></a>
Directives Are Unique per Location</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {location} in the document for which Directives can apply:<ul>
<li>Let {directives} be the set of Directives which apply to {location} and are not repeatable.</li>
<li>For each {directive} in {directives}:<ul>
<li>Let {directiveName} be the name of {directive}.</li>
<li>Let {namedDirectives} be the set of all Directives named {directiveName} in {directives}.</li>
<li>{namedDirectives} must be a set of one.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>GraphQL allows directives that are defined as <code>repeatable</code> to be used more than once on the definition they apply to, possibly with different arguments. In contrast, if a directive is not <code>repeatable</code>, then only one occurrence of it is allowed per location.</p>
<p>For example, the following document will not pass validation because non-repeatable <code>@skip</code> has been used twice for the same field:</p>
<div class="fragment"><div class="line"> graphql counter-example</div>
<div class="line">query ($foo: Boolean = true, $bar: Boolean = false) {</div>
<div class="line">  field @skip(if: $foo) @skip(if: $bar)</div>
<div class="line">}</div>
</div><!-- fragment --><p>However the following example is valid because <code>@skip</code> has been used only once per location, despite being used twice in the operation and on the same named field:</p>
<div class="fragment"><div class="line"> graphql example</div>
<div class="line">query ($foo: Boolean = true, $bar: Boolean = false) {</div>
<div class="line">  field @skip(if: $foo) {</div>
<div class="line">    subfieldA</div>
<div class="line">  }</div>
<div class="line">  field @skip(if: $bar) {</div>
<div class="line">    subfieldB</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1174"></a>
Variables</h2>
<h3><a class="anchor" id="autotoc_md1175"></a>
Variable Uniqueness</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {operation} in the document:<ul>
<li>For every {variable} defined on {operation}:<ul>
<li>Let {variableName} be the name of {variable}.</li>
<li>Let {variables} be the set of all variables named {variableName} on {operation}.</li>
<li>{variables} must be a set of one.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>If any operation defines more than one variable with the same name, it is ambiguous and invalid. It is invalid even if the type of the duplicate variable is the same.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query houseTrainedQuery($atOtherHomes: Boolean, $atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is valid for multiple operations to define a variable with the same name. If two operations reference the same fragment, it might actually be necessary:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query A($atOtherHomes: Boolean) {</div>
<div class="line">  ...HouseTrainedFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query B($atOtherHomes: Boolean) {</div>
<div class="line">  ...HouseTrainedFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment HouseTrainedFragment on Query {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1176"></a>
Variables Are Input Types</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {operation} in a {document}:<ul>
<li>For every {variable} on each {operation}:<ul>
<li>Let {variableType} be the type of {variable}.</li>
<li>{IsInputType(variableType)} must be {true}.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Variables can only be input types. Objects, unions, and interfaces cannot be used as inputs.</p>
<p>For these examples, consider the following type system additions:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">extend type Query {</div>
<div class="line">  booleanList(booleanListArg: [Boolean!]): Boolean</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following operations are valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query takesBoolean($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query takesComplexInput($search: FindDogInput) {</div>
<div class="line">  findDog(searchBy: $search) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query TakesListOfBooleanBang($booleans: [Boolean!]) {</div>
<div class="line">  booleanList(booleanListArg: $booleans)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following operations are invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query takesCat($cat: Cat) {</div>
<div class="line">  # ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query takesDogBang($dog: Dog!) {</div>
<div class="line">  # ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query takesListOfPet($pets: [Pet]) {</div>
<div class="line">  # ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query takesCatOrDog($catOrDog: CatOrDog) {</div>
<div class="line">  # ...</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1177"></a>
All Variable Uses Defined</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {operation} in a document:<ul>
<li>For each {variableUsage} in scope, variable must be in {operation}'s variable list.</li>
<li>Let {fragments} be every fragment referenced by that {operation} transitively.</li>
<li>For each {fragment} in {fragments}:<ul>
<li>For each {variableUsage} in scope of {fragment}, variable must be in {operation}'s variable list.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Variables are scoped on a per-operation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation</p>
<p>For example:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query variableIsDefined($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>is valid. ${atOtherHomes} is defined by the operation.</p>
<p>By contrast the following document is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query variableIsNotDefined {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>${atOtherHomes} is not defined by the operation.</p>
<p>Fragments complicate this rule. Any fragment transitively included by an operation has access to the variables defined by that operation. Fragments can appear within multiple operations and therefore variable usages must correspond to variable definitions in all of those operations.</p>
<p>For example the following is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query variableIsDefinedUsedInSingleFragment($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>since {isHouseTrainedFragment} is used within the context of the operation {variableIsDefinedUsedInSingleFragment} and the variable is defined by that operation.</p>
<p>On the other hand, if a fragment is included within an operation that does not define a referenced variable, the document is invalid.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query variableIsNotDefinedUsedInSingleFragment {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>This applies transitively as well, so the following also fails:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query variableIsNotDefinedUsedInNestedFragment {</div>
<div class="line">  dog {</div>
<div class="line">    ...outerHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment outerHouseTrainedFragment on Dog {</div>
<div class="line">  ...isHouseTrainedFragment</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Variables must be defined in all operations in which a fragment is used.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query houseTrainedQueryOne($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query houseTrainedQueryTwo($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>However the following does not validate:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query houseTrainedQueryOne($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query houseTrainedQueryTwoNotDefined {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is because {houseTrainedQueryTwoNotDefined} does not define a variable ${atOtherHomes} but that variable is used by {isHouseTrainedFragment} which is included in that operation.</p>
<h3><a class="anchor" id="autotoc_md1178"></a>
All Variables Used</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For every {operation} in the document:<ul>
<li>Let {variables} be the variables defined by that {operation}.</li>
<li>Each {variable} in {variables} must be used at least once in either the operation scope itself or any fragment transitively referenced by that operation.</li>
</ul>
</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error.</p>
<p>For example the following is invalid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query variableUnused($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    isHouseTrained</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>because ${atOtherHomes} is not referenced.</p>
<p>These rules apply to transitive fragment spreads as well:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query variableUsedInFragment($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above is valid since ${atOtherHomes} is used in {isHouseTrainedFragment} which is included by {variableUsedInFragment}.</p>
<p>If that fragment did not have a reference to ${atOtherHomes} it would be not valid:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query variableNotUsedWithinFragment($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedWithoutVariableFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedWithoutVariableFragment on Dog {</div>
<div class="line">  isHouseTrained</div>
<div class="line">}</div>
</div><!-- fragment --><p>All operations in a document must use all of their variables.</p>
<p>As a result, the following document does not validate.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query queryWithUsedVar($atOtherHomes: Boolean) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">query queryWithExtraVar($atOtherHomes: Boolean, $extra: Int) {</div>
<div class="line">  dog {</div>
<div class="line">    ...isHouseTrainedFragment</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">fragment isHouseTrainedFragment on Dog {</div>
<div class="line">  isHouseTrained(atOtherHomes: $atOtherHomes)</div>
<div class="line">}</div>
</div><!-- fragment --><p>This document is not valid because {queryWithExtraVar} defines an extraneous variable.</p>
<h3><a class="anchor" id="autotoc_md1179"></a>
All Variable Usages Are Allowed</h3>
<p><b>Formal Specification</b></p>
<ul>
<li>For each {operation} in {document}:<ul>
<li>Let {variableUsages} be all usages transitively included in the {operation}.</li>
<li>For each {variableUsage} in {variableUsages}:<ul>
<li>Let {variableName} be the name of {variableUsage}.</li>
<li>Let {variableDefinition} be the {VariableDefinition} named {variableName} defined within {operation}.</li>
<li>{IsVariableUsageAllowed(variableDefinition, variableUsage)} must be {true}.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>IsVariableUsageAllowed(variableDefinition, variableUsage):</p>
<ul>
<li>Let {variableType} be the expected type of {variableDefinition}.</li>
<li>Let {locationType} be the expected type of the {Argument}, {ObjectField}, or {ListValue} entry where {variableUsage} is located.</li>
<li>If {IsNonNullPosition(locationType, variableUsage)} AND {variableType} is NOT a non-null type:<ul>
<li>Let {hasNonNullVariableDefaultValue} be {true} if a default value exists for {variableDefinition} and is not the value {null}.</li>
<li>Let {hasLocationDefaultValue} be {true} if a default value exists for the {Argument} or {ObjectField} where {variableUsage} is located.</li>
<li>If {hasNonNullVariableDefaultValue} is NOT {true} AND {hasLocationDefaultValue} is NOT {true}, return {false}.</li>
<li>Let {nullableLocationType} be the unwrapped nullable type of {locationType}.</li>
<li>Return {AreTypesCompatible(variableType, nullableLocationType)}.</li>
</ul>
</li>
<li>Return {AreTypesCompatible(variableType, locationType)}.</li>
</ul>
<p>IsNonNullPosition(locationType, variableUsage):</p>
<ul>
<li>If {locationType} is a non-null type, return {true}.</li>
<li>If the location of {variableUsage} is an {ObjectField}:<ul>
<li>Let {parentObjectValue} be the {ObjectValue} containing {ObjectField}.</li>
<li>Let {parentLocationType} be the expected type of {ObjectValue}.</li>
<li>If {parentLocationType} is a <em>OneOf Input Object</em> type, return {true}.</li>
</ul>
</li>
<li>Return {false}.</li>
</ul>
<p>AreTypesCompatible(variableType, locationType):</p>
<ul>
<li>If {locationType} is a non-null type:<ul>
<li>If {variableType} is NOT a non-null type, return {false}.</li>
<li>Let {nullableLocationType} be the unwrapped nullable type of {locationType}.</li>
<li>Let {nullableVariableType} be the unwrapped nullable type of {variableType}.</li>
<li>Return {AreTypesCompatible(nullableVariableType, nullableLocationType)}.</li>
</ul>
</li>
<li>Otherwise, if {variableType} is a non-null type:<ul>
<li>Let {nullableVariableType} be the nullable type of {variableType}.</li>
<li>Return {AreTypesCompatible(nullableVariableType, locationType)}.</li>
</ul>
</li>
<li>Otherwise, if {locationType} is a list type:<ul>
<li>If {variableType} is NOT a list type, return {false}.</li>
<li>Let {itemLocationType} be the unwrapped item type of {locationType}.</li>
<li>Let {itemVariableType} be the unwrapped item type of {variableType}.</li>
<li>Return {AreTypesCompatible(itemVariableType, itemLocationType)}.</li>
</ul>
</li>
<li>Otherwise, if {variableType} is a list type, return {false}.</li>
<li>Return {true} if {variableType} and {locationType} are identical, otherwise {false}.</li>
</ul>
<p><b>Explanatory Text</b></p>
<p>Variable usages must be compatible with the arguments they are passed to.</p>
<p>Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a non-null argument type.</p>
<p>Types must match:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query intCannotGoIntoBoolean($intArg: Int) {</div>
<div class="line">  arguments {</div>
<div class="line">    booleanArgField(booleanArg: $intArg)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>${intArg} typed as {Int} cannot be used as an argument to {booleanArg}, typed as {Boolean}.</p>
<p>List cardinality must also be the same. For example, lists cannot be passed into singular values.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query booleanListCannotGoIntoBoolean($booleanListArg: [Boolean]) {</div>
<div class="line">  arguments {</div>
<div class="line">    booleanArgField(booleanArg: $booleanListArg)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Nullability must also be respected. In general a nullable variable cannot be passed to a non-null argument.</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query booleanArgQuery($booleanArg: Boolean) {</div>
<div class="line">  arguments {</div>
<div class="line">    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>For list types, the same rules around nullability apply to both outer types and inner types. A nullable list cannot be passed to a non-null list, and a list of nullable values cannot be passed to a list of non-null values. The following is valid:</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query nonNullListToList($nonNullBooleanList: [Boolean]!) {</div>
<div class="line">  arguments {</div>
<div class="line">    booleanListArgField(booleanListArg: $nonNullBooleanList)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, a nullable list cannot be passed to a non-null list:</p>
<div class="fragment"><div class="line"> counter-example</div>
<div class="line">query listToNonNullList($booleanList: [Boolean]) {</div>
<div class="line">  arguments {</div>
<div class="line">    nonNullBooleanListField(nonNullBooleanListArg: $booleanList)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This would fail validation because a <code>[T]</code> cannot be passed to a <code>[T]!</code>. Similarly a <code>[T]</code> cannot be passed to a <code>[T!]</code>.</p>
<p>Variables used for OneOf Input Object fields must be non-nullable.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">mutation addCat($cat: CatInput!) {</div>
<div class="line">  addPet(pet: { cat: $cat }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutation addCatWithDefault($cat: CatInput! = { name: &quot;Brontie&quot; }) {</div>
<div class="line">  addPet(pet: { cat: $cat }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"> counter-example</div>
<div class="line">mutation addNullableCat($cat: CatInput) {</div>
<div class="line">  addPet(pet: { cat: $cat }) {</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Allowing Optional Variables When Default Values Exist</b></p>
<p>A notable exception to typical variable type compatibility is allowing a variable definition with a nullable type to be provided to a non-null location as long as either that variable or that location provides a default value.</p>
<p>In the example below, an optional variable <code>$booleanArg</code> is allowed to be used in the non-null argument <code>optionalBooleanArg</code> because the field argument is optional since it provides a default value in the schema.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query booleanArgQueryWithDefault($booleanArg: Boolean) {</div>
<div class="line">  arguments {</div>
<div class="line">    optionalNonNullBooleanArgField(optionalBooleanArg: $booleanArg)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example below, an optional variable <code>$booleanArg</code> is allowed to be used in the non-null argument (<code>nonNullBooleanArg</code>) because the variable provides a default value in the operation. This behavior is explicitly supported for compatibility with earlier editions of this specification. GraphQL authoring tools may wish to report this as a warning with the suggestion to replace <code>Boolean</code> with <code>Boolean!</code> to avoid ambiguity.</p>
<div class="fragment"><div class="line"> example</div>
<div class="line">query booleanArgQueryWithDefault($booleanArg: Boolean = true) {</div>
<div class="line">  arguments {</div>
<div class="line">    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note: The value {null} could still be provided to such a variable at runtime. A non-null argument must raise an <em>execution error</em> if provided a {null} value. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
