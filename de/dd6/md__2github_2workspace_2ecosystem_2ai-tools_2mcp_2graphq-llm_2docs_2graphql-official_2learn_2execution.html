#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: execution</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/dd6/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2execution.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">execution</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>import { Callout } from "nextra/components"</p>
<h1><a class="anchor" id="autotoc_md889"></a>
Execution</h1>
<p>Learn how GraphQL provides data for requested fields</p>
<p>After a parsed document is <a href="../..//learn/validation/">validated</a>, a client's request will be <a href="https://spec.graphql.org/draft/#sec-Execution">executed</a> by the GraphQL server and the returned result will mirror the shape of the requested query. On this page, you'll learn about the execution phase of GraphQL operations where data is read from or written to an existing source depending on what fields are requested by a client.</p>
<h2><a class="anchor" id="autotoc_md890"></a>
Field resolvers</h2>
<p>GraphQL cannot execute operations without a type system, so let's use an example type system to illustrate executing a query. This is a part of the same type system used throughout the examples in this guide:</p>
<div class="fragment"><div class="line">type Query {</div>
<div class="line">  human(id: ID!): Human</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Human {</div>
<div class="line">  name: String</div>
<div class="line">  appearsIn: [Episode]</div>
<div class="line">  starships: [Starship]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">enum Episode {</div>
<div class="line">  NEWHOPE</div>
<div class="line">  EMPIRE</div>
<div class="line">  JEDI</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Starship {</div>
<div class="line">  name: String</div>
<div class="line">}</div>
</div><!-- fragment --><p>To describe what happens when a query is executed, let's walk through an example:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">query {</div>
<div class="line">  human(id: 1002) {</div>
<div class="line">    name</div>
<div class="line">    appearsIn</div>
<div class="line">    starships {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can think of each field in a GraphQL query as a function or method of the previous type which returns the next type. This is exactly how GraphQL worksâ€”each field on each type is backed by a <em>resolver function</em> that is written by the GraphQL server developer. When a field is executed, the corresponding resolver is called to produce the next value.</p>
<p>If a field produces a scalar value like a string or number, then the execution completes. However, if a field produces an object value then the query will contain another selection of fields that apply to that object. This continues until the leaf values are reached. GraphQL queries always end at Scalar or Enum types.</p>
<h2><a class="anchor" id="autotoc_md891"></a>
Root fields and resolvers</h2>
<p>At the top level of every GraphQL server is an Object type that represents the possible entry points into the GraphQL API, it's often called "the `query` root operation type" or the <code>Query</code> type. If the API supports mutations to write data and subscriptions to fetch real-time data as well, then it will have <code>Mutation</code> and <code>Subscription</code> types that expose fields to perform these kinds of operations too. You can learn more about these types on the <a href="../..//learn/schema/#the-query-mutation-and-subscription-types">Schema and Types page</a>.</p>
<p>In this example, our <code>Query</code> type provides a field called <code>human</code> which accepts the argument <code>id</code>. The resolver function for this field likely accesses a database and then constructs and returns a <code>Human</code> type:</p>
<div class="fragment"><div class="line">function resolveHumanQuery(obj, args, context, info) {</div>
<div class="line">  return context.db.loadHumanByID(args.id).then(userData =&gt; new Human(userData));</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example is written in JavaScript, however GraphQL servers can be built in <a href="../..//code/">many different languages</a>. In the reference implementation, a resolver function receives four arguments:</p>
<ul>
<li><code>obj</code>: The previous object (for a field on the root <code>Query</code> type, this argument is often not used).</li>
<li><code>args</code>: The arguments provided to the field in the GraphQL operation.</li>
<li><code>context</code>: A value provided to every resolver that may hold important contextual information like the currently logged in user, or access to a database.</li>
<li><code>info</code>: generally only used in advanced use-cases, this is a value holding field-specific information relevant to the current operation as well as the schema details; refer to <a href="../..//graphql-js/type/#graphqlobjecttype">type GraphQLResolveInfo</a> for more details.</li>
</ul>
<p>&lt;Callout type="info"&gt; Note that while a query operation could technically write data to the underlying data system during its execution, mutation operations are conventionally used for requests that produce side effects during their execution. And because mutation operations produce side effects, GraphQL implementations can be expected to execute these fields serially. &lt;/Callout&gt;</p>
<h2><a class="anchor" id="autotoc_md892"></a>
Asynchronous resolvers</h2>
<p>Let's take a closer look at what's happening in this resolver function:</p>
<div class="fragment"><div class="line">function resolveHuman(obj, args, context, info) {</div>
<div class="line">  return context.db.loadHumanByID(args.id).then(userData =&gt; new Human(userData));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>id</code> argument in the GraphQL query specifies the user whose data is requested, while <code>context</code> provides access to retrieve this data from a database. Since loading from a database is an asynchronous operation, this returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>. In JavaScript, Promises are used to work with asynchronous values, but the same concept exists in many languages, often called <em>Futures</em>, <em>Tasks</em>, or <em>Deferred</em>. When the database returns the data, we can construct and return a new <code>Human</code> object.</p>
<p>Notice that while the resolver function needs to be aware of Promises, the GraphQL query does not. It simply expects the <code>human</code> field to return something that can be further resolved to a scalar <code>name</code> value. During execution, GraphQL will wait for Promises, Futures, and Tasks to be completed before continuing and will do so with optimal concurrency.</p>
<h2><a class="anchor" id="autotoc_md893"></a>
Trivial resolvers</h2>
<p>Now that a <code>Human</code> object is available, GraphQL execution can continue with the fields requested for this type:</p>
<div class="fragment"><div class="line">function resolveHumanName(obj, args, context, info) {</div>
<div class="line">  return obj.name;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A GraphQL server is powered by a type system that is used to determine what to do next. Even before the <code>human</code> field returns anything, GraphQL knows the next step will be to resolve fields on the <code>Human</code> type since the type system tells it that the <code>human</code> field will return this output type.</p>
<p>Resolving the name in this case is straightforward. The name resolver function is called and the <code>obj</code> argument is the new <code>Human</code> object returned from the previous field. In this case, we expect this object to have a <code>name</code> property, which we can read and return directly.</p>
<p>Many GraphQL libraries let you omit resolvers this simple, assuming that if a resolver isn't provided for a field, a property of the same name should be read and returned.</p>
<h2><a class="anchor" id="autotoc_md894"></a>
Scalar coercion</h2>
<p>While the <code>name</code> field is being resolved, the <code>appearsIn</code> and <code>starships</code> fields can be resolved concurrently. The <code>appearsIn</code> field could also have a trivial resolver, but let's take a closer look:</p>
<div class="fragment"><div class="line">const Human = {</div>
<div class="line">  appearsIn(obj) {</div>
<div class="line">    return obj.appearsIn; // e.g. [4, 5, 6]</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><p>Notice that our type system claims <code>appearsIn</code> will return Enum types with known values, however, this function is returning numbers! Indeed if we look up at the result we'll see that the appropriate values for the Enum type are being returned. What's going on?</p>
<p>This is an example of <em>scalar coercion</em>. The type system knows what to expect and will convert the values returned by a resolver function into something that upholds the API contract. In this case, there may be an Enum type defined on our server that uses numbers like <code>4</code>, <code>5</code>, and <code>6</code> internally, but represents them as the expected values in the GraphQL type system.</p>
<h2><a class="anchor" id="autotoc_md895"></a>
List resolvers</h2>
<p>We've already seen some of what happens when a field returns a list of things with the <code>appearsIn</code> field above. It returned a <a href="../..//learn/schema/#lists">List type</a> containing Enum type values, and since that's what the type system expected, each item in the list was coerced to the appropriate value. What happens when the <code>starships</code> field is resolved?</p>
<div class="fragment"><div class="line">function resolveHumanStarships(obj, args, context, info) {</div>
<div class="line">  return Promise.all(</div>
<div class="line">    obj.starshipIDs.map(id =&gt;</div>
<div class="line">      context.db.loadStarshipByID(id).then(shipData =&gt; new Starship(shipData))</div>
<div class="line">    )</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The resolver for this field is not just returning a Promise, it's returning a <em>list</em> of Promises. The <code>Human</code> object had a list of IDs of the <code>Starships</code> they piloted, but we need to load all of those IDs to get real Starship objects.</p>
<p>GraphQL will wait for all of these Promises concurrently before continuing, and when left with a list of objects, it will continue yet again to load the <code>name</code> field on each of these items concurrently.</p>
<h2><a class="anchor" id="autotoc_md896"></a>
Producing the result</h2>
<p>As each field is resolved, the resulting value is placed into a key-value map with the field name (or alias) as the key and the resolved value as the value. This continues from the bottom leaf fields of the query back up to the original field on the root <code>Query</code> type. Collectively these produce a structure that mirrors the original query which can then be sent (typically as JSON) to the client that requested it.</p>
<p>Let's take one last look at the original query to see how all these resolving functions produce a result:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">query {</div>
<div class="line">  human(id: 1002) {</div>
<div class="line">    name</div>
<div class="line">    appearsIn</div>
<div class="line">    starships {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>As we can see, each field in the nested selection sets resolves to a scalar leaf value during execution of the query.</p>
<h2><a class="anchor" id="autotoc_md897"></a>
Next steps</h2>
<p>To recap what we've learned about execution:</p>
<ul>
<li>Each field in a GraphQL type system will have a corresponding resolver function that provides data for the field from an existing data source</li>
<li>Execution begins at the top-level <code>Query</code>, <code>Mutation</code>, or <code>Subscription</code> fields</li>
<li>Resolvers may execute asynchronously</li>
<li>Scalar coercion converts values into the types expected by the schema</li>
<li>When a field on an Object type returns a List type of other objects, additional data may need to be fetched from the underlying data source to transform any foreign key-like references (such as IDs) into the related objects</li>
<li>Once all of the requested fields have been resolved to the expected leaf values, the result is sent to the client, typically as JSON</li>
</ul>
<p>Now that we understand how operations are executed, we can move to the last stage of the lifecycle of a GraphQL request where the <a href="../..//learn/response/">response</a> is delivered to a client. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
