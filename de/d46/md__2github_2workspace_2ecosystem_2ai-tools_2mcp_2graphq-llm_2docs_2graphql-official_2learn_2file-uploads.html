#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: file-uploads</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d46/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2file-uploads.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">file-uploads</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md913"></a>
Handling File Uploads in GraphQL</h1>
<p>GraphQL was not designed with file uploads in mind. While it’s technically possible to implement them, doing so requires extending the transport layer and introduces several risks, both in security and reliability.</p>
<p>This guide explains why file uploads via GraphQL are problematic and presents safer alternatives.</p>
<h2><a class="anchor" id="autotoc_md914"></a>
Why uploads are challenging</h2>
<p>The <a href="https://spec.graphql.org/draft/">GraphQL specification</a> is transport-agnostic and serialization-agnostic (though HTTP and JSON are the most prevalent combination seen in the community). GraphQL was designed to work with relatively small requests from clients, and was not designed with handling binary data in mind.</p>
<p>File uploads, by contrast, typically handle binary data such as images and PDFs &mdash; something many encodings, including JSON, cannot handle directly. One option is to encode within our encoding (e.g. use a base64-encoded string within our JSON), but this is inefficient and is not suitable for larger binary files as it does not support streamed processing easily. Instead, <code>multipart/form-data</code> is a common choice for transferring binary data; but it is not without its own set of complexities.</p>
<p>Supporting uploads over GraphQL usually involves adopting community conventions, the most prevalent of which is the <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request specification</a>. This specification has been successfully implemented in many languages and frameworks, but users implementing it must pay very close attention to ensure that they do not introduce security or reliability concerns.</p>
<h2><a class="anchor" id="autotoc_md915"></a>
Risks to be aware of</h2>
<h3><a class="anchor" id="autotoc_md916"></a>
Memory exhaustion from repeated variables</h3>
<p>GraphQL operations allow the same variable to be referenced multiple times. If a file upload variable is reused, the underlying stream may be read multiple times or prematurely drained. This can result in incorrect behavior or memory exhaustion.</p>
<p>A safe practice is to use trusted documents or a validation rule to ensure each upload variable is referenced exactly once.</p>
<h3><a class="anchor" id="autotoc_md917"></a>
Stream leaks on failed operations</h3>
<p>GraphQL executes in phases: validation, then execution. If validation fails or an authorization check prematurely terminates execution, uploaded file streams may never be consumed. If your server buffers or retains these streams, it can cause memory leaks.</p>
<p>To avoid this, ensure that all streams are terminated when the request finishes, whether or not they were consumed in resolvers. An alternative to consider is writing incoming files to temporary storage immediately, and passing references (like filenames) into resolvers. Ensure this storage is cleaned up after request completion, regardless of success or failure.</p>
<h3><a class="anchor" id="autotoc_md918"></a>
Cross-Site Request Forgery (CSRF)</h3>
<p><code>multipart/form-data</code> is classified as a “simple” request in the CORS spec and does not trigger a preflight check. Without explicit CSRF protection, your GraphQL server may unknowingly accept uploads from malicious origins.</p>
<h3><a class="anchor" id="autotoc_md919"></a>
Oversized or excess payloads</h3>
<p>Attackers may submit very large uploads or include extraneous files under unused variable names. Servers that accept and buffer these can be overwhelmed.</p>
<p>Enforce request size caps and reject any files not explicitly referenced in the map field of the multipart payload.</p>
<h3><a class="anchor" id="autotoc_md920"></a>
Untrusted file metadata</h3>
<p>Information such as file names, MIME types, and contents should never be trusted. To mitigate risk:</p>
<ul>
<li>Sanitize filenames to prevent path traversal or injection issues.</li>
<li>Sniff file types independently of declared MIME types, and reject mismatches.</li>
<li>Validate file contents. Be aware of format-specific exploits like zip bombs or maliciously crafted PDFs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md921"></a>
Recommendation: Use signed URLs</h2>
<p>The most secure and scalable approach is to avoid uploading files through GraphQL entirely. Instead:</p>
<ol type="1">
<li>Use a GraphQL mutation to request a signed upload URL from your storage provider (e.g., Amazon S3).</li>
<li>Upload the file directly from the client using that URL.</li>
<li>Submit a second mutation to associate the uploaded file with your application’s data (or use an automatically triggered process, such as Amazon Lambda, to do the same).</li>
</ol>
<p>You should ensure that these file uploads are only retained for a short period such that an attacker completing only steps 1 and 2 will not exhaust your storage. When processing the file upload (step 3), the file should be moved to more permanent storage as appropriate.</p>
<p>This separates responsibilities cleanly, protects your server from binary data handling, and aligns with best practices for modern web architecture.</p>
<h2><a class="anchor" id="autotoc_md922"></a>
If you still choose to support uploads</h2>
<p>If your application truly requires file uploads through GraphQL, proceed with caution. At a minimum, you should:</p>
<ul>
<li>Use a well-maintained implementation of the <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request spec</a>.</li>
<li>Enforce a rule that upload variables are only referenced once.</li>
<li>Stream uploads to disk or cloud storage—avoid buffering them in memory.</li>
<li>Ensure that streams are always terminated when the request ends, whether or not they were consumed.</li>
<li>Apply strict request size limits and validate all fields.</li>
<li>Treat file names, types, and contents as untrusted data. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
