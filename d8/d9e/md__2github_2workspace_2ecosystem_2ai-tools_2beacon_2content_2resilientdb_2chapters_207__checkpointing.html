#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_checkpointing</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d9e/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_207__checkpointing.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_checkpointing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> layout: default title: 'Chapter 7: Checkpointing &amp; Recovery' parent: 'ResilientDB' </p>
<h2><a class="anchor" id="autotoc_md145"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md146"></a>
Chapter 7: Checkpointing &amp; Recovery</h1>
<p>In the previous chapter, <a class="el" href="../../d4/db2/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_206__storage__layer.html">Chapter 6: Storage Layer)</a>, we learned how ResilientDB actually saves data using components like <code>ResLevelDB</code> (for disk storage) or <code>MemoryDB</code> (for memory storage). This ensures that when we execute a transaction like <code>Set("myKey", "myValue")</code>, the change is recorded.</p>
<p>But what happens if a replica (one of the computers running ResilientDB) suddenly crashes or needs to be restarted? When it comes back online, how does it catch up with all the transactions it missed? Simply replaying <em>every single transaction</em> from the very beginning could take a very long time, especially if the system has been running for weeks or months! Also, the log of all past messages (Chapter 4) would grow forever, eventually filling up the disk.</p>
<p>Welcome to Chapter 7! We'll explore how ResilientDB solves these problems using <b>Checkpointing and Recovery</b>.</p>
<p>Think of it like playing a long video game:</p>
<ul>
<li>You wouldn't want to restart from the very beginning every time you stop playing. You <b>save your progress</b> periodically (this is <b>Checkpointing</b>).</li>
<li>If the game crashes, you can load your last save game and maybe replay just the last few actions you took before the crash (this is <b>Recovery</b>).</li>
</ul>
<p>ResilientDB uses two main components for this:</p>
<ol type="1">
<li><code>CheckPointManager</code>: Coordinates taking periodic "save points" (checkpoints) of the database state that all replicas agree on.</li>
<li><code>Recovery</code>: Manages writing down important actions (like consensus messages) into a journal (log file) and uses these logs along with checkpoints to restore a node's state after a restart.</li>
</ol>
<h2><a class="anchor" id="autotoc_md147"></a>
Why Checkpointing and Recovery?</h2>
<ol type="1">
<li><b>Prevent Infinite Logs:</b> The consensus process (Chapter 3) generates many messages (Pre-Prepare, Prepare, Commit) for each transaction. Storing all these messages forever would consume huge amounts of disk space. Checkpointing allows replicas to agree that "we all know the state up to transaction #1,000,000 is correct," so they can safely delete older messages and log entries before that point.</li>
<li><b>Speed Up Recovery:</b> If a node crashes and restarts, loading the latest agreed-upon checkpoint is much faster than re-processing every transaction from the beginning. The node only needs to replay the transactions and messages that occurred <em>after</em> the last checkpoint using the recovery logs.</li>
</ol>
<p><b>Analogy:</b> Imagine taking meeting minutes. Instead of keeping one massive document with every word ever spoken, you periodically summarize the key decisions and outcomes (a checkpoint). If someone joins late, they can read the latest summary and then catch up on the discussion since that summary (recovery log) instead of reading the entire history.</p>
<h2><a class="anchor" id="autotoc_md148"></a>
Meet the Save Game Coordinator: <code>CheckPointManager</code></h2>
<p>The <code>CheckPointManager</code> is responsible for orchestrating the process of creating these agreed-upon save points, called <b>stable checkpoints</b>.</p>
<p><b>Key Jobs:</b></p>
<ol type="1">
<li><b>Initiate Checkpoints:</b> At regular intervals (e.g., every <code>N</code> transactions, defined by <code>CheckPointWaterMark</code> in the configuration), it calculates a "fingerprint" (a hash) of the current database state.</li>
<li><b>Exchange Proofs:</b> It broadcasts this hash in a <code>CHECKPOINT</code> message to other replicas. It also collects <code>CHECKPOINT</code> messages from others.</li>
<li><b>Determine Stability:</b> It checks if enough replicas (<code>2f+1</code>) have sent <code>CHECKPOINT</code> messages agreeing on the <em>same hash</em> for the <em>same sequence number</em>.</li>
<li><b>Announce Stable Checkpoint:</b> Once agreement is reached, it declares that sequence number as the new <code>StableCheckpoint</code>. This is the "save point" everyone agrees on.</li>
<li><b>Inform Others:</b> It provides the latest stable checkpoint number (<code>GetStableCheckpoint</code>) to other components like <code>Recovery</code> so they know which old logs can be cleaned up.</li>
</ol>
<p><b>Analogy:</b> The <code>CheckPointManager</code> is like the game asking all players, "Everyone agrees we've reached Level 5 with 1000 gold, right? Send proof!" Once enough players send proof confirming the same state, the game declares "Level 5, 1000 gold" as an official save point.</p>
<h2><a class="anchor" id="autotoc_md149"></a>
How Checkpointing Works (Simplified)</h2>
<p>Let's say the checkpoint interval (<code>CheckPointWaterMark</code>) is 100 sequences.</p>
<ol type="1">
<li><b>Reach Checkpoint Sequence:</b> Transactions are executed, and the system reaches sequence number 100.</li>
<li><b>Calculate Hash:</b> Each replica's <code>CheckPointManager</code> calculates a hash representing the state after executing transaction 100.</li>
<li><p class="startli"><b>Broadcast Checkpoint Message:</b> Each replica broadcasts a <code>CHECKPOINT</code> message containing <code>seq=100</code> and its calculated <code>hash</code>.</p>
<p class="startli">```cpp // Simplified from <a class="el" href="../../df/d98/checkpoint__manager_8cpp.html">platform/consensus/ordering/pbft/checkpoint_manager.cpp</a> void CheckPointManager::BroadcastCheckPoint(uint64_t seq, const std::string&amp; hash, ...) { CheckPointData checkpoint_data; // Create a Request message of type CHECKPOINT std::unique_ptr&lt;Request&gt; checkpoint_request = NewRequest( Request::TYPE_CHECKPOINT, Request(), config_.GetSelfInfo().id());</p>
<p class="startli">checkpoint_data.set_seq(seq); // Set the sequence number (e.g., 100) checkpoint_data.set_hash(hash); // Set the calculated state hash</p>
<p class="startli">// Add a digital signature to prove it's from this replica if (verifier_) { // ... sign the hash ... *checkpoint_data.mutable_hash_signature() = signature; }</p>
<p class="startli">// Put the checkpoint data into the Request message checkpoint_data.SerializeToString(checkpoint_request-&gt;mutable_data()); // Send it to all other replicas replica_communicator_-&gt;BroadCast(*checkpoint_request); } ```</p>
<p class="startli">This function creates the <code>CHECKPOINT</code> message, including the sequence number and hash, signs it, and broadcasts it using the <code>ReplicaCommunicator</code> from Chapter 2.</p>
</li>
<li><p class="startli"><b>Process Incoming Checkpoints:</b> Each <code>CheckPointManager</code> receives <code>CHECKPOINT</code> messages from others via its <code>ProcessCheckPoint</code> method.</p>
<p class="startli">```cpp // Simplified from <a class="el" href="../../df/d98/checkpoint__manager_8cpp.html">platform/consensus/ordering/pbft/checkpoint_manager.cpp</a> int CheckPointManager::ProcessCheckPoint(std::unique_ptr&lt;Context&gt; context,
                                             std::unique_ptr&lt;Request&gt; request) { CheckPointData checkpoint_data; if (!checkpoint_data.ParseFromString(request-&gt;data())) { /* error */ return -2; }</p>
<p class="startli">uint64_t checkpoint_seq = checkpoint_data.seq(); // e.g., 100 std::string received_hash = checkpoint_data.hash(); uint32_t sender_id = request-&gt;sender_id();</p>
<p class="startli">// Verify the signature on the message if (verifier_) { if (!verifier_-&gt;VerifyMessage(received_hash, checkpoint_data.hash_signature())) { LOG(ERROR) &lt;&lt; "Invalid signature on checkpoint message"; return -2; } }</p>
<p class="startli">// Record that this sender sent this hash for this sequence number { std::lock_guard&lt;std::mutex&gt; lk(mutex_); // sender_ckpt_ is like: map&lt;(seq, hash), set&lt;sender_id&gt;&gt; auto key = std::make_pair(checkpoint_seq, received_hash); sender_ckpt_[key].insert(sender_id); // sign_ckpt_ stores the signatures for potential proof later sign_ckpt_[key].push_back(checkpoint_data.hash_signature()); new_data_++; // Flag that new checkpoint data arrived } Notify(); // Wake up the stability checking thread return 0; } ```</p>
<p class="startli">This function receives a <code>CHECKPOINT</code> message, validates it, and records which replica sent which hash for which sequence number.</p>
</li>
<li><p class="startli"><b>Check for Stability:</b> A background thread (<code>UpdateStableCheckPointStatus</code>) periodically checks if any sequence number has received enough matching proofs.</p>
<p class="startli">```cpp // Simplified from <a class="el" href="../../df/d98/checkpoint__manager_8cpp.html">platform/consensus/ordering/pbft/checkpoint_manager.cpp</a> void CheckPointManager::UpdateStableCheckPointStatus() { while (!stop_) { // Wait until new checkpoint data arrives (or timeout) if (!Wait()) continue;</p>
<p class="startli">uint64_t new_stable_seq = 0; std::string new_stable_hash;</p>
<p class="startli">{ // Lock to check the collected checkpoint data std::lock_guard&lt;std::mutex&gt; lk(mutex_); // Iterate through all (seq, hash) pairs we have seen for (auto const&amp; [key, senders] : sender_ckpt_) { uint64_t seq = key.first; std::string hash = key.second; // Check if enough replicas sent this exact (seq, hash) pair if (senders.size() &gt;= config_.GetMinDataReceiveNum()) { // MinDataReceiveNum is 2f+1 // Found a potentially stable checkpoint! if (seq &gt; new_stable_seq) { // Keep track of the highest one found new_stable_seq = seq; new_stable_hash = hash; } } } new_data_ = 0; // Reset the new data flag } // Unlock</p>
<p class="startli">// If we found a new stable checkpoint higher than the current one... if (current_stable_seq_ &lt; new_stable_seq) { std::lock_guard&lt;std::mutex&gt; lk(mutex_); // Store the proof (signatures) for this stable checkpoint stable_ckpt_.set_seq(new_stable_seq); stable_ckpt_.set_hash(new_stable_hash); // ... copy signatures from sign_ckpt_ to stable_ckpt_ ...</p>
<p class="startli">// Update the official stable checkpoint sequence number current_stable_seq_ = new_stable_seq; LOG(INFO) &lt;&lt; "New stable checkpoint reached: " &lt;&lt; current_stable_seq_;</p>
<p class="startli">// Clean up old checkpoint data before this sequence number // ... remove entries from sender_ckpt_ and sign_ckpt_ ... } // UpdateStableCheckPointCallback(current_stable_seq_); // Notify others } } ```</p>
<p class="startli">This thread checks the <code>sender_ckpt_</code> map. If it finds a <code>(seq, hash)</code> pair that has been confirmed by at least <code>2f+1</code> replicas, and this <code>seq</code> is higher than the current stable checkpoint, it updates <code>current_stable_seq_</code>.</p>
</li>
<li><b>Result:</b> <code>current_stable_seq_</code> now holds the sequence number of the latest agreed-upon save point (e.g., 100).</li>
</ol>
<h2><a class="anchor" id="autotoc_md150"></a>
Meet the Journal Keeper &amp; Restorer: <code>Recovery</code></h2>
<p>The <code>Recovery</code> component handles two main jobs:</p>
<ol type="1">
<li><b>Write-Ahead Logging (Journaling):</b> It writes important consensus messages (<code>PRE-PREPARE</code>, <code>PREPARE</code>, <code>COMMIT</code>, sometimes others) to a log file <em>before</em> they are fully processed. This is called a Write-Ahead Log (WAL). If the system crashes mid-operation, this log ensures we know what was happening.</li>
<li><b>State Restoration:</b> When a replica starts, the <code>Recovery</code> component reads the last known stable checkpoint (obtained from <code>CheckPointManager</code>) and then reads the WAL files <em>after</em> that checkpoint. It replays the messages found in the WAL to bring the replica's consensus state back up to speed quickly.</li>
</ol>
<p><b>Analogy:</b> The <code>Recovery</code> component is like keeping a detailed diary (WAL) of every important step you take after your last game save (checkpoint). If the game crashes, you load the save, read your diary from that point onwards, and quickly re-do those steps to get back to where you were.</p>
<h2><a class="anchor" id="autotoc_md151"></a>
How Recovery Works (Simplified)</h2>
<p><b>1. Logging Messages (Write-Ahead Log):</b></p>
<p>The <code>ConsensusManager</code> passes relevant incoming consensus messages to <code>Recovery::AddRequest</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from platform/consensus/recovery/recovery.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> Recovery::AddRequest(<span class="keyword">const</span> Context* context, <span class="keyword">const</span> Request* request) {</div>
<div class="line">  <span class="keywordflow">if</span> (!recovery_enabled_) <span class="keywordflow">return</span>; <span class="comment">// Only log if enabled</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Decide which message types are important enough to log for recovery</span></div>
<div class="line">  <span class="keywordflow">switch</span> (request-&gt;type()) {</div>
<div class="line">    <span class="keywordflow">case</span> Request::TYPE_PRE_PREPARE:</div>
<div class="line">    <span class="keywordflow">case</span> Request::TYPE_PREPARE:</div>
<div class="line">    <span class="keywordflow">case</span> Request::TYPE_COMMIT:</div>
<div class="line">    <span class="comment">// case Request::TYPE_CHECKPOINT: // Checkpoint messages might also be logged</span></div>
<div class="line">      <span class="comment">// If it&#39;s an important type, write it to the log file</span></div>
<div class="line">      WriteLog(context, request);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">      <span class="comment">// Ignore other message types for logging purposes</span></div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Recovery::WriteLog(<span class="keyword">const</span> Context* context, <span class="keyword">const</span> Request* request) {</div>
<div class="line">  std::string request_data;</div>
<div class="line">  request-&gt;SerializeToString(&amp;request_data); <span class="comment">// Convert Request to string</span></div>
<div class="line"> </div>
<div class="line">  std::string signature_data;</div>
<div class="line">  context-&gt;signature.SerializeToString(&amp;signature_data); <span class="comment">// Convert Signature to string</span></div>
<div class="line"> </div>
<div class="line">  std::unique_lock&lt;std::mutex&gt; lk(mutex_); <span class="comment">// Protect buffer access</span></div>
<div class="line">  <span class="comment">// Track min/max sequence numbers seen in this log file (for file naming)</span></div>
<div class="line">  <span class="comment">// ... update min_seq_, max_seq_ ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Append the length-prefixed data to an in-memory buffer first</span></div>
<div class="line">  AppendData(request_data);</div>
<div class="line">  AppendData(signature_data);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Maybe write the buffer to the actual disk file if it&#39;s full enough</span></div>
<div class="line">  MayFlush();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Recovery::AppendData(<span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">  <span class="keywordtype">size_t</span> len = <a class="code hl_variable" href="../../df/d04/namespacetest.html#af9ed409051d2739c4b81443db738de3b">data</a>.size();</div>
<div class="line">  <span class="comment">// Write the length of the data first...</span></div>
<div class="line">  buffer_.append(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;len), <span class="keyword">sizeof</span>(len));</div>
<div class="line">  <span class="comment">// ...then write the data itself.</span></div>
<div class="line">  buffer_.append(data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Recovery::Flush() {</div>
<div class="line">  <span class="comment">// Actually write the buffered data to the log file on disk</span></div>
<div class="line">  <span class="keywordtype">size_t</span> len = buffer_.size();</div>
<div class="line">  <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Write a marker indicating the size of the chunk being written</span></div>
<div class="line">  Write(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;len), <span class="keyword">sizeof</span>(len));</div>
<div class="line">  <span class="comment">// Write the buffered data</span></div>
<div class="line">  Write(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(buffer_.c_str()), len);</div>
<div class="line">  buffer_.clear(); <span class="comment">// Clear the memory buffer</span></div>
<div class="line">  fsync(fd_); <span class="comment">// Ensure data is physically written to disk</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacetest_html_af9ed409051d2739c4b81443db738de3b"><div class="ttname"><a href="../../df/d04/namespacetest.html#af9ed409051d2739c4b81443db738de3b">test.data</a></div><div class="ttdeci">dict data</div><div class="ttdef"><b>Definition</b> <a href="../../df/dba/test_8py_source.html#l00022">test.py:22</a></div></div>
</div><!-- fragment --><p><code>AddRequest</code> filters messages. <code>WriteLog</code> serializes the message and its context (like the signature) and calls <code>AppendData</code>. <code>AppendData</code> adds the data (with its length) to a <code>buffer_</code>. <code>Flush</code> writes the buffer content to the current log file (<code>fd_</code>) on disk, prefixed by the total buffer size. This length prefixing helps when reading the log back later.</p>
<p><b>2. Log File Management (Triggered by Checkpoints):</b></p>
<p>The <code>Recovery</code> component has a background thread (<code>UpdateStableCheckPoint</code>) that periodically checks the latest stable checkpoint from <code>CheckPointManager</code>. When the stable checkpoint advances, it closes the current log file and renames it to include the checkpoint number, then starts a new empty log file. This keeps logs organized by checkpoint periods.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from platform/consensus/recovery/recovery.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> Recovery::UpdateStableCheckPoint() {</div>
<div class="line">  <span class="keywordflow">while</span> (!stop_) {</div>
<div class="line">    <span class="comment">// Get the latest stable checkpoint number from CheckPointManager</span></div>
<div class="line">    int64_t latest_ckpt = checkpoint_-&gt;GetStableCheckpoint();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (last_ckpt_ == latest_ckpt) {</div>
<div class="line">      <span class="comment">// No change, wait a while</span></div>
<div class="line">      sleep(recovery_ckpt_time_s_);</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Checkpoint advanced! Finish the current log file.</span></div>
<div class="line">    last_ckpt_ = latest_ckpt;</div>
<div class="line">    FinishFile(latest_ckpt);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Recovery::FinishFile(int64_t seq) {</div>
<div class="line">  std::unique_lock&lt;std::mutex&gt; lk(mutex_);</div>
<div class="line">  Flush(); <span class="comment">// Write any remaining buffered data</span></div>
<div class="line">  close(fd_); <span class="comment">// Close the current log file descriptor</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Generate a new name for the file, including the checkpoint seq</span></div>
<div class="line">  <span class="comment">// Example: log_time_minSeq_maxSeq_ckptSeq.log</span></div>
<div class="line">  std::string final_file_path = GenerateFile(seq, min_seq_, max_seq_);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rename the old log file to its final name</span></div>
<div class="line">  std::rename(file_path_.c_str(), final_file_path.c_str());</div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Finalized log file: &quot;</span> &lt;&lt; final_file_path;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reset sequence tracking for the new file</span></div>
<div class="line">  min_seq_ = -1;</div>
<div class="line">  max_seq_ = -1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Generate the name for the *next* log file (doesn&#39;t include min/max yet)</span></div>
<div class="line">  std::string next_file_path = GenerateFile(seq, -1, -1);</div>
<div class="line">  file_path_ = next_file_path;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Open the new empty log file</span></div>
<div class="line">  OpenFile(file_path_);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This ensures that log files are neatly packaged based on the stable checkpoints. <code>GenerateFile</code> creates filenames encoding the checkpoint sequence and the range of sequence numbers contained within.</p>
<p><b>3. Replaying Logs on Restart:</b></p>
<p>When a node starts up, the main consensus logic calls <code>Recovery::ReadLogs</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Simplified from platform/consensus/recovery/recovery.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> Recovery::ReadLogs(</div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> SystemInfoData&amp; data)&gt; system_callback, <span class="comment">// For system info</span></div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(std::unique_ptr&lt;Context&gt; context, <span class="comment">// Callback to replay</span></div>
<div class="line">                       std::unique_ptr&lt;Request&gt; request)&gt; call_back)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!recovery_enabled_) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  std::unique_lock&lt;std::mutex&gt; lk(mutex_); <span class="comment">// Protect file access</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 1. Find relevant log files (based on the latest stable checkpoint)</span></div>
<div class="line">  <span class="keyword">auto</span> recovery_files_pair = GetRecoveryFiles();</div>
<div class="line">  int64_t last_stable_ckpt = recovery_files_pair.second;</div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Starting recovery from stable checkpoint: &quot;</span> &lt;&lt; last_stable_ckpt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2. Iterate through the identified log files (sorted by time)</span></div>
<div class="line">  <span class="keywordtype">int</span> idx = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> path_pair : recovery_files_pair.first) {</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; path = path_pair.second;</div>
<div class="line">    <span class="comment">// Read messages from this specific file, only processing those AFTER the checkpoint</span></div>
<div class="line">    ReadLogsFromFiles(path, last_stable_ckpt, idx++, system_callback, call_back);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Recovery::ReadLogsFromFiles(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; path, int64_t ckpt, <span class="keywordtype">int</span> file_idx, <span class="comment">// ckpt = last stable checkpoint</span></div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> SystemInfoData&amp; data)&gt; system_callback,</div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(std::unique_ptr&lt;Context&gt; context,</div>
<div class="line">                       std::unique_ptr&lt;Request&gt; request)&gt; call_back)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path.c_str(), O_RDONLY); <span class="comment">// Open log file for reading</span></div>
<div class="line">  <span class="comment">// ... handle errors ...</span></div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Reading recovery log: &quot;</span> &lt;&lt; path;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read the first chunk (system info)</span></div>
<div class="line">  <span class="comment">// ... read size, read data, parse SystemInfoData ...</span></div>
<div class="line">  <span class="comment">// system_callback(info); // Pass system info back (e.g., view number)</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read subsequent chunks (contain pairs of Request + Signature)</span></div>
<div class="line">  <span class="keywordtype">size_t</span> chunk_len = 0;</div>
<div class="line">  <span class="keywordflow">while</span> (Read(fd, <span class="keyword">sizeof</span>(chunk_len), <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;chunk_len))) {</div>
<div class="line">      <span class="comment">// Read the whole chunk</span></div>
<div class="line">      std::string chunk_data;</div>
<div class="line">      <span class="keywordtype">char</span>* buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[chunk_len];</div>
<div class="line">      <span class="keywordflow">if</span> (!Read(fd, chunk_len, buf)) { <span class="comment">/* error */</span> <span class="keywordflow">break</span>; }</div>
<div class="line">      chunk_data = std::string(buf, chunk_len);</div>
<div class="line">      <span class="keyword">delete</span>[] buf;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Parse the chunk back into individual (Request, Signature) pairs</span></div>
<div class="line">      std::vector&lt;std::unique_ptr&lt;RecoveryData&gt;&gt; list = ParseData(chunk_data);</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Process each recovered message</span></div>
<div class="line">      <span class="keywordflow">for</span> (std::unique_ptr&lt;RecoveryData&gt;&amp; recovery_data : list) {</div>
<div class="line">         <span class="comment">// *** IMPORTANT: Only replay messages AFTER the last stable checkpoint ***</span></div>
<div class="line">         <span class="keywordflow">if</span> (ckpt &lt; recovery_data-&gt;request-&gt;seq()) {</div>
<div class="line">             recovery_data-&gt;request-&gt;set_is_recovery(<span class="keyword">true</span>); <span class="comment">// Mark as recovered msg</span></div>
<div class="line">             <span class="comment">// Use the callback to send the message back to the ConsensusManager</span></div>
<div class="line">             <span class="comment">// for processing (rebuilding its internal state)</span></div>
<div class="line">             call_back(std::move(recovery_data-&gt;context),</div>
<div class="line">                       std::move(recovery_data-&gt;request));</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">  close(fd);</div>
<div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Finished reading recovery log: &quot;</span> &lt;&lt; path;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>ReadLogs</code> first determines the latest stable checkpoint (<code>GetRecoveryFiles</code> finds the checkpoint number from the log filenames). It then iterates through the necessary log files. <code>ReadLogsFromFiles</code> reads the log data chunk by chunk, parses the messages, and crucially, uses the provided <code>call_back</code> function to send any message with a sequence number <em>greater than</em> the <code>ckpt</code> back to the consensus layer (Chapter 3) for processing. This rebuilds the node's state efficiently.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
How They Work Together</h2>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant NodeA as Replica Node A</div>
<div class="line">    participant Recov as Recovery (on Node A)</div>
<div class="line">    participant ChkptMgr as CheckPointManager (on Node A)</div>
<div class="line">    participant Storage as Storage Layer (on Node A)</div>
<div class="line">    participant OtherReplicas</div>
<div class="line"> </div>
<div class="line">    Note over NodeA: Running normally...</div>
<div class="line">    NodeA-&gt;&gt;+Recov: AddRequest(Commit Msg, Seq=99)</div>
<div class="line">    Recov-&gt;&gt;Recov: WriteLog (Append to buffer)</div>
<div class="line">    Recov--&gt;&gt;-NodeA: Return</div>
<div class="line">    NodeA-&gt;&gt;+Recov: AddRequest(Commit Msg, Seq=100)</div>
<div class="line">    Recov-&gt;&gt;Recov: WriteLog (Append to buffer, buffer full?)</div>
<div class="line">    Recov-&gt;&gt;Storage: Flush() -&gt; Write WAL to disk (log_..._-1_-1_0.log)</div>
<div class="line">    Recov--&gt;&gt;-NodeA: Return</div>
<div class="line"> </div>
<div class="line">    Note over NodeA: Sequence 100 is Checkpoint Interval</div>
<div class="line">    NodeA-&gt;&gt;+ChkptMgr: Initiate Checkpoint (Seq=100, Hash=H100)</div>
<div class="line">    ChkptMgr-&gt;&gt;OtherReplicas: Broadcast CHECKPOINT(100, H100)</div>
<div class="line">    OtherReplicas--&gt;&gt;ChkptMgr: Receive CHECKPOINT messages</div>
<div class="line">    ChkptMgr-&gt;&gt;ChkptMgr: ProcessCheckPoint messages</div>
<div class="line">    ChkptMgr-&gt;&gt;ChkptMgr: UpdateStableCheckPointStatus() -&gt; Stable=100</div>
<div class="line">    Note over ChkptMgr: Stable Checkpoint is now 100</div>
<div class="line">    ChkptMgr-&gt;&gt;Recov: (Background Thread) checkpoint_-&gt;GetStableCheckpoint() returns 100</div>
<div class="line">    Recov-&gt;&gt;Recov: FinishFile(100)</div>
<div class="line">    Recov-&gt;&gt;Storage: Rename log to log_..._min_max_100.log</div>
<div class="line">    Recov-&gt;&gt;Storage: OpenFile(log_..._-1_-1_100.log) - New empty log</div>
<div class="line"> </div>
<div class="line">    NodeA-&gt;&gt;+Recov: AddRequest(Commit Msg, Seq=101)</div>
<div class="line">    Recov-&gt;&gt;Recov: WriteLog (Append to new log buffer)</div>
<div class="line">    Recov--&gt;&gt;-NodeA: Return</div>
<div class="line"> </div>
<div class="line">    Note over NodeA: CRASH! Node A restarts...</div>
<div class="line"> </div>
<div class="line">    NodeA-&gt;&gt;+Recov: ReadLogs(callback_to_ConsensusManager)</div>
<div class="line">    Recov-&gt;&gt;Recov: GetRecoveryFiles() -&gt; finds latest stable checkpoint = 100</div>
<div class="line">    Recov-&gt;&gt;Storage: Find log files &gt;= checkpoint 100 (e.g., log_..._-1_-1_100.log)</div>
<div class="line">    Recov-&gt;&gt;Storage: Read log file(s)</div>
<div class="line">    Recov-&gt;&gt;Recov: ParseData -&gt; Find Commit Msg Seq=101</div>
<div class="line">    Recov-&gt;&gt;NodeA: callback(Context_101, Request_101)</div>
<div class="line">    Note over NodeA: ConsensusManager processes Seq 101 msg, state restored.</div>
<div class="line">    Recov--&gt;&gt;-NodeA: Recovery Complete</div>
</div><!-- fragment --><p>This diagram shows the interplay: <code>Recovery</code> logs messages during normal operation. <code>CheckPointManager</code> determines stable checkpoints. <code>Recovery</code> uses this information to finalize old log files. On restart, <code>Recovery</code> reads logs <em>after</em> the last stable checkpoint and replays them via the callback to quickly catch up.</p>
<h2><a class="anchor" id="autotoc_md153"></a>
Conclusion</h2>
<p>Checkpointing and Recovery are essential for the long-term stability and efficiency of ResilientDB.</p>
<ul>
<li><b>Checkpointing (<code>CheckPointManager</code>)</b> provides periodic, agreed-upon "save points" (stable checkpoints) of the database state. This allows old logs and consensus messages to be safely discarded, preventing infinite growth.</li>
<li><b>Recovery (<code>Recovery</code>)</b> uses Write-Ahead Logging (WAL) to record important consensus messages. After a crash, it uses the latest stable checkpoint and replays the messages from the WAL files since that checkpoint to quickly restore the node's state.</li>
<li>Together, they ensure that replicas can recover efficiently from failures without replaying the entire history and that log storage remains manageable.</li>
</ul>
<p>We've now journeyed through the core components of ResilientDB, from client interaction to storage and recovery. But how do we configure all these components? How do we tell ResilientDB which nodes are part of the network, which consensus algorithm to use, or where to store its data? That's the topic of our final chapter!</p>
<p><b>Next:</b> <a class="el" href="../../df/dca/md__2github_2workspace_2ecosystem_2ai-tools_2beacon_2content_2resilientdb_2chapters_208__resilientdb__configuration.html">Chapter 8: ResilientDB Configuration (ResDBConfig)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
