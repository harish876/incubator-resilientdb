#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: mutations</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/dfd/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2mutations.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">mutations</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>import { Callout } from "nextra/components"</p>
<h1><a class="anchor" id="autotoc_md944"></a>
Mutations</h1>
<p>Learn how to modify data with a GraphQL server</p>
<p>Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well.</p>
<p>In REST, any request might cause some side-effects on the server, but by convention, it's suggested that one doesn't use <code>GET</code> requests to modify data. GraphQL is similar—technically any field resolver could be implemented to cause a data write—but the <a href="https://spec.graphql.org/draft/#sel-GANRNDAB6DBmMn6D">GraphQL specification states</a> that "the resolution of fields other than top-level mutation fields must always be side effect-free and idempotent." Thus, for any spec-compliant GraphQL schemas, only the top-level fields in mutation operations are allowed to cause side effects.</p>
<p>On this page, you'll learn how to use mutation operations to write data using GraphQL, and do so in a way that supports client use cases.</p>
<p>&lt;Callout type="info"&gt; All of the features of GraphQL operations that apply to queries also apply to mutations, so review the <a href="../..//learn/queries/">Queries</a> page first before proceeding. &lt;/Callout&gt;</p>
<h2><a class="anchor" id="autotoc_md945"></a>
Add new data</h2>
<p>When creating new data with a REST API, you would send a <code>POST</code> request to a specific endpoint and include information about the entities to be created in the body of the request. GraphQL takes a different approach.</p>
<p>Let's look at an example mutation that's defined in our schema:</p>
<div class="fragment"><div class="line">enum Episode {</div>
<div class="line">  NEWHOPE</div>
<div class="line">  EMPIRE</div>
<div class="line">  JEDI</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">input ReviewInput {</div>
<div class="line">  stars: Int!</div>
<div class="line">  commentary: String</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type Mutation {</div>
<div class="line">  createReview(episode: Episode, review: ReviewInput!): Review</div>
<div class="line">}</div>
</div><!-- fragment --><p>Like queries, mutation fields are added to one of the <a href="https://spec.graphql.org/draft/#sec-Root-Operation-Types">root operation types</a> that provide an entry point to the API. In this case, we define the <code>createReview</code> field on the <code>Mutation</code> type.</p>
<p>Mutation fields can also accept arguments and you might notice that the <code>review</code> argument has an input type set to <code>ReviewInput</code>. This is known as <a href="../..//learn/schema/#input-object-types">Input Object type</a>, which allows us to pass in a structured object containing information the mutation can use instead of individual scalar values only.</p>
<p>As with queries, if the mutation field returns an Object type then you must specify a selection set of its fields in the operation:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true, &quot;variables&quot;: { &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: { &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; } } }</div>
<div class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {</div>
<div class="line">  createReview(episode: $ep, review: $review) {</div>
<div class="line">    stars</div>
<div class="line">    commentary</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While the <code>createReview</code> field could be defined with any valid output type in the schema, it's conventional to specify an output type that relates to whatever is modified during the mutation—in this case, the <code>Review</code> type. This can be useful for clients that need to fetch the new state of an object after an update.</p>
<p>Recall that GraphQL is meant to work with your existing code and data, so the actual creation of the review is up to you when clients send this operation to the GraphQL server. A hypothetical function that writes the new review to a database during a <code>createReview</code> mutation might look like this:</p>
<div class="fragment"><div class="line">const Mutation = {</div>
<div class="line">  createReview(_obj, args, context, _info) {</div>
<div class="line">    return context.db</div>
<div class="line">      .createNewReview(args.episode, args.review)</div>
<div class="line">      .then(reviewData =&gt; new Review(reviewData));</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><p>You can learn more about how GraphQL provides data for fields on the <a href="../..//learn/execution">Execution page</a>.</p>
<h2><a class="anchor" id="autotoc_md946"></a>
Update existing data</h2>
<p>Similarly, we use mutations to update existing data. To change a human's name, we'll define a new mutation field and set that field's output type to the <code>Human</code> type so we can return the updated human's information to client after the server successfully writes the data:</p>
<div class="fragment"><div class="line">type Mutation {</div>
<div class="line">  updateHumanName(id: ID!, name: String!): Human</div>
<div class="line">}</div>
</div><!-- fragment --><p>This operation will update Luke Skywalker's name:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true, &quot;variables&quot;: { &quot;id&quot;: &quot;1000&quot;, &quot;name&quot;: &quot;Luke Starkiller&quot; } }</div>
<div class="line">mutation UpdateHumanName($id: ID!, $name: String!) { </div>
<div class="line">  updateHumanName(id: $id, name: $name ) {</div>
<div class="line">    id</div>
<div class="line">    name</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md947"></a>
Purpose-built mutations</h2>
<p>The previous example demonstrates an important distinction from REST. To update a human's properties using a REST API, you would likely send any updated data to a generalized endpoint for that resource using a <code>PATCH</code> request. With GraphQL, instead of simply creating an <code>updateHuman</code> mutation, you can define more specific mutation fields such as <code>updateHumanName</code>that are designed for the task at hand.</p>
<p>Purpose-built mutation fields can help make a schema more expressive by allowing the input types for field arguments to be Non-Null types (a generic <code>updateHuman</code> mutation would likely need to accept many nullable arguments to handle different update scenarios). Defining this requirement in the schema also eliminates the need for other runtime logic to determine that the appropriate values were submitted to perform the client's desired write operation.</p>
<p>GraphQL also allows us to express relationships between data that would be more difficult to model semantically with a basic CRUD-style request. For example, a user may wish to save a personal rating for a film. While the rating belongs to the user and doesn't modify anything related to a film itself, we can ergonomically associate it with a <code>Film</code> object as follows:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true, &quot;variables&quot;: { &quot;episode&quot;: &quot;EMPIRE&quot;, &quot;rating&quot;: &quot;THUMBS_UP&quot; } }</div>
<div class="line">mutation RateFilm($episode: Episode!, $rating: FilmRating!) { </div>
<div class="line">  rateFilm(episode: $episode, rating: $rating) {</div>
<div class="line">    episode</div>
<div class="line">    viewerRating</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>As a general rule, a GraphQL API should be designed to help clients get and modify data in a way that makes sense for them, so the fields defined in a schema should be informed by those use cases.</p>
<h2><a class="anchor" id="autotoc_md948"></a>
Remove existing data</h2>
<p>Just as we can send a <code>DELETE</code> request to delete a resource with a REST API, we can use mutations to delete some existing data as well by defining another field on the <code>Mutation</code> type:</p>
<div class="fragment"><div class="line">type Mutation {</div>
<div class="line">  deleteStarship(id: ID!): ID!</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here's an example of the new mutation field:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true, &quot;variables&quot;: { &quot;id&quot;: &quot;3003&quot; } }</div>
<div class="line">mutation DeleteStarship($id: ID!) { </div>
<div class="line">  deleteStarship(id: $id)</div>
<div class="line">}</div>
</div><!-- fragment --><p>As with mutations that create and update data, the GraphQL specification doesn't indicate what should be returned from a successful mutation operation that deletes data, but we do have to specify some type as an output type for the field in the schema. Commonly, the deleted entity's ID or a payload object containing data about the entity will be used to indicate that the operation was successful.</p>
<h2><a class="anchor" id="autotoc_md949"></a>
Multiple fields in mutations</h2>
<p>A mutation can contain multiple fields, just like a query. There's one important distinction between queries and mutations, other than the name:</p>
<p><b>While query fields are executed in parallel, mutation fields run in series.</b></p>
<p>Let's look at an example:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">mutation { </div>
<div class="line">  firstShip: deleteStarship(id: &quot;3001&quot;)</div>
<div class="line">  secondShip: deleteStarship(id: &quot;3002&quot;)</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="https://spec.graphql.org/draft/#sec-Normal-and-Serial-Execution">Serial execution</a> of these top-level fields means that if we send two <code>deleteStarship</code> mutations in one request, the first is guaranteed to finish before the second begins, ensuring that we don't end up in a race condition with ourselves.</p>
<p>Note that serial execution of top-level <code>Mutation</code> fields differs from the notion of a database transaction. Some mutation fields may resolve successfully while others return errors, and there's no way for GraphQL to revert the successful portions of the operation when this happens. So in the previous example, if the first starship is removed successfully but the <code>secondShip</code> field raises an error, there is no built-in way for GraphQL to revert the execution of the <code>firstShip</code> field afterward.</p>
<h2><a class="anchor" id="autotoc_md950"></a>
Next steps</h2>
<p>To recap what we've learned about mutations:</p>
<ul>
<li>Clients can create, update, and delete data using a GraphQL API, depending on what capabilities are exposed in the schema</li>
<li>Depending on client requirements, mutations can be designed to accommodate granular use cases for write operations</li>
<li>Top-level fields on the <code>Mutation</code> type will execute serially, unlike fields on other types which are often executed in parallel</li>
</ul>
<p>Now that we know how to use a GraphQL server to read and write data, we're ready to learn how to fetch data in real time using <a href="../..//learn/subscriptions">subscriptions</a>. You may also wish to learn more about how GraphQL queries and mutations can be <a href="../..//learn/serving-over-http/">served over HTTP</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
