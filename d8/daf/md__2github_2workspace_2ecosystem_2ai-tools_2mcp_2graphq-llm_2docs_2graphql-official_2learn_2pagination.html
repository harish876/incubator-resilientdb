#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: pagination</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/daf/md__2github_2workspace_2ecosystem_2ai-tools_2mcp_2graphq-llm_2docs_2graphql-official_2learn_2pagination.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">pagination</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md951"></a>
Pagination</h1>
<p>Traverse lists of objects with a consistent field pagination model</p>
<p>A common use case in GraphQL is traversing the relationship between sets of objects. There are different ways that these relationships can be exposed in GraphQL, giving a varying set of capabilities to the client developer. On this page, we'll explore how fields may be paginated using a cursor-based connection model.</p>
<h2><a class="anchor" id="autotoc_md952"></a>
Plurals</h2>
<p>The simplest way to expose a connection between objects is with a field that returns a plural <a href="../..//learn/schema/#list">List type</a>. For example, if we wanted to get a list of R2-D2's friends, we could just ask for all of them:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">query {</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    friends {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md953"></a>
Slicing</h2>
<p>Quickly, though, we realize that there are additional behaviors a client might want. A client might want to be able to specify how many friends they want to fetch—maybe they only want the first two. So we'd want to expose something like this:</p>
<div class="fragment"><div class="line">query {</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    friends(first: 2) {</div>
<div class="line">      name</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>But if we just fetched the first two, we might want to paginate through the list as well; once the client fetches the first two friends, they might want to send a second request to ask for the next two friends. How can we enable that behavior?</p>
<h2><a class="anchor" id="autotoc_md954"></a>
Pagination and edges</h2>
<p>There are several ways we could do pagination:</p>
<ul>
<li>We could do something like <code>friends(first:2 offset:2)</code> to ask for the next two in the list.</li>
<li>We could do something like <code>friends(first:2 after:$friendId)</code>, to ask for the next two after the last friend we fetched.</li>
<li>We could do something like <code>friends(first:2 after:$friendCursor)</code>, where we get a cursor from the last item and use that to paginate.</li>
</ul>
<p>The approach described in the first bullet is classic <em>offset-based pagination</em>. However, this style of pagination can have performance and security downsides, especially for larger data sets. Additionally, if new records are added to the database after the user has made a request for a page of results, then offset calculations for subsequent pages may become ambiguous.</p>
<p>In general, we've found that <em>cursor-based pagination</em> is the most powerful of those designed. Especially if the cursors are opaque, either offset or ID-based pagination can be implemented using cursor-based pagination (by making the cursor the offset or the ID), and using cursors gives additional flexibility if the pagination model changes in the future. As a reminder that the cursors are opaque and their format should not be relied upon, we suggest base64 encoding them.</p>
<p>But that leads us to a problem—how do we get the cursor from the object? We wouldn't want the cursor to live on the <code>User</code> type; it's a property of the connection, not of the object. So we might want to introduce a new layer of indirection; our <code>friends</code> field should give us a list of edges, and an edge has both a cursor and the underlying node:</p>
<div class="fragment"><div class="line">query {</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    friends(first: 2) {</div>
<div class="line">      edges {</div>
<div class="line">        node {</div>
<div class="line">          name</div>
<div class="line">        }</div>
<div class="line">        cursor</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The concept of an edge also proves useful if there is information that is specific to the edge, rather than to one of the objects. For example, if we wanted to expose "friendship time" in the API, having it live on the edge is a natural place to put it.</p>
<h2><a class="anchor" id="autotoc_md955"></a>
End-of-list, counts, and connections</h2>
<p>Now we can paginate through the connection using cursors, but how do we know when we reach the end of the connection? We have to keep querying until we get an empty list back, but we'd like for the connection to tell us when we've reached the end so we don't need that additional request. Similarly, what if we want additional information about the connection itself, for example, how many friends does R2-D2 have in total?</p>
<p>To solve both of these problems, our <code>friends</code> field can return a connection object. The connection object will be an Object type that has a field for the edges, as well as other information (like total count and information about whether a next page exists). So our final query might look more like this:</p>
<div class="fragment"><div class="line">query {</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    friends(first: 2) {</div>
<div class="line">      totalCount</div>
<div class="line">      edges {</div>
<div class="line">        node {</div>
<div class="line">          name</div>
<div class="line">        }</div>
<div class="line">        cursor</div>
<div class="line">      }</div>
<div class="line">      pageInfo {</div>
<div class="line">        endCursor</div>
<div class="line">        hasNextPage</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that we also might include <code>endCursor</code> and <code>startCursor</code> in this <code>PageInfo</code> object. This way, if we don't need any of the additional information that the edge contains, we don't need to query for the edges at all, since we got the cursors needed for pagination from <code>pageInfo</code>. This leads to a potential usability improvement for connections; instead of just exposing the <code>edges</code> list, we could also expose a dedicated list of just the nodes, to avoid a layer of indirection.</p>
<h2><a class="anchor" id="autotoc_md956"></a>
Complete connection model</h2>
<p>Clearly, this is more complex than our original design of just having a plural! But by adopting this design, we've unlocked several capabilities for the client:</p>
<ul>
<li>The ability to paginate through the list.</li>
<li>The ability to ask for information about the connection itself, like <code>totalCount</code> or <code>pageInfo</code>.</li>
<li>The ability to ask for information about the edge itself, like <code>cursor</code> or <code>friendshipTime</code>.</li>
<li>The ability to change how our backend does pagination, since the user just uses opaque cursors.</li>
</ul>
<p>To see this in action, there's an additional field in the example schema, called <code>friendsConnection</code>, that exposes all of these concepts:</p>
<div class="fragment"><div class="line">interface Character {</div>
<div class="line">  id: ID!</div>
<div class="line">  name: String!</div>
<div class="line">  friends: [Character]</div>
<div class="line">  friendsConnection(first: Int, after: ID): FriendsConnection!</div>
<div class="line">  appearsIn: [Episode]!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type FriendsConnection {</div>
<div class="line">  totalCount: Int</div>
<div class="line">  edges: [FriendsEdge]</div>
<div class="line">  friends: [Character]</div>
<div class="line">  pageInfo: PageInfo!</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type FriendsEdge {</div>
<div class="line">  cursor: ID!</div>
<div class="line">  node: Character</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">type PageInfo {</div>
<div class="line">  startCursor: ID</div>
<div class="line">  endCursor: ID</div>
<div class="line">  hasNextPage: Boolean!</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can try it out in the example query. Try removing the <code>after</code> argument for the <code>friendsConnection</code> field to see how the pagination will be affected. Also, try replacing the <code>edges</code> field with the helper <code>friends</code> field on the connection, which lets you get directly to the list of friends without the additional edge layer of indirection, when appropriate for clients:</p>
<div class="fragment"><div class="line"># { &quot;graphiql&quot;: true }</div>
<div class="line">query {</div>
<div class="line">  hero {</div>
<div class="line">    name</div>
<div class="line">    friendsConnection(first: 2, after: &quot;Y3Vyc29yMQ==&quot;) {</div>
<div class="line">      totalCount</div>
<div class="line">      edges {</div>
<div class="line">        node {</div>
<div class="line">          name</div>
<div class="line">        }</div>
<div class="line">        cursor</div>
<div class="line">      }</div>
<div class="line">      pageInfo {</div>
<div class="line">        endCursor</div>
<div class="line">        hasNextPage</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md957"></a>
Connection specification</h2>
<p>To ensure a consistent implementation of this pattern, the Relay project has a formal <a href="https://relay.dev/graphql/connections.htm">specification</a> you can follow for building GraphQL APIs that use a cursor-based connection pattern - whether or not use you Relay.</p>
<h2><a class="anchor" id="autotoc_md958"></a>
Recap</h2>
<p>To recap these recommendations for paginating fields in a GraphQL schema:</p>
<ul>
<li>List fields that may return a lot of data should be paginated</li>
<li>Cursor-based pagination provides a stable pagination model for fields in a GraphQL schema</li>
<li>The cursor connection specification from the Relay project provides a consistent pattern for paginating the fields in a GraphQL schema </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
